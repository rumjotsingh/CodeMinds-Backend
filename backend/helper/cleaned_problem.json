[
  {
    "title": "Container With Most Water",
    "description": "Given **n** non-negative integers **height**, where each integer represents a point at coordinate **(i, height[i])**, draw **n** vertical lines such that the two endpoints of the line **i** are at **(i, height[i])** and **(i, 0)**. Find two lines that together with the x-axis form a container that can hold the most water.\n\n### Problem Statement\n\nYou are given an array **height** of length **n**. Return the maximum amount of water a container formed by two of these vertical lines can hold.\n\n- The container cannot be slanted.\n- **n** is at least 2.\n- The water contained is calculated as the area between two lines (min(height[left], height[right]) multiplied by the distance between them (right - left)).\n\n### Input\n\n- **height**: An array of non-negative integers (2 <= height.length <= 10^5).\n- Each element in **height** is within the range (0 <= height[i] <= 10^4).\n\n### Output\n\n- An integer representing the maximum area of water that can be contained.\n\n### Example\n\n**Input**: height = [1,8,6,2,5,4,8,3,7]  \n**Output**: 49  \n**Explanation**:  \nThe vertical lines are represented by the array [1,8,6,2,5,4,8,3,7]. The two lines that form the container with the most water are at indices 1 (height = 8) and 8 (height = 7). The area is min(8, 7) * (8 - 1) = 7 * 7 = 49.\n\n**Input**: height = [1,1]  \n**Output**: 1  \n**Explanation**:  \nThe two lines are both height 1. The area is min(1, 1) * (1 - 0) = 1 * 1 = 1.\n\n### Notes\n\n- The problem requires finding two lines that form the largest possible container area.\n- The area is calculated as the minimum of the two heights multiplied by the distance between them.\n- The solution must be efficient, ideally O(n) time complexity, where n is the length of the input array.\n- The problem is commonly used to introduce the two-pointer technique.\n\n### Real-World Context\n\nThis problem models scenarios like finding the optimal placement of two barriers to hold the maximum amount of water, such as in reservoir design or rainwater harvesting systems.",
    "difficulty": "MEDIUM",
    "tags": [
      "Google",
      "Amazon",
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "constraints": [
      "- 2 <= height.length <= 10^5",
      "- 0 <= height[i] <= 10^4",
      "- The area is calculated as min(height[left], height[right]) * (right - left).",
      "- The solution must be efficient (O(n) time complexity is optimal).",
      "- The container cannot be slanted."
    ],
    "examples": [
      {
        "input": "height = [1, 8, 6, 2, 5, 4, 8, 3, 7]",
        "output": "49",
        "explanation": "The two lines that form the container with the most water are at indices 1 (height = 8) and 8 (height = 7). The area is min(8, 7) * (8 - 1) = 7 * 7 = 49.\n\nVisual Path:\n- Initial: left=0 (1), right=8 (7), area=8. Move left.\n- left=1 (8), right=8 (7), area=49. Move right.\n- Continue until left >= right. Max area is 49."
      }
    ],
    "testcases": [
      {
        "input": "1,8,6,2,5,4,8,3,7",
        "output": "49",
        "isHidden": false
      },
      {
        "input": "1,1",
        "output": "1",
        "isHidden": false
      },
      {
        "input": "4,3,2,1,4",
        "output": "16",
        "isHidden": false
      },
      {
        "input": "1,2,1",
        "output": "2",
        "isHidden": true
      },
      {
        "input": "5,5,5,5",
        "output": "15",
        "isHidden": true
      }
    ],
    "hints": [
      "1. **Brute Force Approach**: Can you check every pair of lines to calculate the area and find the maximum? What is the time complexity of this approach?",
      "2. **Two Pointer Insight**: Start with the widest possible container (left=0, right=n-1). How can you move the pointers to potentially find a larger area?",
      "3. **Greedy Strategy**: At each step, move the pointer pointing to the shorter line inward. Why does this work?",
      "4. **Edge Cases**: Consider cases where all lines are the same height or where the array has the minimum size (2 elements)."
    ],
    "editorial": "## Editorial: Container With Most Water\n\n### Problem Recap\n\nGiven an array **height** of non-negative integers, find two lines that form the largest container area. The area is calculated as the minimum of the two heights multiplied by the distance between them.\n\n### Intuition\n\nTo maximize the area, we need to find two lines that are both tall and far apart. The brute force approach checks all pairs, but this is inefficient for large arrays. A smarter approach uses the two-pointer technique to reduce the time complexity to O(n).\n\n- Start with the widest possible container (left=0, right=n-1).\n- Calculate the area and move the pointer pointing to the shorter line inward, as moving the taller line cannot increase the area.\n\n### Approaches\n\n#### 1. Brute Force (Nested Loops)\n\n- **Idea**: Iterate through all pairs of indices (i, j) where i < j, and calculate the area for each pair.\n- **Steps**:\n  1. For each index **i** from 0 to **n-1**, iterate over **j** from **i+1** to **n-1**.\n  2. Calculate the area as min(height[i], height[j]) * (j - i).\n  3. Track the maximum area encountered.\n- **Time Complexity**: O(n²) due to nested loops.\n- **Space Complexity**: O(1).\n- **Pros**: Simple to implement.\n- **Cons**: Inefficient for large arrays (e.g., n = 10^5).\n\n#### 2. Two Pointer (Optimal)\n\n- **Idea**: Use two pointers starting at the ends of the array and move the pointer pointing to the shorter line inward.\n- **Steps**:\n  1. Initialize **left = 0**, **right = n-1**, and **max_area = 0**.\n  2. While **left < right**:\n     - Calculate the current area as min(height[left], height[right]) * (right - left).\n     - Update **max_area** if the current area is larger.\n     - Move the pointer pointing to the shorter line inward (left++ or right--).\n  3. Return **max_area**.\n- **Time Complexity**: O(n) for a single pass through the array.\n- **Space Complexity**: O(1).\n- **Pros**: Optimal time complexity, efficient for large arrays.\n- **Cons**: Requires understanding of the two-pointer technique.\n\n### Recommended Solution\n\nThe two-pointer approach is recommended for its O(n) time complexity and O(1) space complexity. It efficiently narrows down the search space by always moving the pointer pointing to the shorter line.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for the two-pointer approach, as we make a single pass through the array.\n- **Space Complexity**: O(1) for storing pointers and the maximum area.\n- **Constraints Handling**:\n  - Array size: 2 <= n <= 10^5 ensures the array is non-empty and manageable.\n  - Value range: 0 <= height[i] <= 10^4 fits within standard integer limits.\n\n### Edge Cases\n\n- **Minimum array size**: height = [1, 1] → 1.\n- **All elements equal**: height = [5, 5, 5, 5] → 15 (5 * 3).\n- **Large array**: height.length = 10^5 requires efficient O(n) solution.\n- **Peak in middle**: height = [1, 2, 1] → 2 (min(1, 1) * 2 = 2).\n\n### Implementation Notes\n\n- Initialize **max_area** to 0.\n- Use two pointers (**left** and **right**) starting at the ends of the array.\n- At each step, calculate the current area and update **max_area**.\n- Move the pointer pointing to the shorter line inward.\n- Loop until **left** and **right** meet.\n\n### Visual Explanation\n\nFor height = [1,8,6,2,5,4,8,3,7]:\n- Initial: left=0 (1), right=8 (7), area=min(1,7)*8=8. Move left.\n- left=1 (8), right=8 (7), area=min(8,7)*7=49. Move right.\n- left=1 (8), right=7 (3), area=min(8,3)*6=18. Move right.\n- Continue until left >= right. Maximum area encountered is 49.\n- Result: 49.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc maxArea(height []int) int {\n    // Write your Code here:\n    max_area := 0\n    left := 0\n    right := len(height) - 1\n    for left < right {\n        current_area := min(height[left], height[right]) * (right - left)\n        if current_area > max_area {\n            max_area = current_area\n        }\n        if height[left] < height[right] {\n            left++\n        } else {\n            right--\n        }\n    }\n    return max_area\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil || input == \"\" {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    numsStr := strings.Split(input, \",\")\n    heights := make([]int, len(numsStr))\n    for i, s := range numsStr {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        heights[i] = num\n    }\n    result := maxArea(heights)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        // Write your Code here:\n        int max_area = 0;\n        int left = 0;\n        int right = height.size() - 1;\n        while (left < right) {\n            int current_area = min(height[left], height[right]) * (right - left);\n            max_area = max(max_area, current_area);\n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return max_area;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line) || line.empty()) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        stringstream ss(line);\n        vector<int> heights;\n        int num;\n        char comma;\n        while (ss >> num) {\n            heights.push_back(num);\n            if (ss >> comma && comma != ',') {\n                cout << \"Invalid input format\" << endl;\n                return 1;\n            }\n        }\n        Solution sol;\n        int result = sol.maxArea(heights);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Calculates the maximum area of water that can be contained.\n     * @param height Array of non-negative integers\n     * @return Maximum area\n     */\n    public int maxArea(int[] height) {\n        // Write your Code here:\n        int max_area = 0;\n        int left = 0;\n        int right = height.length - 1;\n        while (left < right) {\n            int current_area = Math.min(height[left], height[right]) * (right - left);\n            max_area = Math.max(max_area, current_area);\n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return max_area;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String input = scanner.nextLine().trim();\n            String[] numsStr = input.split(\",\");\n            int[] heights = new int[numsStr.length];\n            for (int i = 0; i < numsStr.length; i++) {\n                heights[i] = Integer.parseInt(numsStr[i].trim());\n            }\n            Main main = new Main();\n            int result = main.maxArea(heights);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def maxArea(self, height):\n        \"\"\"\n        Calculates the maximum area of water that can be contained.\n        :param height: List of non-negative integers\n        :return: Maximum area\n        \"\"\"\n        # Write your Code here:\n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        while left < right:\n            current_area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, current_area)\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        return max_area\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        heights = [int(x) for x in line.split(\",\")]\n        sol = Solution()\n        result = sol.maxArea(heights)\n        print(result)\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Calculates the maximum area of water that can be contained.\n * @param {number[]} height - Array of non-negative integers\n * @return {number} - Maximum area\n */\nfunction maxArea(height) {\n    // Write your Code here:\n    let max_area = 0;\n    let left = 0;\n    let right = height.length - 1;\n    while (left < right) {\n        const current_area = Math.min(height[left], height[right]) * (right - left);\n        max_area = Math.max(max_area, current_area);\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return max_area;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const heights = line.split(\",\").map(num => parseInt(num.trim()));\n        const result = maxArea(heights);\n        console.log(result);\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc maxArea(height []int) int {\n    max_area := 0\n    left := 0\n    right := len(height) - 1\n    for left < right {\n        current_area := min(height[left], height[right]) * (right - left)\n        if current_area > max_area {\n            max_area = current_area\n        }\n        if height[left] < height[right] {\n            left++\n        } else {\n            right--\n        }\n    }\n    return max_area\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil || input == \"\" {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    numsStr := strings.Split(input, \",\")\n    heights := make([]int, len(numsStr))\n    for i, s := range numsStr {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        heights[i] = num\n    }\n    result := maxArea(heights)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int max_area = 0;\n        int left = 0;\n        int right = height.size() - 1;\n        while (left < right) {\n            int current_area = min(height[left], height[right]) * (right - left);\n            max_area = max(max_area, current_area);\n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return max_area;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line) || line.empty()) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        stringstream ss(line);\n        vector<int> heights;\n        int num;\n        char comma;\n        while (ss >> num) {\n            heights.push_back(num);\n            if (ss >> comma && comma != ',') {\n                cout << \"Invalid input format\" << endl;\n                return 1;\n            }\n        }\n        Solution sol;\n        int result = sol.maxArea(heights);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Calculates the maximum area of water that can be contained.\n     * @param height Array of non-negative integers\n     * @return Maximum area\n     */\n    public int maxArea(int[] height) {\n        int max_area = 0;\n        int left = 0;\n        int right = height.length - 1;\n        while (left < right) {\n            int current_area = Math.min(height[left], height[right]) * (right - left);\n            max_area = Math.max(max_area, current_area);\n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return max_area;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String input = scanner.nextLine().trim();\n            String[] numsStr = input.split(\",\");\n            int[] heights = new int[numsStr.length];\n            for (int i = 0; i < numsStr.length; i++) {\n                heights[i] = Integer.parseInt(numsStr[i].trim());\n            }\n            Main main = new Main();\n            int result = main.maxArea(heights);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def maxArea(self, height):\n        \"\"\"\n        Calculates the maximum area of water that can be contained.\n        :param height: List of non-negative integers\n        :return: Maximum area\n        \"\"\"\n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        while left < right:\n            current_area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, current_area)\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        return max_area\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        heights = [int(x) for x in line.split(\",\")]\n        sol = Solution()\n        result = sol.maxArea(heights)\n        print(result)\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Calculates the maximum area of water that can be contained.\n * @param {number[]} height - Array of non-negative integers\n * @return {number} - Maximum area\n */\nfunction maxArea(height) {\n    let max_area = 0;\n    let left = 0;\n    let right = height.length - 1;\n    while (left < right) {\n        const current_area = Math.min(height[left], height[right]) * (right - left);\n        max_area = Math.max(max_area, current_area);\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return max_area;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const heights = line.split(\",\").map(num => parseInt(num.trim()));\n        const result = maxArea(heights);\n        console.log(result);\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    }
  },
  {
    "title": "Remove Element",
    "description": "Given an array **nums** and a value **val**, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array - you must modify the input array in-place with O(1) extra memory.\n\n### Problem Statement\n\nRemove all occurrences of **val** from **nums** in-place, returning the new length of the array after removal. The order of elements can be changed. Elements beyond the new length are irrelevant.\n\n### Input\n\n- **nums**: An array of integers (0 <= nums.length <= 100).\n- **val**: An integer to be removed from **nums** (0 <= val <= 100).\n- Each element in **nums** is within the range (0 <= nums[i] <= 50).\n\n### Output\n\n- An integer representing the new length of **nums** after removal.\n- The array **nums** should be modified in-place such that all occurrences of **val** are removed.\n\n### Example\n\n**Input**: nums = [3,2,2,3], val = 3  \n**Output**: 2  \n**Explanation**:  \nYour function should return length = 2, with the first two elements of nums being 2. The elements beyond the returned length are irrelevant.\n\n**Input**: nums = [0,1,2,2,3,0,4,2], val = 2  \n**Output**: 5  \n**Explanation**:  \nYour function should return length = 5, with the first five elements containing 0, 1, 3, 0, and 4. The order of these elements can be arbitrary.\n\n### Notes\n\n- The problem requires in-place modification of the array.\n- The solution must use O(1) extra memory.\n- The order of elements can be changed.\n- Elements beyond the returned length are irrelevant.\n\n### Real-World Context\n\nThis problem models scenarios like filtering out specific values from a dataset in memory-constrained environments, or preprocessing data for algorithms that only need to consider a subset of elements.",
    "difficulty": "EASY",
    "tags": [
      "Google",
      "Amazon",
      "Array",
      "Two Pointers"
    ],
    "constraints": [
      "- 0 <= nums.length <= 100",
      "- 0 <= val <= 100",
      "- 0 <= nums[i] <= 50",
      "- Must modify the array in-place with O(1) extra memory",
      "- Order of elements can be changed"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 2, 3], val = 3",
        "output": "2",
        "explanation": "After removing all 3's, the array becomes [2,2,...] with new length 2."
      }
    ],
    "testcases": [
      {
        "input": "[3,2,2,3]:3",
        "output": "2",
        "isHidden": false
      },
      {
        "input": "[0,1,2,2,3,0,4,2]:2",
        "output": "5",
        "isHidden": false
      },
      {
        "input": "[]:0",
        "output": "0",
        "isHidden": true
      },
      {
        "input": "[1,1,1,1]:1",
        "output": "0",
        "isHidden": true
      },
      {
        "input": "[4,5,6,7]:8",
        "output": "4",
        "isHidden": true
      }
    ],
    "hints": [
      "1. **Two Pointers Approach**: Use one pointer to iterate through the array and another to track the position where non-val elements should be placed.",
      "2. **In-Place Modification**: Since order doesn't matter, you can swap elements to the end of the array when you find a val.",
      "3. **Edge Cases**: Consider empty arrays or arrays where all elements equal val.",
      "4. **Optimization**: Think about how to minimize the number of operations when val is rare in the array."
    ],
    "editorial": "## Editorial: Remove Element\n\n### Problem Recap\n\nGiven an array and a value, remove all instances of that value in-place, returning the new length of the array after removal.\n\n### Intuition\n\nThe key insight is that we don't need to actually delete elements from the array - we just need to move all non-val elements to the front and return the count of these elements. The remaining elements can be any value since they'll be ignored.\n\n### Approaches\n\n#### 1. Two Pointers (Optimal)\n\n- **Idea**: Use one pointer (i) to iterate through the array and another (k) to track the position where non-val elements should be placed.\n- **Steps**:\n  1. Initialize k = 0\n  2. For each element in nums:\n     - If the element ≠ val, copy it to nums[k] and increment k\n  3. Return k as the new length\n- **Time Complexity**: O(n) - single pass through the array\n- **Space Complexity**: O(1) - in-place modification\n- **Pros**: Simple and efficient\n- **Cons**: Modifies the original array\n\n#### 2. Swap with End (When Val is Rare)\n\n- **Idea**: When we encounter val, swap it with the last element and reduce the array size.\n- **Steps**:\n  1. Initialize i = 0 and n = nums.length\n  2. While i < n:\n     - If nums[i] == val, swap nums[i] with nums[n-1] and reduce n\n     - Else increment i\n  3. Return n\n- **Time Complexity**: O(n) - each element is checked at most once\n- **Space Complexity**: O(1)\n- **Pros**: Minimizes copy operations when val is rare\n- **Cons**: Changes the order of elements\n\n### Recommended Solution\n\nThe two pointer approach is recommended for its simplicity and efficiency. It works well regardless of how frequent val appears in the array.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for both approaches\n- **Space Complexity**: O(1) for both approaches\n- **Constraints Handling**:\n  - Array size up to 100 is easily manageable\n  - Value ranges fit within standard integer limits\n\n### Edge Cases\n\n- **Empty array**: Return 0\n- **All elements equal val**: Return 0\n- **No elements equal val**: Return original length\n- **Single element array**: Return 0 if it equals val, 1 otherwise\n\n### Implementation Notes\n\n- Initialize a pointer at the start of the array\n- Iterate through the array, copying non-val elements to the pointer position\n- Increment the pointer only when copying a non-val element\n- Return the pointer position as the new length",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc removeElement(nums []int, val int) int {\n\t// Write your code here\n\treturn 0\n}\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tif scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tparts := strings.Split(line, \":\")\n\t\tif len(parts) != 2 {\n\t\t\tfmt.Println(\"Invalid input format\")\n\t\t\treturn\n\t\t}\n\t\t\n\t\t// Parse nums array\n\t\tnumsStr := strings.TrimSpace(parts[0])\n\t\tvar nums []int\n\t\terr := json.Unmarshal([]byte(numsStr), &nums)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Invalid input format\")\n\t\t\treturn\n\t\t}\n\t\t\n\t\t// Parse val\n\t\tval, err := strconv.Atoi(strings.TrimSpace(parts[1]))\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Invalid input format\")\n\t\t\treturn\n\t\t}\n\t\t\n\t\tlength := removeElement(nums, val)\n\t\tfmt.Println(length)\n\t\t// For debugging: fmt.Println(nums[:length])\n\t}\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        // Write your code here\n        return 0;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        getline(cin, line);\n        size_t colon_pos = line.find(':');\n        if (colon_pos == string::npos) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        \n        string nums_str = line.substr(0, colon_pos);\n        string val_str = line.substr(colon_pos + 1);\n        \n        // Parse nums array\n        vector<int> nums;\n        nums_str = nums_str.substr(1, nums_str.size() - 2); // Remove brackets\n        stringstream ss(nums_str);\n        string num;\n        while (getline(ss, num, ',')) {\n            nums.push_back(stoi(num));\n        }\n        \n        int val = stoi(val_str);\n        Solution sol;\n        int len = sol.removeElement(nums, val);\n        cout << len << endl;\n        // For debugging: \n        // for (int i = 0; i < len; i++) cout << nums[i] << \" \";\n        // cout << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public int removeElement(int[] nums, int val) {\n        // Write your code here\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String input = scanner.nextLine().trim();\n            String[] parts = input.split(\":\");\n            String numsStr = parts[0];\n            int val = Integer.parseInt(parts[1]);\n            \n            // Parse array input\n            numsStr = numsStr.replaceAll(\"\\\\[\", \"\").replaceAll(\"\\\\]\", \"\");\n            String[] numStrings = numsStr.split(\",\");\n            int[] nums = new int[numStrings.length];\n            for (int i = 0; i < numStrings.length; i++) {\n                nums[i] = Integer.parseInt(numStrings[i].trim());\n            }\n            \n            Main main = new Main();\n            int len = main.removeElement(nums, val);\n            System.out.println(len);\n            // For debugging: System.out.println(Arrays.toString(Arrays.copyOfRange(nums, 0, len)));\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        :type nums: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        # Write your code here\n        return 0\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    import json\n    try:\n        line = sys.stdin.readline().strip()\n        nums_str, val_str = line.split(':')\n        nums = json.loads(nums_str)\n        val = int(val_str)\n        sol = Solution()\n        result = sol.removeElement(nums, val)\n        print(result)\n        # For debugging: print(nums[:result])\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Removes all instances of val from nums in-place\n * @param {number[]} nums - The input array\n * @param {number} val - The value to remove\n * @return {number} - The new length after removal\n */\nfunction removeElement(nums, val) {\n    // Write your code here\n    return 0;\n}\n\n// Input handling\nconst readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on('line', (line) => {\n    try {\n        const [numsStr, valStr] = line.split(':');\n        const nums = JSON.parse(numsStr);\n        const val = parseInt(valStr);\n        const len = removeElement(nums, val);\n        console.log(len);\n        // For debugging: console.log(nums.slice(0, len));\n    } catch (e) {\n        console.log('Invalid input format');\n        process.exit(1);\n    }\n    rl.close();\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc removeElement(nums []int, val int) int {\n\tk := 0\n\tfor i := 0; i < len(nums); i++ {\n\t\tif nums[i] != val {\n\t\t\tnums[k] = nums[i]\n\t\t\tk++\n\t\t}\n\t}\n\treturn k\n}\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tif scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tparts := strings.Split(line, \":\")\n\t\tif len(parts) != 2 {\n\t\t\tfmt.Println(\"Invalid input format\")\n\t\t\treturn\n\t\t}\n\t\t\n\t\t// Parse nums array\n\t\tnumsStr := strings.TrimSpace(parts[0])\n\t\tvar nums []int\n\t\terr := json.Unmarshal([]byte(numsStr), &nums)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Invalid input format\")\n\t\t\treturn\n\t\t}\n\t\t\n\t\t// Parse val\n\t\tval, err := strconv.Atoi(strings.TrimSpace(parts[1]))\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Invalid input format\")\n\t\t\treturn\n\t\t}\n\t\t\n\t\tlength := removeElement(nums, val)\n\t\tfmt.Println(length)\n\t}\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int k = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] != val) {\n                nums[k] = nums[i];\n                k++;\n            }\n        }\n        return k;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        getline(cin, line);\n        size_t colon_pos = line.find(':');\n        if (colon_pos == string::npos) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        \n        string nums_str = line.substr(0, colon_pos);\n        string val_str = line.substr(colon_pos + 1);\n        \n        // Parse nums array\n        vector<int> nums;\n        nums_str = nums_str.substr(1, nums_str.size() - 2); // Remove brackets\n        stringstream ss(nums_str);\n        string num;\n        while (getline(ss, num, ',')) {\n            nums.push_back(stoi(num));\n        }\n        \n        int val = stoi(val_str);\n        Solution sol;\n        int len = sol.removeElement(nums, val);\n        cout << len << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public int removeElement(int[] nums, int val) {\n        int k = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != val) {\n                nums[k] = nums[i];\n                k++;\n            }\n        }\n        return k;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String input = scanner.nextLine().trim();\n            String[] parts = input.split(\":\");\n            if (parts.length != 2) {\n                System.out.println(\"Invalid input format\");\n                System.exit(1);\n            }\n            \n            String numsStr = parts[0].trim();\n            int val = Integer.parseInt(parts[1].trim());\n            \n            // Handle empty array case\n            if (numsStr.equals(\"[]\")) {\n                System.out.println(0);\n                return;\n            }\n            \n            // Parse array input\n            numsStr = numsStr.replaceAll(\"\\\\[\", \"\").replaceAll(\"\\\\]\", \"\");\n            String[] numStrings = numsStr.split(\",\");\n            int[] nums = new int[numStrings.length];\n            for (int i = 0; i < numStrings.length; i++) {\n                nums[i] = Integer.parseInt(numStrings[i].trim());\n            }\n            \n            Main main = new Main();\n            int len = main.removeElement(nums, val);\n            System.out.println(len);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        :type nums: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        k = 0\n        for i in range(len(nums)):\n            if nums[i] != val:\n                nums[k] = nums[i]\n                k += 1\n        return k\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    import json\n    try:\n        line = sys.stdin.readline().strip()\n        nums_str, val_str = line.split(':')\n        nums = json.loads(nums_str)\n        val = int(val_str)\n        sol = Solution()\n        result = sol.removeElement(nums, val)\n        print(result)\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Removes all instances of val from nums in-place\n * @param {number[]} nums - The input array\n * @param {number} val - The value to remove\n * @return {number} - The new length after removal\n */\nfunction removeElement(nums, val) {\n    let k = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== val) {\n            nums[k] = nums[i];\n            k++;\n        }\n    }\n    return k;\n}\n\n// Input handling\nconst readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on('line', (line) => {\n    try {\n        const [numsStr, valStr] = line.split(':');\n        const nums = JSON.parse(numsStr);\n        const val = parseInt(valStr);\n        const len = removeElement(nums, val);\n        console.log(len);\n    } catch (e) {\n        console.log('Invalid input format');\n        process.exit(1);\n    }\n    rl.close();\n});"
    }
  },
  {
    "title": "Maximum Subarray",
    "description": "Given an integer array **nums**, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n### Problem Statement\n\nYou are given an array of integers **nums**. Find a contiguous subarray with the maximum sum and return that sum. A subarray must contain at least one element.\n\n### Input\n\n- **nums**: An array of integers (-2^31 <= nums[i] <= 2^31 - 1, 1 <= nums.length <= 10^5).\n\n### Output\n\n- An integer representing the maximum sum of any contiguous subarray.\n\n### Example\n\n**Input**: nums = [-2,1,-3,4,-1,2,1,-5,4]  \n**Output**: 6  \n**Explanation**: The subarray [4,-1,2,1] has the largest sum = 6.\n\n**Input**: nums = [1]  \n**Output**: 1  \n**Explanation**: The single element [1] has sum = 1.\n\n**Input**: nums = [-1,-2]  \n**Output**: -1  \n**Explanation**: The subarray [-1] has the largest sum = -1.\n\n### Notes\n\n- Use Kadane’s algorithm for an O(n) solution.\n- Consider edge cases like single-element arrays or all negative numbers.\n- The follow-up suggests a divide-and-conquer approach, but O(n) is optimal.\n\n### Real-World Context\n\nThis problem models scenarios like finding the maximum profit window in stock prices or identifying high-value segments in data streams.",
    "difficulty": "MEDIUM",
    "tags": [
      "Google",
      "Amazon",
      "Array",
      "Dynamic Programming",
      "Kadane’s Algorithm"
    ],
    "constraints": [
      "- 1 <= nums.length <= 10^5",
      "- -2^31 <= nums[i] <= 2^31 - 1",
      "- Return the maximum subarray sum as an integer.",
      "- Time complexity should be O(n).",
      "- Space complexity should be O(1)."
    ],
    "examples": [
      {
        "input": "nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum = 6.\n\nVisual Path:\n- Kadane’s: currentSum = 4, 3, 5, 6 at index 6, maxSum = 6."
      }
    ],
    "testcases": [
      {
        "input": "-2,1,-3,4,-1,2,1,-5,4",
        "output": "6",
        "isHidden": false
      },
      {
        "input": "1",
        "output": "1",
        "isHidden": false
      },
      {
        "input": "-1,-2",
        "output": "-1",
        "isHidden": false
      },
      {
        "input": "-2,-1",
        "output": "-1",
        "isHidden": true
      },
      {
        "input": "5,4,-1,7,8",
        "output": "23",
        "isHidden": true
      }
    ],
    "hints": [
      "1. **Brute Force**: Can you check all possible subarrays to find the maximum sum?",
      "2. **Kadane’s Algorithm**: Can you maintain a running sum that resets when it becomes negative?",
      "3. **Edge Cases**: Consider arrays with all negative numbers or a single element.",
      "4. **Optimization**: How can you solve this in one pass with constant space?"
    ],
    "editorial": "## Editorial: Maximum Subarray\n\n### Problem Recap\n\nFind the contiguous subarray with the maximum sum in an integer array **nums** and return that sum.\n\n### Intuition\n\nThe brute force approach of checking all subarrays is O(n^2), which is too slow. Instead, Kadane’s algorithm solves this in O(n) by maintaining a running sum that resets when it becomes negative, as a negative sum is unlikely to contribute to a maximum subarray.\n\n### Approaches\n\n#### 1. Brute Force\n\n- **Idea**: Compute the sum of every possible subarray.\n- **Time Complexity**: O(n^2).\n- **Space Complexity**: O(1).\n- **Cons**: Too slow for large arrays.\n\n#### 2. Kadane’s Algorithm\n\n- **Idea**: Iterate through the array, maintaining the maximum sum ending at each position.\n- **Steps**:\n  1. Initialize maxSum (global maximum) and currentSum (maximum ending at current position).\n  2. For each number:\n     - Update currentSum = max(nums[i], currentSum + nums[i]).\n     - Update maxSum = max(maxSum, currentSum).\n  3. Return maxSum.\n- **Time Complexity**: O(n).\n- **Space Complexity**: O(1).\n- **Pros**: Optimal and simple.\n\n#### 3. Divide and Conquer\n\n- **Idea**: Split the array into two halves, compute the maximum subarray sum for each half and across the middle.\n- **Time Complexity**: O(n log n).\n- **Space Complexity**: O(log n).\n- **Cons**: More complex and slower than Kadane’s.\n\n### Recommended Solution\n\nKadane’s algorithm is recommended for its O(n) time and O(1) space.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for Kadane’s.\n- **Space Complexity**: O(1).\n- **Constraints Handling**:\n  - Array size: 1 <= n <= 10^5.\n  - Value range: Fits 32-bit integers.\n\n### Edge Cases\n\n- **Single element**: nums = [1] → 1.\n- **All negative**: nums = [-1, -2] → -1.\n- **All positive**: nums = [1, 2] → 3.\n\n### Implementation Notes\n\n- Use long for currentSum to avoid overflow in intermediate sums.\n- Initialize maxSum to the first element or a very negative number.\n- Handle single-element arrays correctly.\n\n### Visual Explanation\n\nFor nums = [-2,1,-3,4,-1,2,1,-5,4]:\n- currentSum starts at -2, resets to 1, drops to -2, jumps to 4, etc.\n- maxSum tracks the highest value, ending at 6 for [4,-1,2,1].",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc maxSubArray(nums []int) int {\n    // Write your code here\n    return 0\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    numsStr := strings.Split(input, \",\")\n    nums := make([]int, len(numsStr))\n    for i, s := range numsStr {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        nums[i] = num\n    }\n    result := maxSubArray(nums)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        // Write your code here\n        return 0;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        stringstream ss(line);\n        vector<int> nums;\n        int num;\n        char comma;\n        while (ss >> num) {\n            nums.push_back(num);\n            if (ss >> comma && comma != ',') {\n                cout << \"Invalid input format\" << endl;\n                return 1;\n            }\n        }\n        Solution sol;\n        int result = sol.maxSubArray(nums);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Finds the maximum subarray sum.\n     * @param nums Array of integers\n     * @return Maximum subarray sum\n     */\n    public int maxSubArray(int[] nums) {\n        // Write your code here\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String[] numsStr = scanner.nextLine().trim().split(\",\");\n            int[] nums = new int[numsStr.length];\n            for (int i = 0; i < nums.length; i++) {\n                nums[i] = Integer.parseInt(numsStr[i].trim());\n            }\n            Main main = new Main();\n            int result = main.maxSubArray(nums);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def maxSubArray(self, nums):\n        \"\"\"\n        Finds the maximum subarray sum.\n        :param nums: List of integers\n        :return: Integer - Maximum subarray sum\n        \"\"\"\n        # Write your code here\n        return 0\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        nums = [int(x) for x in line.split(\",\")]\n        sol = Solution()\n        result = sol.maxSubArray(nums)\n        print(result)\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds the maximum subarray sum.\n * @param {number[]} nums - Array of integers\n * @return {number} - Maximum subarray sum\n */\nfunction maxSubArray(nums) {\n    // Write your code here\n    return 0;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const nums = line.trim().split(\",\").map(num => parseInt(num.trim()));\n        const result = maxSubArray(nums);\n        console.log(result);\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc maxSubArray(nums []int) int {\n    maxSum := nums[0]\n    currentSum := nums[0]\n    for _, num := range nums[1:] {\n        if currentSum+num > num {\n            currentSum += num\n        } else {\n            currentSum = num\n        }\n        if currentSum > maxSum {\n            maxSum = currentSum\n        }\n    }\n    return maxSum\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    numsStr := strings.Split(input, \",\")\n    nums := make([]int, len(numsStr))\n    for i, s := range numsStr {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        nums[i] = num\n    }\n    result := maxSubArray(nums)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int maxSum = nums[0];\n        int currentSum = nums[0];\n        for (int i = 1; i < nums.size(); i++) {\n            currentSum = max(nums[i], currentSum + nums[i]);\n            maxSum = max(maxSum, currentSum);\n        }\n        return maxSum;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        stringstream ss(line);\n        vector<int> nums;\n        int num;\n        char comma;\n        while (ss >> num) {\n            nums.push_back(num);\n            if (ss >> comma && comma != ',') {\n                cout << \"Invalid input format\" << endl;\n                return 1;\n            }\n        }\n        Solution sol;\n        int result = sol.maxSubArray(nums);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public int maxSubArray(int[] nums) {\n        int maxSum = nums[0];\n        int currentSum = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            currentSum = Math.max(nums[i], currentSum + nums[i]);\n            maxSum = Math.max(maxSum, currentSum);\n        }\n        return maxSum;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String[] numsStr = scanner.nextLine().trim().split(\",\");\n            int[] nums = new int[numsStr.length];\n            for (int i = 0; i < nums.length; i++) {\n                nums[i] = Integer.parseInt(numsStr[i].trim());\n            }\n            Main main = new Main();\n            int result = main.maxSubArray(nums);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def maxSubArray(self, nums):\n        max_sum = nums[0]\n        current_sum = nums[0]\n        for num in nums[1:]:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        nums = [int(x) for x in line.split(\",\")]\n        sol = Solution()\n        result = sol.maxSubArray(nums)\n        print(result)\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds the maximum subarray sum.\n * @param {number[]} nums - Array of integers\n * @return {number} - Maximum subarray sum\n */\nfunction maxSubArray(nums) {\n    let maxSum = nums[0];\n    let currentSum = nums[0];\n    for (let i = 1; i < nums.length; i++) {\n        currentSum = Math.max(nums[i], currentSum + nums[i]);\n        maxSum = Math.max(maxSum, currentSum);\n    }\n    return maxSum;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const nums = line.trim().split(\",\").map(num => parseInt(num.trim()));\n        const result = maxSubArray(nums);\n        console.log(result);\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    }
  },
  {
    "title": "Jump Game",
    "description": "Given an array of non-negative integers **nums**, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.\n\n### Problem Statement\n\nStarting at index 0, you can jump up to **nums[i]** steps forward from index **i**. Return **true** if you can reach the last index, **false** otherwise.\n\n### Input\n\n- **nums**: An array of non-negative integers (1 <= nums.length <= 3 * 10^4, 0 <= nums[i] <= 10^5).\n\n### Output\n\n- A boolean indicating whether the last index can be reached.\n\n### Example\n\n**Input**: nums = [2,3,1,1,4]  \n**Output**: true  \n**Explanation**: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n**Input**: nums = [3,2,1,0,4]  \n**Output**: false  \n**Explanation**: You will always arrive at index 3, where nums[3] = 0, making it impossible to proceed.\n\n### Notes\n\n- Use a greedy approach to track the furthest reachable index.\n- Consider edge cases like single-element arrays or arrays with zeros.\n\n### Real-World Context\n\nThis problem models scenarios like network routing, where each node has a maximum reach, or game mechanics involving jump distances.",
    "difficulty": "MEDIUM",
    "tags": [
      "Google",
      "Amazon",
      "Array",
      "Greedy"
    ],
    "constraints": [
      "- 1 <= nums.length <= 3 * 10^4",
      "- 0 <= nums[i] <= 10^5",
      "- Return true if the last index can be reached, false otherwise.",
      "- Time complexity should be O(n).",
      "- Space complexity should be O(1)."
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "true",
        "explanation": "Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\nVisual Path:\n- maxReach = 2, 4, 4, 4, 4 → reaches last index."
      }
    ],
    "testcases": [
      {
        "input": "2,3,1,1,4",
        "output": "true",
        "isHidden": false
      },
      {
        "input": "3,2,1,0,4",
        "output": "false",
        "isHidden": false
      },
      {
        "input": "0",
        "output": "true",
        "isHidden": false
      },
      {
        "input": "1,0,1",
        "output": "false",
        "isHidden": true
      },
      {
        "input": "100,0",
        "output": "true",
        "isHidden": true
      }
    ],
    "hints": [
      "1. **Brute Force**: Can you try all possible jumps from each position using DFS?",
      "2. **Greedy Approach**: Can you track the furthest index you can reach while iterating?",
      "3. **Edge Cases**: Consider arrays with a single element or zeros blocking the path.",
      "4. **Optimization**: How can you solve this in one pass without backtracking?"
    ],
    "editorial": "## Editorial: Jump Game\n\n### Problem Recap\n\nDetermine if you can reach the last index of an array **nums**, where **nums[i]** is the maximum jump length from index **i**.\n\n### Intuition\n\nA brute force DFS approach trying all jumps is O(2^n) and too slow. Instead, a greedy approach works in O(n) by tracking the furthest reachable index. If at any point the current index exceeds the furthest reachable index, we’re stuck.\n\n### Approaches\n\n#### 1. DFS/Backtracking\n\n- **Idea**: Try all possible jumps from each position.\n- **Time Complexity**: O(2^n).\n- **Space Complexity**: O(n).\n- **Cons**: Too slow.\n\n#### 2. Greedy\n\n- **Idea**: Track the furthest index you can reach while iterating.\n- **Steps**:\n  1. Initialize maxReach = nums[0].\n  2. For each index i (up to n-2):\n     - If i > maxReach, return false (stuck).\n     - Update maxReach = max(maxReach, i + nums[i]).\n  3. Return true if maxReach >= n-1.\n- **Time Complexity**: O(n).\n- **Space Complexity**: O(1).\n- **Pros**: Optimal and simple.\n\n#### 3. Dynamic Programming\n\n- **Idea**: Use DP to mark reachable indices.\n- **Time Complexity**: O(n^2) in worst case.\n- **Space Complexity**: O(n).\n- **Cons**: Slower than greedy.\n\n### Recommended Solution\n\nThe greedy approach is recommended for its O(n) time and O(1) space.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for greedy.\n- **Space Complexity**: O(1).\n- **Constraints Handling**:\n  - Array size: 1 <= n <= 3 * 10^4.\n  - Jump range: 0 <= nums[i] <= 10^5.\n\n### Edge Cases\n\n- **Single element**: nums = [0] → true.\n- **Zero blocks path**: nums = [1,0,1] → false.\n- **Large jumps**: nums = [100,0] → true.\n\n### Implementation Notes\n\n- Track maxReach and check if current index is reachable.\n- Stop at n-2, as the last index doesn’t need a jump.\n- Handle single-element arrays correctly.\n\n### Visual Explanation\n\nFor nums = [2,3,1,1,4]:\n- maxReach = 2, updates to 4 at index 1, reaches 4 → true.\nFor nums = [3,2,1,0,4]:\n- maxReach = 3, stuck at index 4 > 3 → false.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n\nfunc canJump(nums []int) bool {\n    // Write your code here\n    return false\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    numsStr := strings.Split(input, \",\")\n    nums := make([]int, len(numsStr))\n    for i, numStr := range numsStr {\n        num, err := strconv.Atoi(strings.TrimSpace(numStr))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        nums[i] = num\n    }\n    result := canJump(nums)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        // Write your code here\n        return false;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        stringstream ss(line);\n        vector<int> nums;\n        int num;\n        char comma;\n        while (ss >> num) {\n            nums.push_back(num);\n            if (ss >> comma && comma != ',') {\n                cout << \"Invalid input format\" << endl;\n                return 1;\n            }\n        }\n        Solution sol;\n        bool result = sol.canJump(nums);\n        cout << (result ? \"true\" : \"false\") << endl;  // Fixed syntax, lowercase output\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Determines if the last index can be reached.\n     * @param nums Array of non-negative integers\n     * @return True if last index is reachable\n     */\n    public boolean canJump(int[] nums) {\n        // Write your code here\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String[] numsStr = scanner.nextLine().trim().split(\",\");\n            int[] nums = new int[numsStr.length];\n            for (int i = 0; i < nums.length; i++) {\n                nums[i] = Integer.parseInt(numsStr[i].trim());\n            }\n            Main main = new Main();\n            boolean result = main.canJump(nums);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def canJump(self, nums):\n        \"\"\"\n        Determines if the last index can be reached.\n        :param nums: List of non-negative integers\n        :return: Boolean - True if last index is reachable\n        \"\"\"\n        # Write your code here\n        return False\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        nums = [int(x) for x in line.split(\",\")]\n        sol = Solution()\n        result = sol.canJump(nums)\n        sys.stdout.write(\"true\" if result else \"false\")  # Output lowercase true/false, no newline\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Determines if the last index can be reached.\n * @param {number[]} nums - Array of non-negative integers\n * @return {boolean} - True if last index is reachable\n */\nfunction canJump(nums) {\n    // Write your code here\n    return false;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const nums = line.trim().split(\",\").map(num => parseInt(num.trim()));\n        const result = canJump(nums);\n        console.log(result);\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc canJump(nums []int) bool {\n    maxReach := nums[0]\n    for i := 0; i < len(nums)-1 && i <= maxReach; i++ {\n        if i+nums[i] > maxReach {\n            maxReach = i + nums[i]\n        }\n        if maxReach >= len(nums)-1 {\n            return true\n        }\n    }\n    return maxReach >= len(nums)-1\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    numsStr := strings.Split(input, \",\")\n    nums := make([]int, len(numsStr))\n    for i, s := range numsStr {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        nums[i] = num\n    }\n    result := canJump(nums)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int maxReach = nums[0];\n        for (int i = 0; i < nums.size() - 1 && i <= maxReach; i++) {\n            maxReach = max(maxReach, i + nums[i]);\n            if (maxReach >= nums.size() - 1) return true;\n        }\n        return maxReach >= nums.size() - 1;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        stringstream ss(line);\n        vector<int> nums;\n        int num;\n        char comma;\n        while (ss >> num) {\n            nums.push_back(num);\n            if (ss >> comma && comma != ',') {\n                cout << \"Invalid input format\" << endl;\n                return 1;\n            }\n        }\n        Solution sol;\n        bool result = sol.canJump(nums);\n        cout << (result ? \"true\" : \"false\") << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public boolean canJump(int[] nums) {\n        int maxReach = nums[0];\n        for (int i = 0; i < nums.length - 1 && i <= maxReach; i++) {\n            maxReach = Math.max(maxReach, i + nums[i]);\n            if (maxReach >= nums.length - 1) return true;\n        }\n        return maxReach >= nums.length - 1;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String[] numsStr = scanner.nextLine().trim().split(\",\");\n            int[] nums = new int[numsStr.length];\n            for (int i = 0; i < nums.length; i++) {\n                nums[i] = Integer.parseInt(numsStr[i].trim());\n            }\n            Main main = new Main();\n            boolean result = main.canJump(nums);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def canJump(self, nums):\n        max_reach = nums[0]\n        for i in range(len(nums) - 1):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n            if max_reach >= len(nums) - 1:\n                return True\n        return max_reach >= len(nums) - 1\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        nums = [int(x) for x in line.split(\",\")]\n        sol = Solution()\n        result = sol.canJump(nums)\n        sys.stdout.write(\"true\" if result else \"false\")  # Output lowercase true/false, no newline\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Determines if the last index can be reached.\n * @param {number[]} nums - Array of non-negative integers\n * @return {boolean} - True if last index is reachable\n */\nfunction canJump(nums) {\n    let maxReach = nums[0];\n    for (let i = 0; i < nums.length - 1 && i <= maxReach; i++) {\n        maxReach = Math.max(maxReach, i + nums[i]);\n        if (maxReach >= nums.length - 1) return true;\n    }\n    return maxReach >= nums.length - 1;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const nums = line.trim().split(\",\").map(num => parseInt(num.trim()));\n        const result = canJump(nums);\n        console.log(result);\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    }
  },
  {
    "title": "Pow(x, n)",
    "description": "Implement **pow(x, n)**, which calculates **x** raised to the power **n** (i.e., **x^n**).\n\n### Problem Statement\n\nGiven a floating-point number **x** and a 32-bit signed integer **n**, compute **x^n**. Return the result as a floating-point number.\n\n### Input\n\n- **x**: A floating-point number (-100.0 < x < 100.0).\n- **n**: A 32-bit signed integer (-2^31 <= n <= 2^31 - 1).\n\n### Output\n\n- A floating-point number representing **x^n**.\n\n### Example\n\n**Input**: x = 2.00000, n = 10  \n**Output**: 1024.00000  \n**Explanation**: 2^10 = 1024.\n\n**Input**: x = 2.10000, n = 3  \n**Output**: 9.26100  \n**Explanation**: 2.1^3 = 2.1 * 2.1 * 2.1 = 9.261.\n\n**Input**: x = 2.00000, n = -2  \n**Output**: 0.25000  \n**Explanation**: 2^(-2) = 1/(2^2) = 1/4 = 0.25.\n\n### Notes\n\n- The solution should handle negative exponents by computing 1/x^|n|.\n- Use an efficient algorithm to achieve O(log n) time complexity.\n- Consider edge cases like x = 0, n = 0, or large |n|.\n\n### Real-World Context\n\nThis problem models computations in scientific applications, such as calculating compound interest or exponential growth.",
    "difficulty": "MEDIUM",
    "tags": [
      "Google",
      "Amazon",
      "Math",
      "Recursion",
      "Binary Exponentiation"
    ],
    "constraints": [
      "- -100.0 < x < 100.0",
      "- -2^31 <= n <= 2^31 - 1",
      "- Return a floating-point number with reasonable precision.",
      "- Time complexity should be O(log n).",
      "- Space complexity should be O(1) or O(log n) for recursive solutions."
    ],
    "examples": [
      {
        "input": "x = 2.00000, n = 10",
        "output": "1024.00000",
        "explanation": "2^10 = 1024.\n\nVisual Path:\n- n = 10 (binary 1010): Compute x^2, x^8, result = x^2 * x^8 = 1024."
      }
    ],
    "testcases": [
      {
        "input": "2.00000:10",
        "output": "1024.00000",
        "isHidden": false
      },
      {
        "input": "2.10000:3",
        "output": "9.26100",
        "isHidden": false
      },
      {
        "input": "2.00000:-2",
        "output": "0.25000",
        "isHidden": false
      },
      {
        "input": "1.00000:0",
        "output": "1.00000",
        "isHidden": true
      },
      {
        "input": "-2.00000:3",
        "output": "-8.00000",
        "isHidden": true
      }
    ],
    "hints": [
      "1. **Naive Approach**: Can you multiply x by itself n times? What’s the time complexity?",
      "2. **Binary Exponentiation**: Can you reduce the number of multiplications by using the binary representation of n?",
      "3. **Negative Exponents**: How can you handle negative n by computing 1/x^|n|?",
      "4. **Edge Cases**: Consider x = 0, n = 0, or very large |n|."
    ],
    "editorial": "## Editorial: Pow(x, n)\n\n### Problem Recap\n\nCompute **x^n** for a floating-point **x** and integer **n**, returning the result as a floating-point number. The solution must be efficient (O(log n)).\n\n### Intuition\n\nMultiplying **x** by itself **n** times is O(n), which is too slow for large **n**. Instead, use binary exponentiation, which reduces the problem to O(log n) by leveraging the binary representation of **n**.\n\n- **Binary Exponentiation**: If n = 10 (binary 1010), compute x^10 as x^8 * x^2, where each power is calculated by squaring.\n- **Negative Exponents**: For negative n, compute 1/x^|n|.\n\n### Approaches\n\n#### 1. Naive Multiplication\n\n- **Idea**: Multiply x by itself n times.\n- **Time Complexity**: O(n).\n- **Space Complexity**: O(1).\n- **Cons**: Too slow for large n.\n\n#### 2. Binary Exponentiation (Iterative)\n\n- **Idea**: Use n’s binary form to compute powers efficiently.\n- **Steps**:\n  1. Initialize result = 1.\n  2. If n is negative, set x = 1/x and n = -n.\n  3. While n > 0:\n     - If n is odd, multiply result by x.\n     - Square x and divide n by 2.\n  4. Return result.\n- **Time Complexity**: O(log n).\n- **Space Complexity**: O(1).\n- **Pros**: Efficient and simple.\n\n#### 3. Binary Exponentiation (Recursive)\n\n- **Idea**: Recursively compute x^(n/2) and square it, handling odd/even cases.\n- **Time Complexity**: O(log n).\n- **Space Complexity**: O(log n) due to recursion stack.\n\n### Recommended Solution\n\nThe iterative binary exponentiation approach is recommended for its O(log n) time and O(1) space.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(log n) for binary exponentiation.\n- **Space Complexity**: O(1) for iterative, O(log n) for recursive.\n- **Constraints Handling**:\n  - x range: Handled by floating-point arithmetic.\n  - n range: Fits 32-bit integers, handled by binary exponentiation.\n\n### Edge Cases\n\n- **n = 0**: Return 1.\n- **x = 0**: Valid for positive n, undefined for n < 0 (not applicable per constraints).\n- **Negative n**: Compute 1/x^|n|.\n- **Large |n|**: Binary exponentiation handles efficiently.\n\n### Implementation Notes\n\n- Use long for n to avoid integer overflow in intermediate steps.\n- Handle negative n by inverting x.\n- Ensure precision for floating-point results.\n\n### Visual Explanation\n\nFor x = 2, n = 10 (binary 1010):\n- result = 1, x = 2, n = 10.\n- n = 1010: Compute x^2, x^8, multiply result by x^2 * x^8 = 1024.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc myPow(x float64, n int) float64 {\n    // Write your code here\n    return 0\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil || input == \"\" || !strings.Contains(input, \":\") {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    parts := strings.Split(input, \":\")\n    x, err := strconv.ParseFloat(strings.TrimSpace(parts[0]), 64)\n    if err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    n, err := strconv.Atoi(strings.TrimSpace(parts[1]))\n    if err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := myPow(x, n)\n    fmt.Printf(\"%.5f\\n\", result)\n}",
      "C++": "#include <iostream>\n#include <sstream>\n#include <iomanip> \nusing namespace std;\n\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        // Write your code here\n        return 0;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line) || line.empty() || line.find(':') == string::npos) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        stringstream ss(line);\n        string xStr;\n        getline(ss, xStr, ':');\n        int n;\n        ss >> n;\n        double x = stod(xStr);\n        Solution sol;\n        double result = sol.myPow(x, n);\n        cout << fixed << setprecision(5) << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Computes x raised to power n.\n     * @param x Base\n     * @param n Exponent\n     * @return x^n\n     */\n    public double myPow(double x, int n) {\n        // Write your code here\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String input = scanner.nextLine().trim();\n            if (input.isEmpty() || !input.contains(\":\")) {\n                System.out.println(\"Invalid input format\");\n                System.exit(1);\n            }\n            String[] parts = input.split(\":\");\n            double x = Double.parseDouble(parts[0].trim());\n            int n = Integer.parseInt(parts[1].trim());\n            Main main = new Main();\n            double result = main.myPow(x, n);\n            System.out.printf(\"%.5f\\n\", result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def myPow(self, x, n):\n        \"\"\"\n        Computes x raised to power n.\n        :param x: float - Base\n        :param n: int - Exponent\n        :return: float - x^n\n        \"\"\"\n        # Write your code here\n        return 0\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        if not line or \":\" not in line:\n            print(\"Invalid input format\")\n            sys.exit(1)\n        x_str, n_str = line.split(\":\")\n        x = float(x_str.strip())\n        n = int(n_str.strip())\n        sol = Solution()\n        result = sol.myPow(x, n)\n        print(\"%.5f\" % result)\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Computes x raised to power n.\n * @param {number} x - Base\n * @param {number} n - Exponent\n * @return {number} - x^n\n */\nfunction myPow(x, n) {\n    // Write your code here\n    return 0;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        if (!line || !line.includes(\":\")) {\n            console.log(\"Invalid input format\");\n            process.exit(1);\n        }\n        const [xStr, nStr] = line.split(\":\");\n        const x = parseFloat(xStr.trim());\n        const n = parseInt(nStr.trim());\n        const result = myPow(x, n);\n        console.log(result.toFixed(5));\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc myPow(x float64, n int) float64 {\n    if n == 0 {\n        return 1.0\n    }\n    nLong := int64(n)\n    if nLong < 0 {\n        x = 1 / x\n        nLong = -nLong\n    }\n    result := 1.0\n    current := x\n    for nLong > 0 {\n        if nLong%2 == 1 {\n            result *= current\n        }\n        current *= current\n        nLong /= 2\n    }\n    return result\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil || input == \"\" || !strings.Contains(input, \":\") {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    parts := strings.Split(input, \":\")\n    x, err := strconv.ParseFloat(strings.TrimSpace(parts[0]), 64)\n    if err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    n, err := strconv.Atoi(strings.TrimSpace(parts[1]))\n    if err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := myPow(x, n)\n    fmt.Printf(\"%.5f\\n\", result)\n}",
      "C++": "#include <iostream>\n#include <sstream>\n#include <iomanip> \nusing namespace std;\n\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        if (n == 0) return 1.0;\n        long nLong = n;\n        if (nLong < 0) {\n            x = 1 / x;\n            nLong = -nLong;\n        }\n        double result = 1.0;\n        double current = x;\n        while (nLong > 0) {\n            if (nLong % 2 == 1) result *= current;\n            current *= current;\n            nLong /= 2;\n        }\n        return result;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line) || line.empty() || line.find(':') == string::npos) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        stringstream ss(line);\n        string xStr;\n        getline(ss, xStr, ':');\n        int n;\n        ss >> n;\n        double x = stod(xStr);\n        Solution sol;\n        double result = sol.myPow(x, n);\n        cout << fixed << setprecision(5) << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public double myPow(double x, int n) {\n        if (n == 0) return 1.0;\n        long nLong = n;\n        if (nLong < 0) {\n            x = 1 / x;\n            nLong = -nLong;\n        }\n        double result = 1.0;\n        double current = x;\n        while (nLong > 0) {\n            if (nLong % 2 == 1) result *= current;\n            current *= current;\n            nLong /= 2;\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String input = scanner.nextLine().trim();\n            if (input.isEmpty() || !input.contains(\":\")) {\n                System.out.println(\"Invalid input format\");\n                System.exit(1);\n            }\n            String[] parts = input.split(\":\");\n            double x = Double.parseDouble(parts[0].trim());\n            int n = Integer.parseInt(parts[1].trim());\n            Main main = new Main();\n            double result = main.myPow(x, n);\n            System.out.printf(\"%.5f\\n\", result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def myPow(self, x, n):\n        if n == 0:\n            return 1.0\n        if n < 0:\n            x = 1 / x\n            n = -n\n        result = 1.0\n        current = x\n        while n > 0:\n            if n % 2 == 1:\n                result *= current\n            current *= current\n            n //= 2\n        return result\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        if not line or \":\" not in line:\n            print(\"Invalid input format\")\n            sys.exit(1)\n        x_str, n_str = line.split(\":\")\n        x = float(x_str.strip())\n        n = int(n_str.strip())\n        sol = Solution()\n        result = sol.myPow(x, n)\n        print(\"%.5f\" % result)\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Computes x raised to power n.\n * @param {number} x - Base\n * @param {number} n - Exponent\n * @return {number} - x^n\n */\nfunction myPow(x, n) {\n    if (n === 0) return 1;\n    let nLong = BigInt(n);\n    if (nLong < 0) {\n        x = 1 / x;\n        nLong = -nLong;\n    }\n    let result = 1;\n    let current = x;\n    while (nLong > 0) {\n        if (nLong % 2n === 1n) result *= current;\n        current *= current;\n        nLong = nLong / 2n;\n    }\n    return result;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        if (!line || !line.includes(\":\")) {\n            console.log(\"Invalid input format\");\n            process.exit(1);\n        }\n        const [xStr, nStr] = line.split(\":\");\n        const x = parseFloat(xStr.trim());\n        const n = parseInt(nStr.trim());\n        const result = myPow(x, n);\n        console.log(result.toFixed(5));\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    }
  },
  {
    "title": "Best Time to Buy and Sell Stock",
    "description": "Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one.\n\n### Problem Statement\n\nYou are given an array of integers **prices** representing stock prices on different days. Find the maximum profit from one buy and one sell transaction. If no profit is possible, return 0.\n\n### Input\n\n- **prices**: An array of integers representing stock prices (0 <= prices[i] <= 10^4, 1 <= prices.length <= 10^5).\n\n### Output\n\n- An integer representing the maximum profit from one transaction. Return 0 if no profit is possible.\n\n### Example\n\n**Input**: prices = [7,1,5,3,6,4]  \n**Output**: 5  \n**Explanation**: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6 - 1 = 5. Note that buying on day 2 and selling on day 1 is not allowed as you must buy before selling.\n\n**Input**: prices = [7,6,4,3,1]  \n**Output**: 0  \n**Explanation**: No transaction is done as prices are decreasing, so max profit = 0.\n\n**Input**: prices = [1,2]  \n**Output**: 1  \n**Explanation**: Buy on day 1 (price = 1) and sell on day 2 (price = 2), profit = 2 - 1 = 1.\n\n### Notes\n\n- Use a single-pass approach to track the minimum price seen so far and compute the maximum profit.\n- Consider edge cases like arrays with one element or no increasing prices.\n- You cannot sell before buying, so the sell price must come after the buy price in the array.\n\n### Real-World Context\n\nThis problem models scenarios like maximizing profit in stock trading or identifying optimal buy-sell opportunities in time-series data.",
    "difficulty": "EASY",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Amazon",
      "Goldman Sachs",
      "Bloomberg"
    ],
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4",
      "Return the maximum profit as an integer.",
      "Time complexity should be O(n).",
      "Space complexity should be O(1)."
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6 - 1 = 5.\n\nVisual Path:\n- minPrice = 1 at day 2, maxProfit = 5 at day 5."
      }
    ],
    "testcases": [
      {
        "input": "7,1,5,3,6,4",
        "output": "5",
        "isHidden": false
      },
      {
        "input": "7,6,4,3,1",
        "output": "0",
        "isHidden": false
      },
      {
        "input": "1,2",
        "output": "1",
        "isHidden": false
      },
      {
        "input": "1",
        "output": "0",
        "isHidden": true
      },
      {
        "input": "2,4,1",
        "output": "2",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Can you track the minimum price seen so far to compute the potential profit at each step?",
      "2. For each price, consider it as a selling price and use the lowest previous price as the buying price.",
      "3. If the current price is lower than the minimum, update the minimum instead of computing profit.",
      "4. Handle cases where no profit is possible by returning 0."
    ],
    "editorial": "## Editorial: Best Time to Buy and Sell Stock\n\n### Problem Recap\n\nGiven an array of stock prices, find the maximum profit from one buy and one sell transaction, where the sell must occur after the buy. Return 0 if no profit is possible.\n\n### Intuition\n\nA brute force approach checking all possible buy-sell pairs is O(n^2), which is too slow for arrays up to 10^5. Instead, a single-pass solution tracks the minimum price seen so far and computes the maximum profit by considering each price as a potential selling price.\n\n### Approaches\n\n#### 1. Brute Force\n\n- **Idea**: For each price, try every later price as the sell price and compute the profit.\n- **Time Complexity**: O(n^2), as we check all pairs.\n- **Space Complexity**: O(1).\n- **Cons**: Too slow for large inputs.\n\n#### 2. Single-Pass Approach\n\n- **Idea**: Track the minimum price seen so far and update the maximum profit at each step.\n- **Steps**:\n  1. Initialize minPrice to the first price and maxProfit to 0.\n  2. For each price:\n     - Update minPrice = min(minPrice, currentPrice).\n     - Update maxProfit = max(maxProfit, currentPrice - minPrice).\n  3. Return maxProfit.\n- **Time Complexity**: O(n), as we iterate once.\n- **Space Complexity**: O(1), using only two variables.\n- **Pros**: Optimal and simple.\n\n### Recommended Solution\n\nThe single-pass approach is recommended for its O(n) time and O(1) space.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for one iteration.\n- **Space Complexity**: O(1) for two variables.\n- **Constraints Handling**:\n  - Array size: 1 <= n <= 10^5.\n  - Price range: 0 <= prices[i] <= 10^4.\n\n### Edge Cases\n\n- **Single element**: prices = [1] → 0 (no sell possible).\n- **Decreasing prices**: prices = [7,6,4,3,1] → 0 (no profit).\n- **Increasing prices**: prices = [1,2,3] → 2 (buy first, sell last).\n\n### Implementation Notes\n\n- Initialize minPrice to a large value or the first price.\n- Handle single-element arrays by returning 0.\n- Ensure profit is non-negative (return 0 if no profit).\n\n### Visual Explanation\n\nFor prices = [7,1,5,3,6,4]:\n- minPrice starts at 7, updates to 1.\n- At 5, profit = 5-1=4, maxProfit=4.\n- At 6, profit = 6-1=5, maxProfit=5.\n- Final maxProfit = 5.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc maxProfit(prices []int) int {\n    // Write your code here\n    return 0\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    pricesStr := strings.Split(input, \",\")\n    prices := make([]int, len(pricesStr))\n    for i, s := range pricesStr {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        prices[i] = num\n    }\n    result := maxProfit(prices)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        // Write your code here\n        return 0;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        stringstream ss(line);\n        vector<int> prices;\n        int num;\n        char comma;\n        while (ss >> num) {\n            prices.push_back(num);\n            if (ss >> comma && comma != ',') {\n                cout << \"Invalid input format\" << endl;\n                return 1;\n            }\n        }\n        Solution sol;\n        int result = sol.maxProfit(prices);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Finds the maximum profit from one buy and one sell transaction.\n     * @param prices Array of stock prices\n     * @return Maximum profit\n     */\n    public int maxProfit(int[] prices) {\n        // Write your code here\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String[] pricesStr = scanner.nextLine().trim().split(\",\");\n            int[] prices = new int[pricesStr.length];\n            for (int i = 0; i < prices.length; i++) {\n                prices[i] = Integer.parseInt(pricesStr[i].trim());\n            }\n            Main main = new Main();\n            int result = main.maxProfit(prices);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def maxProfit(self, prices):\n        \"\"\"\n        Finds the maximum profit from one buy and one sell transaction.\n        :param prices: List of stock prices\n        :return: Integer - Maximum profit\n        \"\"\"\n        # Write your code here\n        return 0\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        prices = [int(x) for x in line.split(\",\")]\n        sol = Solution()\n        result = sol.maxProfit(prices)\n        print(result)\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds the maximum profit from one buy and one sell transaction.\n * @param {number[]} prices - Array of stock prices\n * @return {number} - Maximum profit\n */\nfunction maxProfit(prices) {\n    // Write your code here\n    return 0;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const prices = line.trim().split(\",\").map(num => parseInt(num.trim()));\n        const result = maxProfit(prices);\n        console.log(result);\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc maxProfit(prices []int) int {\n    if len(prices) < 2 {\n        return 0\n    }\n    minPrice := prices[0]\n    maxProfit := 0\n    for _, price := range prices[1:] {\n        if price < minPrice {\n            minPrice = price\n        } else if price-minPrice > maxProfit {\n            maxProfit = price - minPrice\n        }\n    }\n    return maxProfit\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scan(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    pricesStr := strings.Split(input, \",\")\n    prices := make([]int, len(pricesStr))\n    for i, s := range pricesStr {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        prices[i] = num\n    }\n    result := maxProfit(prices)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if (prices.size() < 2) return 0;\n        int minPrice = prices[0];\n        int maxProfit = 0;\n        for (int i = 1; i < prices.size(); i++) {\n            if (prices[i] < minPrice) {\n                minPrice = prices[i];\n            } else {\n                maxProfit = max(maxProfit, prices[i] - minPrice);\n            }\n        }\n        return maxProfit;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        stringstream ss(line);\n        vector<int> prices;\n        int num;\n        char comma;\n        while (ss >> num) {\n            prices.push_back(num);\n            if (ss >> comma && comma != ',') {\n                cout << \"Invalid input format\" << endl;\n                return 1;\n            }\n        }\n        Solution sol;\n        int result = sol.maxProfit(prices);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public int maxProfit(int[] prices) {\n        if (prices.length < 2) return 0;\n        int minPrice = prices[0];\n        int maxProfit = 0;\n        for (int i = 1; i < prices.length; i++) {\n            if (prices[i] < minPrice) {\n                minPrice = prices[i];\n            } else {\n                maxProfit = Math.max(maxProfit, prices[i] - minPrice);\n            }\n        }\n        return maxProfit;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String[] pricesStr = scanner.nextLine().trim().split(\",\");\n            int[] prices = new int[pricesStr.length];\n            for (int i = 0; i < prices.length; i++) {\n                prices[i] = Integer.parseInt(pricesStr[i].trim());\n            }\n            Main main = new Main();\n            int result = main.maxProfit(prices);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def maxProfit(self, prices):\n        if len(prices) < 2:\n            return 0\n        min_price = prices[0]\n        max_profit = 0\n        for price in prices[1:]:\n            if price < min_price:\n                min_price = price\n            else:\n                max_profit = max(max_profit, price - min_price)\n        return max_profit\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        prices = [int(x) for x in line.split(\",\")]\n        sol = Solution()\n        result = sol.maxProfit(prices)\n        print(result)\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds the maximum profit from one buy and one sell transaction.\n * @param {number[]} prices - Array of stock prices\n * @return {number} - Maximum profit\n */\nfunction maxProfit(prices) {\n    if (prices.length < 2) return 0;\n    let minPrice = prices[0];\n    let maxProfit = 0;\n    for (let i = 1; i < prices.length; i++) {\n        if (prices[i] < minPrice) {\n            minPrice = prices[i];\n        } else {\n            maxProfit = Math.max(maxProfit, prices[i] - minPrice);\n        }\n    }\n    return maxProfit;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const prices = line.trim().split(\",\").map(num => parseInt(num.trim()));\n        const result = maxProfit(prices);\n        console.log(result);\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    }
  },
  {
    "title": "Plus One",
    "description": "Given a non-empty array of digits representing a non-negative integer, increment the integer by one. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself.\n\n### Problem Statement\n\nYou are given an array of integers **digits**. Increment the integer it represents by one and return the resulting array.\n\n### Input\n\n- **digits**: An array of integers representing digits (0 <= digits[i] <= 9, 1 <= digits.length <= 100).\n\n### Output\n\n- An array of integers representing the incremented number.\n\n### Example\n\n**Input**: digits = [1,2,3]  \n**Output**: [1,2,4]  \n**Explanation**: The array represents the integer 123. Incrementing gives 124.\n\n**Input**: digits = [4,3,2,1]  \n**Output**: [4,3,2,2]  \n**Explanation**: The array represents the integer 4321. Incrementing gives 4322.\n\n**Input**: digits = [9,9]  \n**Output**: [1,0,0]  \n**Explanation**: The array represents the integer 99. Incrementing gives 100.\n\n### Notes\n\n- Start from the least significant digit and handle carry.\n- Consider the case where all digits are 9, requiring an extra digit.\n- The input has no leading zeros except for 0 itself.\n\n### Real-World Context\n\nThis problem models scenarios like incrementing counters or numerical displays in software systems.",
    "difficulty": "EASY",
    "tags": [
      "Array",
      "Math",
      "Google",
      "Amazon"
    ],
    "constraints": [
      "1 <= digits.length <= 100",
      "0 <= digits[i] <= 9",
      "The input does not contain leading zeros, except for 0 itself",
      "Return the incremented number as an array of integers.",
      "Time complexity should be O(n).",
      "Space complexity should be O(1) excluding output."
    ],
    "examples": [
      {
        "input": "digits = [1, 2, 3]",
        "output": "[1,2,4]",
        "explanation": "The array represents the integer 123. Incrementing gives 124.\n\nVisual Path:\n- Increment digits[2] from 3 to 4, return [1,2,4]."
      }
    ],
    "testcases": [
      {
        "input": "1,2,3",
        "output": "[1,2,4]",
        "isHidden": false
      },
      {
        "input": "4,3,2,1",
        "output": "[4,3,2,2]",
        "isHidden": false
      },
      {
        "input": "9,9",
        "output": "[1,0,0]",
        "isHidden": false
      },
      {
        "input": "0",
        "output": "[1]",
        "isHidden": true
      },
      {
        "input": "9,9,9",
        "output": "[1,0,0,0]",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Start from the least significant digit and handle carry.",
      "2. Consider the case where all digits are 9, which requires prepending a 1.",
      "3. If a digit is less than 9, increment it and return immediately.",
      "4. Use the array in-place to avoid extra space."
    ],
    "editorial": "## Editorial: Plus One\n\n### Problem Recap\n\nIncrement a non-negative integer represented as an array of digits by one, where the most significant digit is at the head.\n\n### Intuition\n\nStart from the rightmost (least significant) digit. If it’s less than 9, increment it and return the array. If it’s 9, set it to 0 and carry over to the next digit. If all digits are 9, prepend a 1 to the array to handle the carry (e.g., [9,9] → [1,0,0]).\n\n### Approaches\n\n#### 1. Brute Force\n\n- **Idea**: Convert the array to a number, increment it, then convert back to an array.\n- **Time Complexity**: O(n) for conversion, but risks overflow for large numbers.\n- **Space Complexity**: O(n) for the result.\n- **Cons**: Overflow for large inputs, not efficient.\n\n#### 2. Iterative Carry Approach\n\n- **Idea**: Process digits from right to left, handling carry.\n- **Steps**:\n  1. Iterate from the last digit (i = length - 1) to the first.\n  2. If digits[i] < 9, increment it and return the array.\n  3. If digits[i] = 9, set digits[i] = 0 and continue (carry = 1).\n  4. If all digits are processed (all 9s), create a new array with 1 followed by zeros.\n- **Time Complexity**: O(n), where n is the length of digits.\n- **Space Complexity**: O(1) excluding output (O(n) if new array is needed).\n- **Pros**: Simple, handles all cases without overflow.\n\n### Recommended Solution\n\nThe iterative carry approach is optimal for O(n) time and O(1) space (excluding output).\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for one pass through the array.\n- **Space Complexity**: O(1) for in-place updates, O(n) for output or all-9s case.\n- **Constraints Handling**:\n  - Array size: 1 <= n <= 100.\n  - Digit range: 0 <= digits[i] <= 9.\n  - No leading zeros except 0.\n\n### Edge Cases\n\n- **Single digit**: digits = [0] → [1].\n- **All 9s**: digits = [9,9] → [1,0,0].\n- **No carry**: digits = [1,2,3] → [1,2,4].\n\n### Implementation Notes\n\n- Process digits in-place to minimize space.\n- Handle the all-9s case by creating a new array only when necessary.\n- Return the array directly after incrementing a non-9 digit.\n\n### Visual Explanation\n\nFor digits = [9,9]:\n- Set digits[1] = 0, carry to digits[0].\n- Set digits[0] = 0, carry remains.\n- Prepend 1, result = [1,0,0].",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc plusOne(digits []int) []int {\n    // Write your code here\n    return []int{}\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    digitsStr := strings.Split(input, \",\")\n    digits := make([]int, len(digitsStr))\n    for i, s := range digitsStr {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        digits[i] = num\n    }\n    result := plusOne(digits)\n    fmt.Print(\"[\")\n    for i, num := range result {\n        fmt.Print(num)\n        if i < len(result)-1 {\n            fmt.Print(\",\")\n        }\n    }\n    fmt.Println(\"]\")\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        // Write your code here\n        return {};\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        stringstream ss(line);\n        vector<int> digits;\n        int num;\n        char comma;\n        while (ss >> num) {\n            digits.push_back(num);\n            if (ss >> comma && comma != ',') {\n                cout << \"Invalid input format\" << endl;\n                return 1;\n            }\n        }\n        Solution sol;\n        vector<int> result = sol.plusOne(digits);\n        cout << \"[\";\n        for (int i = 0; i < result.size(); i++) {\n            cout << result[i];\n            if (i < result.size() - 1) cout << \",\";\n        }\n        cout << \"]\" << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Increments a non-negative integer represented as an array of digits by one.\n     * @param digits Array of digits\n     * @return Incremented array\n     */\n    public int[] plusOne(int[] digits) {\n        // Write your code here\n        return new int[]{};\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String[] digitsStr = scanner.nextLine().trim().split(\",\");\n            int[] digits = new int[digitsStr.length];\n            for (int i = 0; i < digits.length; i++) {\n                digits[i] = Integer.parseInt(digitsStr[i].trim());\n            }\n            Main main = new Main();\n            int[] result = main.plusOne(digits);\n            System.out.print(\"[\");\n            for (int i = 0; i < result.length; i++) {\n                System.out.print(result[i]);\n                if (i < result.length - 1) System.out.print(\",\");\n            }\n            System.out.println(\"]\");\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def plusOne(self, digits):\n        \"\"\"\n        Increments the integer represented by digits by one.\n        :param digits: List of digits\n        :return: List of digits after increment\n        \"\"\"\n        # Write your code here\n        return digits\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        digits = [int(x) for x in line.split(\",\")]\n        sol = Solution()\n        result = sol.plusOne(digits)\n        sys.stdout.write(\"[\" + \",\".join(map(str, result)) + \"]\")\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Increments a non-negative integer represented as an array of digits by one.\n * @param {number[]} digits - Array of digits\n * @return {number[]} - Incremented array\n */\nfunction plusOne(digits) {\n    // Write your code here\n    return [];\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const digits = line.trim().split(\",\").map(num => parseInt(num.trim()));\n        const result = plusOne(digits);\n        console.log(JSON.stringify(result));\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc plusOne(digits []int) []int {\n    for i := len(digits) - 1; i >= 0; i-- {\n        if digits[i] < 9 {\n            digits[i]++\n            return digits\n        }\n        digits[i] = 0\n    }\n    result := make([]int, len(digits)+1)\n    result[0] = 1\n    return result\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    digitsStr := strings.Split(input, \",\")\n    digits := make([]int, len(digitsStr))\n    for i, s := range digitsStr {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        digits[i] = num\n    }\n    result := plusOne(digits)\n    fmt.Print(\"[\")\n    for i, num := range result {\n        fmt.Print(num)\n        if i < len(result)-1 {\n            fmt.Print(\",\")\n        }\n    }\n    fmt.Println(\"]\")\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        for (int i = digits.size() - 1; i >= 0; i--) {\n            if (digits[i] < 9) {\n                digits[i]++;\n                return digits;\n            }\n            digits[i] = 0;\n        }\n        vector<int> result(digits.size() + 1, 0);\n        result[0] = 1;\n        return result;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        stringstream ss(line);\n        vector<int> digits;\n        int num;\n        char comma;\n        while (ss >> num) {\n            digits.push_back(num);\n            if (ss >> comma && comma != ',') {\n                cout << \"Invalid input format\" << endl;\n                return 1;\n            }\n        }\n        Solution sol;\n        vector<int> result = sol.plusOne(digits);\n        cout << \"[\";\n        for (int i = 0; i < result.size(); i++) {\n            cout << result[i];\n            if (i < result.size() - 1) cout << \",\";\n        }\n        cout << \"]\" << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public int[] plusOne(int[] digits) {\n        for (int i = digits.length - 1; i >= 0; i--) {\n            if (digits[i] < 9) {\n                digits[i]++;\n                return digits;\n            }\n            digits[i] = 0;\n        }\n        int[] result = new int[digits.length + 1];\n        result[0] = 1;\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String[] digitsStr = scanner.nextLine().trim().split(\",\");\n            int[] digits = new int[digitsStr.length];\n            for (int i = 0; i < digits.length; i++) {\n                digits[i] = Integer.parseInt(digitsStr[i].trim());\n            }\n            Main main = new Main();\n            int[] result = main.plusOne(digits);\n            System.out.print(\"[\");\n            for (int i = 0; i < result.length; i++) {\n                System.out.print(result[i]);\n                if (i < result.length - 1) System.out.print(\",\");\n            }\n            System.out.println(\"]\");\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def plusOne(self, digits):\n        n = len(digits)\n        for i in range(n - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        return [1] + [0] * n\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        digits = [int(x) for x in line.split(\",\")]\n        sol = Solution()\n        result = sol.plusOne(digits)\n        # Compact output: [1,2,4] without spaces or newline\n        sys.stdout.write(\"[\" + \",\".join(map(str, result)) + \"]\")\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Increments a non-negative integer represented as an array of digits by one.\n * @param {number[]} digits - Array of digits\n * @return {number[]} - Incremented array\n */\nfunction plusOne(digits) {\n    for (let i = digits.length - 1; i >= 0; i--) {\n        if (digits[i] < 9) {\n            digits[i]++;\n            return digits;\n        }\n        digits[i] = 0;\n    }\n    return [1, ...new Array(digits.length).fill(0)];\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const digits = line.trim().split(\",\").map(num => parseInt(num.trim()));\n        const result = plusOne(digits);\n        console.log(JSON.stringify(result));\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    }
  },
  {
    "title": "Edit Distance",
    "description": "Given two strings word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted:\n- Insert a character\n- Delete a character\n- Replace a character\n\n### Problem Statement\n\nYou are given two strings **word1** and **word2**. Compute the minimum number of operations (insert, delete, or replace) to transform word1 into word2.\n\n### Input\n\n- **word1**: A string of lowercase English letters (0 <= word1.length <= 500).\n- **word2**: A string of lowercase English letters (0 <= word2.length <= 500).\n\n### Output\n\n- An integer representing the minimum number of operations required.\n\n### Example\n\n**Input**: word1 = \"horse\", word2 = \"ros\"  \n**Output**: 3  \n**Explanation**: horse -> rorse (replace 'h' with 'r'), rorse -> rose (remove 'r'), rose -> ros (remove 'e').\n\n**Input**: word1 = \"intention\", word2 = \"execution\"  \n**Output**: 5  \n**Explanation**: intention -> inention (remove 't'), inention -> enention (replace 'i' with 'e'), enention -> exention (replace 'n' with 'x'), exention -> exection (replace 'n' with 'c'), exection -> execution (insert 'u').\n\n**Input**: word1 = \"\", word2 = \"\"  \n**Output**: 0  \n**Explanation**: Empty strings require 0 operations.\n\n### Notes\n\n- Use dynamic programming to compute the minimum operations.\n- Each operation (insert, delete, replace) has a cost of 1.\n- Consider a 2D DP table where dp[i][j] represents the minimum operations for prefixes.\n\n### Real-World Context\n\nThis problem models applications like spell checkers, DNA sequence alignment, and natural language processing, where the similarity between strings is measured.",
    "difficulty": "HARD",
    "tags": [
      "String",
      "Dynamic Programming",
      "Google",
      "Amazon"
    ],
    "constraints": [
      "0 <= word1.length, word2.length <= 500",
      "word1 and word2 consist of lowercase English letters",
      "Return the minimum number of operations as an integer.",
      "Time complexity should be O(m*n), where m and n are the lengths of word1 and word2.",
      "Space complexity should be O(m*n) or O(min(m,n)) with optimization."
    ],
    "examples": [
      {
        "input": "word1 = \"horse\", word2 = \"ros\"",
        "output": "3",
        "explanation": "Minimum operations: 3.\n\nVisual Path:\n- horse -> rorse (replace 'h' with 'r'), rorse -> rose (delete 'r'), rose -> ros (delete 'e')."
      }
    ],
    "testcases": [
      {
        "id": "tc1",
        "input": "horse\nros",
        "output": "3",
        "isHidden": false,
        "explanation": "Minimum operations: 3"
      },
      {
        "id": "tc2",
        "input": "intention\nexecution",
        "output": "5",
        "isHidden": false,
        "explanation": "Minimum operations: 5"
      },
      {
        "id": "tc3",
        "input": "\n",
        "output": "0",
        "isHidden": false,
        "explanation": "Empty strings require 0 operations"
      },
      {
        "id": "tc4",
        "input": "abc\n",
        "output": "3",
        "isHidden": true,
        "explanation": "Delete all characters in 'abc' to get empty string"
      },
      {
        "id": "tc5",
        "input": "abc\nabc",
        "output": "0",
        "isHidden": true,
        "explanation": "Identical strings require 0 operations"
      }
    ],
    "hints": [
      "1. Use dynamic programming to build a matrix of edit distances.",
      "2. Consider the minimum cost of insert, delete, or replace for each character.",
      "3. Initialize dp[i][0] = i and dp[0][j] = j for base cases.",
      "4. If characters match, no operation is needed; otherwise, take the minimum of three operations."
    ],
    "editorial": "## Editorial: Edit Distance\n\n### Problem Recap\n\nFind the minimum number of operations (insert, delete, replace) to convert word1 to word2.\n\n### Intuition\n\nThis is a classic dynamic programming problem, also known as the Levenshtein distance. Define dp[i][j] as the minimum operations to convert the first i characters of word1 to the first j characters of word2. If the characters match, no operation is needed; otherwise, choose the minimum of inserting, deleting, or replacing a character.\n\n### Approaches\n\n#### 1. Recursive (Top-Down)\n\n- **Idea**: Recursively try insert, delete, and replace operations.\n- **Time Complexity**: O(3^(m+n)), exponential due to overlapping subproblems.\n- **Space Complexity**: O(m+n) for recursion stack.\n- **Cons**: Too slow for m, n up to 500.\n\n#### 2. Dynamic Programming (Bottom-Up)\n\n- **Idea**: Use a 2D DP table to store edit distances.\n- **Steps**:\n  1. Create dp[m+1][n+1] where m = word1.length, n = word2.length.\n  2. Initialize dp[i][0] = i (delete i characters) and dp[0][j] = j (insert j characters).\n  3. For each i from 1 to m and j from 1 to n:\n     - If word1[i-1] == word2[j-1], dp[i][j] = dp[i-1][j-1].\n     - Else, dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1.\n  4. Return dp[m][n].\n- **Time Complexity**: O(m*n) for filling the DP table.\n- **Space Complexity**: O(m*n) for the DP table.\n- **Pros**: Efficient, handles all cases.\n\n#### 3. Space-Optimized DP\n\n- **Idea**: Use a single row or column (size min(m,n)+1) to store intermediate results.\n- **Time Complexity**: O(m*n).\n- **Space Complexity**: O(min(m,n)).\n- **Cons**: More complex, not needed for constraints.\n\n### Recommended Solution\n\nThe bottom-up DP approach is optimal for clarity and O(m*n) time, O(m*n) space.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(m*n) for the DP table.\n- **Space Complexity**: O(m*n) for the 2D array.\n- **Constraints Handling**:\n  - String length: 0 <= m, n <= 500.\n  - Input: Lowercase English letters.\n\n### Edge Cases\n\n- **Empty strings**: word1 = \"\", word2 = \"\" → 0.\n- **One empty string**: word1 = \"abc\", word2 = \"\" → 3 (delete all).\n- **Identical strings**: word1 = \"abc\", word2 = \"abc\" → 0.\n- **Single characters**: word1 = \"a\", word2 = \"b\" → 1 (replace).\n\n### Implementation Notes\n\n- Initialize dp[i][0] and dp[0][j] for base cases.\n- Use min() to select the cheapest operation.\n- Handle character comparison at indices i-1, j-1 (0-based indexing).\n\n### Visual Explanation\n\nFor word1 = \"horse\", word2 = \"ros\":\n- dp[5][3] table, final value = 3.\n- Path: Replace 'h'->'r', delete 'r', delete 'e'.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"bufio\"\n    \"os\"\n    \"strings\"\n)\n\nfunc minDistance(word1 string, word2 string) int {\n    // Write your code here\n    return 0\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    var lines []string\n    for scanner.Scan() {\n        lines = append(lines, strings.TrimSpace(scanner.Text()))\n        if len(lines) == 2 {\n            break\n        }\n    }\n    if len(lines) != 2 {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := minDistance(lines[0], lines[1])\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        // Write your code here\n        return 0;\n    }\n};\n\nint main() {\n    try {\n        string word1, word2;\n        if (!getline(cin, word1) || !getline(cin, word2)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        Solution sol;\n        int result = sol.minDistance(word1, word2);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Computes the minimum number of operations to convert word1 to word2.\n     * @param word1 First string\n     * @param word2 Second string\n     * @return Minimum operations\n     */\n    public int minDistance(String word1, String word2) {\n        // Write your code here\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String word1 = scanner.nextLine().trim();\n            String word2 = scanner.nextLine().trim();\n            Main main = new Main();\n            int result = main.minDistance(word1, word2);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        \"\"\"\n        Computes the minimum number of operations to convert word1 to word2.\n        :param word1: First string\n        :param word2: Second string\n        :return: Minimum operations\n        \"\"\"\n        # Write your code here\n        return 0\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        word1 = sys.stdin.readline().strip()\n        word2 = sys.stdin.readline().strip()\n        sol = Solution()\n        result = sol.minDistance(word1, word2)\n        print(result)\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Computes the minimum number of operations to convert word1 to word2.\n * @param {string} word1 - First string\n * @param {string} word2 - Second string\n * @return {number} - Minimum operations\n */\nfunction minDistance(word1, word2) {\n    // Write your code here\n    return 0;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nlet lines = [];\nrl.on(\"line\", (line) => {\n    lines.push(line.trim());\n    if (lines.length === 2) {\n        try {\n            const result = minDistance(lines[0], lines[1]);\n            console.log(result);\n            rl.close();\n        } catch (e) {\n            console.log(\"Invalid input format\");\n            process.exit(1);\n        }\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"bufio\"\n    \"os\"\n    \"strings\"\n)\n\nfunc minDistance(word1 string, word2 string) int {\n    m, n := len(word1), len(word2)\n    dp := make([][]int, m+1)\n    for i := range dp {\n        dp[i] = make([]int, n+1)\n    }\n    for i := 0; i <= m; i++ {\n        dp[i][0] = i\n    }\n    for j := 0; j <= n; j++ {\n        dp[0][j] = j\n    }\n    for i := 1; i <= m; i++ {\n        for j := 1; j <= n; j++ {\n            if word1[i-1] == word2[j-1] {\n                dp[i][j] = dp[i-1][j-1]\n            } else {\n                min := dp[i-1][j-1]\n                if dp[i-1][j] < min {\n                    min = dp[i-1][j]\n                }\n                if dp[i][j-1] < min {\n                    min = dp[i][j-1]\n                }\n                dp[i][j] = min + 1\n            }\n        }\n    }\n    return dp[m][n]\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    var lines []string\n    for scanner.Scan() {\n        lines = append(lines, strings.TrimSpace(scanner.Text()))\n        if len(lines) == 2 {\n            break\n        }\n    }\n    if len(lines) != 2 {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := minDistance(lines[0], lines[1])\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int m = word1.length(), n = word2.length();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n        for (int i = 0; i <= m; i++) dp[i][0] = i;\n        for (int j = 0; j <= n; j++) dp[0][j] = j;\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (word1[i - 1] == word2[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n\nint main() {\n    try {\n        string word1, word2;\n        if (!getline(cin, word1) || !getline(cin, word2)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        Solution sol;\n        int result = sol.minDistance(word1, word2);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public int minDistance(String word1, String word2) {\n        int m = word1.length(), n = word2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        for (int i = 0; i <= m; i++) dp[i][0] = i;\n        for (int j = 0; j <= n; j++) dp[0][j] = j;\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;\n                }\n            }\n        }\n        return dp[m][n];\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String word1 = scanner.nextLine().trim();\n            String word2 = scanner.nextLine().trim();\n            Main main = new Main();\n            int result = main.minDistance(word1, word2);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n        return dp[m][n]\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        word1 = sys.stdin.readline().strip()\n        word2 = sys.stdin.readline().strip()\n        sol = Solution()\n        result = sol.minDistance(word1, word2)\n        print(result)\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Computes the minimum number of operations to convert word1 to word2.\n * @param {string} word1 - First string\n * @param {string} word2 - Second string\n * @return {number} - Minimum operations\n */\nfunction minDistance(word1, word2) {\n    let m = word1.length, n = word2.length;\n    let dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));\n    for (let i = 0; i <= m; i++) dp[i][0] = i;\n    for (let j = 0; j <= n; j++) dp[0][j] = j;\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (word1[i - 1] === word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1;\n            }\n        }\n    }\n    return dp[m][n];\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nlet lines = [];\nrl.on(\"line\", (line) => {\n    lines.push(line.trim());\n    if (lines.length === 2) {\n        try {\n            const result = minDistance(lines[0], lines[1]);\n            console.log(result);\n            rl.close();\n        } catch (e) {\n            console.log(\"Invalid input format\");\n            process.exit(1);\n        }\n    }\n});"
    }
  },
  {
    "title": "Sort Colors",
    "description": "Given an array with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. Here, we use the integers 0, 1, and 2 to represent the colors red, white, and blue, respectively.\n\n### Problem Statement\n\nYou are given an array **nums** containing n integers, each of which is 0, 1, or 2. Sort the array in-place without using the library's sort function, such that all 0s come first, followed by all 1s, and then all 2s.\n\n### Input\n\n- **nums**: An array of integers where each element is 0, 1, or 2 (1 <= nums.length <= 300).\n\n### Output\n\n- Modify **nums** in-place to have all 0s, then all 1s, then all 2s.\n\n### Example\n\n**Input**: nums = [2,0,2,1,1,0]  \n**Output**: [0,0,1,1,2,2]  \n**Explanation**: The array is sorted in-place with all 0s first, then 1s, then 2s.\n\n**Input**: nums = [2,0,1]  \n**Output**: [0,1,2]  \n**Explanation**: The array is sorted in-place.\n\n**Input**: nums = [1]  \n**Output**: [1]  \n**Explanation**: Single element is already sorted.\n\n### Notes\n\n- You cannot use the library's sort function.\n- A two-pass counting sort is straightforward: count 0s, 1s, and 2s, then overwrite the array. However, a one-pass algorithm with O(1) space is preferred (e.g., Dutch National Flag algorithm).\n\n### Real-World Context\n\nThis problem models scenarios like partitioning data into categories (e.g., prioritizing tasks or sorting items by type) with minimal memory usage, common in embedded systems or performance-critical applications.",
    "difficulty": "MEDIUM",
    "tags": [
      "Array",
      "Two Pointers",
      "Sorting",
      "Google",
      "Facebook",
      "VM Ware"
    ],
    "constraints": [
      "n == nums.length",
      "1 <= n <= 300",
      "nums[i] is 0, 1, or 2",
      "Sort the array in-place without using library sort functions.",
      "Time complexity should be O(n).",
      "Space complexity should be O(1) for the optimal solution."
    ],
    "examples": [
      {
        "input": "nums = [2, 0, 2, 1, 1, 0]",
        "output": "[0,0,1,1,2,2]",
        "explanation": "The array is sorted in-place with all 0s first, then 1s, then 2s.\n\nVisual Path:\n- Dutch National Flag: Partition using low, mid, high pointers."
      }
    ],
    "testcases": [
      {
        "input": "[2,0,2,1,1,0]",
        "output": "[0,0,1,1,2,2]",
        "isHidden": false
      },
      {
        "input": "[2,0,1]",
        "output": "[0,1,2]",
        "isHidden": false
      },
      {
        "input": "[1]",
        "output": "[1]",
        "isHidden": false
      },
      {
        "input": "[2,2,2]",
        "output": "[2,2,2]",
        "isHidden": true
      },
      {
        "input": "[0,0,0,1,1,1,2,2,2]",
        "output": "[0,0,0,1,1,1,2,2,2]",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Consider a two-pass approach: count the occurrences of 0, 1, and 2, then overwrite the array.",
      "2. For a one-pass solution, use three pointers to partition the array (Dutch National Flag algorithm).",
      "3. Maintain pointers for the next position of 0, the current element, and the next position of 2."
    ],
    "editorial": "## Editorial: Sort Colors\n\n### Problem Recap\n\nSort an array of 0s, 1s, and 2s in-place, with 0s first, then 1s, then 2s, without using library sort functions.\n\n### Intuition\n\nThis is a partitioning problem, similar to sorting but with only three distinct values. A two-pass counting sort is intuitive but requires O(n) time and two traversals. The optimal solution is the Dutch National Flag algorithm, which uses three pointers to sort in one pass with O(1) space.\n\n### Approaches\n\n#### 1. Counting Sort (Two-Pass)\n\n- **Idea**: Count occurrences of 0, 1, and 2, then overwrite the array.\n- **Steps**:\n  1. Initialize counters for 0, 1, and 2.\n  2. Traverse nums to count each value.\n  3. Overwrite nums with counted 0s, then 1s, then 2s.\n- **Time Complexity**: O(n) for two passes.\n- **Space Complexity**: O(1) for three counters.\n- **Cons**: Requires two passes.\n\n#### 2. Dutch National Flag (One-Pass)\n\n- **Idea**: Use three pointers (low, mid, high) to partition the array.\n- **Steps**:\n  1. Initialize low = 0 (next position for 0), mid = 0 (current element), high = n-1 (next position for 2).\n  2. While mid <= high:\n     - If nums[mid] = 0, swap with nums[low], increment low and mid.\n     - If nums[mid] = 1, increment mid.\n     - If nums[mid] = 2, swap with nums[high], decrement high.\n  3. Array is sorted in-place.\n- **Time Complexity**: O(n) for one pass.\n- **Space Complexity**: O(1) for pointers.\n- **Pros**: Optimal, one-pass, constant space.\n\n### Recommended Solution\n\nThe Dutch National Flag algorithm is optimal for O(n) time and O(1) space.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for one pass.\n- **Space Complexity**: O(1) for three pointers.\n- **Constraints Handling**:\n  - Array length: 1 <= n <= 300.\n  - Values: nums[i] is 0, 1, or 2.\n\n### Edge Cases\n\n- **Single element**: nums = [1] → [1].\n- **All same value**: nums = [2,2,2] → [2,2,2].\n- **Maximum length**: n = 300.\n- **Mixed values**: nums = [2,0,2,1,1,0].\n\n### Implementation Notes\n\n- Use swap operations carefully to avoid overwriting.\n- Ensure mid <= high to avoid out-of-bounds access.\n- In-place modification means no return value is needed, but output is checked via nums.\n\n### Visual Explanation\n\nFor nums = [2,0,2,1,1,0]:\n- Initial: low=0, mid=0, high=5.\n- Swap 2 with high, move high left, etc.\n- Final: [0,0,1,1,2,2].",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc sortColors(nums []int) {\n    // Write your code here\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    input = input[1 : len(input)-1]\n    strNums := strings.Split(input, \",\")\n    nums := make([]int, len(strNums))\n    for i, s := range strNums {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        nums[i] = num\n    }\n    sortColors(nums)\n    fmt.Print(\"[\")\n    for i, num := range nums {\n        fmt.Print(num)\n        if i < len(nums)-1 {\n            fmt.Print(\",\")\n        }\n    }\n    fmt.Println(\"]\")\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        // Write your code here\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        size_t pos = 0;\n        while ((pos = line.find(\",\")) != string::npos) {\n            nums.push_back(stoi(line.substr(0, pos)));\n            line.erase(0, pos + 1);\n        }\n        if (!line.empty()) nums.push_back(stoi(line));\n        Solution sol;\n        sol.sortColors(nums);\n        cout << \"[\";\n        for (size_t i = 0; i < nums.size(); i++) {\n            cout << nums[i];\n            if (i < nums.size() - 1) cout << \",\";\n        }\n        cout << \"]\" << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Sorts an array of 0s, 1s, and 2s in-place.\n     * @param nums Array of 0, 1, or 2\n     */\n    public void sortColors(int[] nums) {\n        // Write your code here\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            String[] strNums = line.substring(1, line.length()-1).split(\",\");\n            int[] nums = new int[strNums.length];\n            for (int i = 0; i < strNums.length; i++) {\n                nums[i] = Integer.parseInt(strNums[i].trim());\n            }\n            Main main = new Main();\n            main.sortColors(nums);\n            System.out.print(\"[\");\n            for (int i = 0; i < nums.length; i++) {\n                System.out.print(nums[i]);\n                if (i < nums.length - 1) System.out.print(\",\");\n            }\n            System.out.println(\"]\");\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import json\n\nclass Solution:\n    def sortColors(self, nums):\n        \"\"\"\n        Sorts an array of 0s, 1s, and 2s in-place.\n        :param nums: List of 0, 1, or 2\n        :return: None, modify nums in-place\n        \"\"\"\n        # Write your code here\n        pass\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        nums = json.loads(line)  # Parse JSON array\n        sol = Solution()\n        sol.sortColors(nums)\n        sys.stdout.write(json.dumps(nums, separators=(',', ':')))  # Compact JSON output\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Sorts an array of 0s, 1s, and 2s in-place.\n * @param {number[]} nums - Array of 0, 1, or 2\n * @return {void} Do not return anything, modify nums in-place\n */\nfunction sortColors(nums) {\n    // Write your code here\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const nums = JSON.parse(line.trim());\n        sortColors(nums);\n        console.log(JSON.stringify(nums));\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc sortColors(nums []int) {\n    low, mid, high := 0, 0, len(nums)-1\n    for mid <= high {\n        if nums[mid] == 0 {\n            nums[low], nums[mid] = nums[mid], nums[low]\n            low++\n            mid++\n        } else if nums[mid] == 1 {\n            mid++\n        } else {\n            nums[mid], nums[high] = nums[high], nums[mid]\n            high--\n        }\n    }\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    input = input[1 : len(input)-1]\n    strNums := strings.Split(input, \",\")\n    nums := make([]int, len(strNums))\n    for i, s := range strNums {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        nums[i] = num\n    }\n    sortColors(nums)\n    fmt.Print(\"[\")\n    for i, num := range nums {\n        fmt.Print(num)\n        if i < len(nums)-1 {\n            fmt.Print(\",\")\n        }\n    }\n    fmt.Println(\"]\")\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        int low = 0, mid = 0, high = nums.size() - 1;\n        while (mid <= high) {\n            if (nums[mid] == 0) {\n                swap(nums[low], nums[mid]);\n                low++;\n                mid++;\n            } else if (nums[mid] == 1) {\n                mid++;\n            } else {\n                swap(nums[mid], nums[high]);\n                high--;\n            }\n        }\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        size_t pos = 0;\n        while ((pos = line.find(\",\")) != string::npos) {\n            nums.push_back(stoi(line.substr(0, pos)));\n            line.erase(0, pos + 1);\n        }\n        if (!line.empty()) nums.push_back(stoi(line));\n        Solution sol;\n        sol.sortColors(nums);\n        cout << \"[\";\n        for (size_t i = 0; i < nums.size(); i++) {\n            cout << nums[i];\n            if (i < nums.size() - 1) cout << \",\";\n        }\n        cout << \"]\" << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public void sortColors(int[] nums) {\n        int low = 0, mid = 0, high = nums.length - 1;\n        while (mid <= high) {\n            if (nums[mid] == 0) {\n                int temp = nums[low];\n                nums[low] = nums[mid];\n                nums[mid] = temp;\n                low++;\n                mid++;\n            } else if (nums[mid] == 1) {\n                mid++;\n            } else {\n                int temp = nums[high];\n                nums[high] = nums[mid];\n                nums[mid] = temp;\n                high--;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            String[] strNums = line.substring(1, line.length()-1).split(\",\");\n            int[] nums = new int[strNums.length];\n            for (int i = 0; i < strNums.length; i++) {\n                nums[i] = Integer.parseInt(strNums[i].trim());\n            }\n            Main main = new Main();\n            main.sortColors(nums);\n            System.out.print(\"[\");\n            for (int i = 0; i < nums.length; i++) {\n                System.out.print(nums[i]);\n                if (i < nums.length - 1) System.out.print(\",\");\n            }\n            System.out.println(\"]\");\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import json\n\nclass Solution:\n    def sortColors(self, nums):\n        low = 0\n        mid = 0\n        high = len(nums) - 1\n        while mid <= high:\n            if nums[mid] == 0:\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n            elif nums[mid] == 1:\n                mid += 1\n            else:  # nums[mid] == 2\n                nums[mid], nums[high] = nums[high], nums[mid]\n                high -= 1\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        nums = json.loads(line)  # Parse JSON array\n        sol = Solution()\n        sol.sortColors(nums)\n        sys.stdout.write(json.dumps(nums, separators=(',', ':')))  # Compact JSON output\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Sorts an array of 0s, 1s, and 2s in-place.\n * @param {number[]} nums - Array of 0, 1, or 2\n * @return {void} Do not return anything, modify nums in-place\n */\nfunction sortColors(nums) {\n    let low = 0, mid = 0, high = nums.length - 1;\n    while (mid <= high) {\n        if (nums[mid] === 0) {\n            [nums[low], nums[mid]] = [nums[mid], nums[low]];\n            low++;\n            mid++;\n        } else if (nums[mid] === 1) {\n            mid++;\n        } else {\n            [nums[mid], nums[high]] = [nums[high], nums[mid]];\n            high--;\n        }\n    }\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const nums = JSON.parse(line.trim());\n        sortColors(nums);\n        console.log(JSON.stringify(nums));\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    }
  },
  {
    "title": "Word Search",
    "description": "Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where 'adjacent' cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\n### Problem Statement\n\nYou are given a 2D grid **board** of characters and a string **word**. Determine if **word** can be formed by connecting adjacent cells (up, down, left, right) without reusing any cell.\n\n### Input\n\n- **board**: A 2D array of characters (1 <= board.length, board[i].length <= 200).\n- **word**: A string of lowercase and uppercase English letters (1 <= word.length <= 10^3).\n\n### Output\n\n- A boolean: true if the word exists in the grid, false otherwise.\n\n### Example\n\n**Input**: board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = 'ABCCED'  \n**Output**: true  \n**Explanation**: The word 'ABCCED' can be formed starting from (0,0): A→B→C→C→E→D.\n\n**Input**: board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = 'SEE'  \n**Output**: true  \n**Explanation**: The word 'SEE' can be formed starting from (1,0): S→E→E.\n\n**Input**: board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = 'ABCB'  \n**Output**: false  \n**Explanation**: The word 'ABCB' cannot be formed without reusing cells.\n\n### Notes\n\n- Use depth-first search (DFS) to explore all possible paths.\n- Mark visited cells to avoid reuse, and backtrack to restore the board.\n\n### Real-World Context\n\nThis problem models applications like word games (e.g., Boggle), pattern matching in grids, or pathfinding in constraint-based environments.",
    "difficulty": "MEDIUM",
    "tags": [
      "Goldman Sachs",
      "JP Morgan",
      "Microsoft",
      "Google",
      "Array",
      "Backtracking",
      "Matrix",
      "DFS"
    ],
    "constraints": [
      "1 <= board.length <= 200",
      "1 <= board[i].length <= 200",
      "1 <= word.length <= 10^3",
      "board and word consist of lowercase and uppercase English letters",
      "Time complexity should be O(m*n*4^L), where m,n are board dimensions, L is word length",
      "Space complexity should be O(L) for recursion stack"
    ],
    "examples": [
      {
        "input": "board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = \"ABCCED\"",
        "output": "true",
        "explanation": "The word 'ABCCED' can be formed: A→B→C→C→E→D."
      }
    ],
    "testcases": [
      {
        "input": "[['A','B','C','E'],['S','F','C','S'],['A','D','E','E']]\nABCCED",
        "output": "true",
        "isHidden": false
      },
      {
        "input": "[['A','B','C','E'],['S','F','C','S'],['A','D','E','E']]\nSEE",
        "output": "true",
        "isHidden": false
      },
      {
        "input": "[['A','B','C','E'],['S','F','C','S'],['A','D','E','E']]\nABCB",
        "output": "false",
        "isHidden": false
      },
      {
        "input": "[['A']]\nA",
        "output": "true",
        "isHidden": true
      },
      {
        "input": "[['A','B']]\nABC",
        "output": "false",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Use depth-first search to explore paths from each cell.",
      "2. Mark visited cells to prevent reuse, and unmark during backtracking.",
      "3. Check all four directions (up, down, left, right) for each cell."
    ],
    "editorial": "## Editorial: Word Search\n\n### Problem Recap\n\nDetermine if a word exists in a 2D grid by forming it from adjacent cells without reusing any cell.\n\n### Intuition\n\nThis is a pathfinding problem best solved with depth-first search (DFS). Start from each cell that matches the word’s first letter, then explore all valid paths. Use backtracking to mark and unmark visited cells.\n\n### Approaches\n\n#### 1. DFS with Backtracking\n\n- **Idea**: For each cell, try to build the word using DFS.\n- **Steps**:\n  1. Iterate over each cell (i,j) in the board.\n  2. If board[i][j] matches word[0], start DFS.\n  3. In DFS:\n     - Check if the current position is valid and matches the current character.\n     - Mark the cell (e.g., with '#').\n     - Recurse in four directions.\n     - Unmark the cell after exploration.\n  4. Return true if any DFS finds the word.\n- **Time Complexity**: O(m*n*4^L), where m,n are board dimensions, L is word length.\n- **Space Complexity**: O(L) for recursion stack.\n- **Pros**: Efficient, handles all cases.\n\n### Recommended Solution\n\nDFS with backtracking is the standard approach.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(m*n*4^L), as each cell (m*n) can start a DFS with up to 4^L paths.\n- **Space Complexity**: O(L) for recursion stack.\n- **Constraints Handling**:\n  - Board size: 1 <= m,n <= 200.\n  - Word length: 1 <= L <= 10^3.\n\n### Edge Cases\n\n- **Single cell**: board = [['A']], word = 'A' → true.\n- **No match**: board = [['A']], word = 'B' → false.\n- **Long word**: word.length = 10^3.\n- **Small board**: 1x1 or 1x200.\n\n### Implementation Notes\n\n- Use a helper DFS function to manage state.\n- Validate indices to avoid out-of-bounds errors.\n- Mark cells temporarily to avoid reuse.\n\n### Visual Explanation\n\nFor board = [['A','B','C'],['S','F','C']], word = 'ABF':\n- Start at (0,0)='A', move to (0,1)='B', then (1,1)='F'.\n- Path found, return true.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strings\"\n)\n\nfunc exist(board [][]byte, word string) bool {\n    // Write your code here\n    return false\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    var lines []string\n    for scanner.Scan() {\n        lines = append(lines, strings.TrimSpace(scanner.Text()))\n        if len(lines) == 2 {\n            break\n        }\n    }\n    if len(lines) != 2 {\n        fmt.Print(\"Invalid input format\")\n        return\n    }\n\n    // Parse board input\n    boardLine := lines[0]\n    word := lines[1]\n    var board [][]byte\n\n    // Remove [[ and ]]\n    if len(boardLine) < 4 {\n        fmt.Print(\"Invalid input format\")\n        return\n    }\n    boardLine = boardLine[2 : len(boardLine)-2]\n    // Split by ],[\n    rows := strings.Split(boardLine, \"],[\")\n    board = make([][]byte, len(rows))\n    for i, row := range rows {\n        // Remove single quotes and split by comma\n        row = strings.ReplaceAll(row, \"'\", \"\")\n        chars := strings.Split(row, \",\")\n        board[i] = make([]byte, len(chars))\n        for j, c := range chars {\n            if len(c) != 1 {\n                fmt.Print(\"Invalid input format\")\n                return\n            }\n            board[i][j] = c[0] // Convert to byte\n        }\n    }\n\n    result := exist(board, word)\n    fmt.Print(result) // Output without newline\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        // Write your code here\n        return false;\n    }\n};\n\nint main() {\n    try {\n        string boardLine, word;\n        if (!getline(cin, boardLine) || !getline(cin, word)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        boardLine = boardLine.substr(2, boardLine.length()-4);\n        vector<vector<char>> board;\n        size_t pos = 0;\n        while ((pos = boardLine.find(\"],[\")) != string::npos) {\n            string rowStr = boardLine.substr(0, pos);\n            vector<char> row;\n            for (char c : rowStr) if (c != '\\'' && c != ',') row.push_back(c);\n            board.push_back(row);\n            boardLine.erase(0, pos + 3);\n        }\n        vector<char> row;\n        for (char c : boardLine) if (c != '\\'' && c != ',') row.push_back(c);\n        if (!row.empty()) board.push_back(row);\n        Solution sol;\n        bool result = sol.exist(board, word);\n        cout << (result ? \"true\" : \"false\") << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Checks if a word exists in the board.\n     * @param board 2D grid of characters\n     * @param word Word to find\n     * @return True if word exists, false otherwise\n     */\n    public boolean exist(char[][] board, String word) {\n        // Write your code here\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String boardLine = scanner.nextLine().trim();\n            String word = scanner.nextLine().trim();\n            // Parse board input manually\n            boardLine = boardLine.substring(2, boardLine.length() - 2); // Remove [[ and ]]\n            String[] rows = boardLine.split(\"],\\\\[\"); // Split by ],[\n            char[][] board = new char[rows.length][];\n            for (int i = 0; i < rows.length; i++) {\n                String row = rows[i].replace(\"'\", \"\"); // Remove single quotes\n                String[] chars = row.split(\",\");\n                board[i] = new char[chars.length];\n                for (int j = 0; j < chars.length; j++) {\n                    board[i][j] = chars[j].charAt(0); // Convert to char\n                }\n            }\n            Main main = new Main();\n            boolean result = main.exist(board, word);\n            System.out.print(result); // Output without newline\n        } catch (Exception e) {\n            System.out.print(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import json\nimport sys\n\nclass Solution:\n    def exist(self, board, word):\n        \"\"\"\n        Checks if a word exists in the board.\n        :param board: 2D grid of characters\n        :param word: Word to find\n        :return: True if word exists, false otherwise\n        \"\"\"\n        # Write your code here\n        return False\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        board_input = sys.stdin.readline().strip()\n        word = sys.stdin.readline().strip()\n        # Try parsing as JSON\n        try:\n            board = json.loads(board_input)\n        except ValueError:\n            # Fallback: evaluate raw input\n            board = eval(board_input)\n        sol = Solution()\n        result = sol.exist(board, word)\n        sys.stdout.write(str(result).lower())  # Output 'true' or 'false' without newline\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Checks if a word exists in the board.\n * @param {character[][]} board - 2D grid of characters\n * @param {string} word - Word to find\n * @return {boolean} - True if word exists, false otherwise\n */\nfunction exist(board, word) {\n    // Write your code here\n    return false;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nlet lines = [];\nrl.on(\"line\", (line) => {\n    lines.push(line.trim());\n    if (lines.length === 2) {\n        try {\n            let board;\n            // Try parsing as JSON\n            try {\n                board = JSON.parse(lines[0]);\n            } catch (e) {\n                // Fallback: attempt to parse raw input\n                board = eval(lines[0]); // Use eval cautiously\n            }\n            const word = lines[1];\n            const result = exist(board, word);\n            process.stdout.write(result.toString()); // Avoid trailing newline\n            rl.close();\n        } catch (e) {\n            process.stdout.write(\"Invalid input format\");\n            process.exit(1);\n        }\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strings\"\n)\n\nfunc exist(board [][]byte, word string) bool {\n    m, n := len(board), len(board[0])\n    var dfs func(i, j, k int) bool\n    dfs = func(i, j, k int) bool {\n        if k == len(word) {\n            return true\n        }\n        if i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word[k] {\n            return false\n        }\n        temp := board[i][j]\n        board[i][j] = '#'\n        found := dfs(i+1, j, k+1) || dfs(i-1, j, k+1) || dfs(i, j+1, k+1) || dfs(i, j-1, k+1)\n        board[i][j] = temp\n        return found\n    }\n    for i := 0; i < m; i++ {\n        for j := 0; j < n; j++ {\n            if board[i][j] == word[0] && dfs(i, j, 0) {\n                return true\n            }\n        }\n    }\n    return false\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    var lines []string\n    for scanner.Scan() {\n        lines = append(lines, strings.TrimSpace(scanner.Text()))\n        if len(lines) == 2 {\n            break\n        }\n    }\n    if len(lines) != 2 {\n        fmt.Print(\"Invalid input format\")\n        return\n    }\n\n    // Parse board input\n    boardLine := lines[0]\n    word := lines[1]\n    var board [][]byte\n\n    // Remove [[ and ]]\n    if len(boardLine) < 4 {\n        fmt.Print(\"Invalid input format\")\n        return\n    }\n    boardLine = boardLine[2 : len(boardLine)-2]\n    // Split by ],[\n    rows := strings.Split(boardLine, \"],[\")\n    board = make([][]byte, len(rows))\n    for i, row := range rows {\n        // Remove single quotes and split by comma\n        row = strings.ReplaceAll(row, \"'\", \"\")\n        chars := strings.Split(row, \",\")\n        board[i] = make([]byte, len(chars))\n        for j, c := range chars {\n            if len(c) != 1 {\n                fmt.Print(\"Invalid input format\")\n                return\n            }\n            board[i][j] = c[0] // Convert to byte\n        }\n    }\n\n    result := exist(board, word)\n    fmt.Print(result) // Output without newline\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        int m = board.size(), n = board[0].size();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (board[i][j] == word[0] && dfs(board, word, i, j, 0)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\nprivate:\n    bool dfs(vector<vector<char>>& board, string& word, int i, int j, int k) {\n        if (k == word.size()) return true;\n        if (i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || board[i][j] != word[k]) {\n            return false;\n        }\n        char temp = board[i][j];\n        board[i][j] = '#';\n        bool found = dfs(board, word, i+1, j, k+1) || dfs(board, word, i-1, j, k+1) ||\n                     dfs(board, word, i, j+1, k+1) || dfs(board, word, i, j-1, k+1);\n        board[i][j] = temp;\n        return found;\n    }\n};\n\nint main() {\n    try {\n        string boardLine, word;\n        if (!getline(cin, boardLine) || !getline(cin, word)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        boardLine = boardLine.substr(2, boardLine.length()-4);\n        vector<vector<char>> board;\n        size_t pos = 0;\n        while ((pos = boardLine.find(\"],[\")) != string::npos) {\n            string rowStr = boardLine.substr(0, pos);\n            vector<char> row;\n            for (char c : rowStr) if (c != '\\'' && c != ',') row.push_back(c);\n            board.push_back(row);\n            boardLine.erase(0, pos + 3);\n        }\n        vector<char> row;\n        for (char c : boardLine) if (c != '\\'' && c != ',') row.push_back(c);\n        if (!row.empty()) board.push_back(row);\n        Solution sol;\n        bool result = sol.exist(board, word);\n        cout << (result ? \"true\" : \"false\") << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public boolean exist(char[][] board, String word) {\n        int m = board.length, n = board[0].length;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (board[i][j] == word.charAt(0) && dfs(board, word, i, j, 0)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean dfs(char[][] board, String word, int i, int j, int k) {\n        if (k == word.length()) return true;\n        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word.charAt(k)) {\n            return false;\n        }\n        char temp = board[i][j];\n        board[i][j] = '#';\n        boolean found = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) ||\n                        dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i, j - 1, k + 1);\n        board[i][j] = temp;\n        return found;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String boardLine = scanner.nextLine().trim();\n            String word = scanner.nextLine().trim();\n            // Parse board input manually\n            boardLine = boardLine.substring(2, boardLine.length() - 2); // Remove [[ and ]]\n            String[] rows = boardLine.split(\"],\\\\[\"); // Split by ],[\n            char[][] board = new char[rows.length][];\n            for (int i = 0; i < rows.length; i++) {\n                String row = rows[i].replace(\"'\", \"\"); // Remove single quotes\n                String[] chars = row.split(\",\");\n                board[i] = new char[chars.length];\n                for (int j = 0; j < chars.length; j++) {\n                    board[i][j] = chars[j].charAt(0); // Convert to char\n                }\n            }\n            Main main = new Main();\n            boolean result = main.exist(board, word);\n            System.out.print(result); // Output without newline\n        } catch (Exception e) {\n            System.out.print(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import json\nimport sys\n\nclass Solution:\n    def exist(self, board, word):\n        m, n = len(board), len(board[0])\n        def dfs(i, j, k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != word[k]:\n                return False\n            temp = board[i][j]\n            board[i][j] = '#'\n            found = (dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or \n                     dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1))\n            board[i][j] = temp\n            return found\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == word[0] and dfs(i, j, 0):\n                    return True\n        return False\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        board_input = sys.stdin.readline().strip()\n        word = sys.stdin.readline().strip()\n        # Try parsing as JSON\n        try:\n            board = json.loads(board_input)\n        except ValueError:\n            # Fallback: evaluate raw input (safe for controlled input)\n            board = eval(board_input)\n        sol = Solution()\n        result = sol.exist(board, word)\n        sys.stdout.write(str(result).lower())  # Output 'true' or 'false' without newline\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Checks if a word exists in the board.\n * @param {character[][]} board - 2D grid of characters\n * @param {string} word - Word to find\n * @return {boolean} - True if word exists, false otherwise\n */\nfunction exist(board, word) {\n    const m = board.length, n = board[0].length;\n    function dfs(i, j, k) {\n        if (k === word.length) return true;\n        if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] !== word[k]) return false;\n        const temp = board[i][j];\n        board[i][j] = '#';\n        const found = dfs(i + 1, j, k + 1) || dfs(i - 1, j, k + 1) || dfs(i, j + 1, k + 1) || dfs(i, j - 1, k + 1);\n        board[i][j] = temp;\n        return found;\n    }\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (board[i][j] === word[0] && dfs(i, j, 0)) return true;\n        }\n    }\n    return false;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nlet lines = [];\nrl.on(\"line\", (line) => {\n    lines.push(line.trim());\n    if (lines.length === 2) {\n        try {\n            let board;\n            // Try parsing as JSON\n            try {\n                board = JSON.parse(lines[0]);\n            } catch (e) {\n                // Fallback: attempt to parse raw input (e.g., [['A','B','C','E'],...])\n                board = eval(lines[0]); // Use eval cautiously, assuming input is safe\n            }\n            const word = lines[1];\n            const result = exist(board, word);\n            process.stdout.write(result.toString()); // Avoid trailing newline\n            rl.close();\n        } catch (e) {\n            process.stdout.write(\"Invalid input format\");\n            process.exit(1);\n        }\n    }\n});"
    }
  },
  {
    "title": "Find the Largest Number in an Array",
    "description": "Given an array of integers, find the largest number in the array.\n\n### Problem Statement\n\nYou are given an array **nums** containing n integers. Find and return the largest number in the array. If the array is empty, return null or an appropriate sentinel value depending on the language.\n\n### Input\n\n- **nums**: An array of integers (0 <= nums.length <= 100, -10^5 <= nums[i] <= 10^5).\n\n### Output\n\n- An integer representing the largest number in the array, or null (or equivalent) if the array is empty.\n\n### Example\n\n**Input**: nums = [4, 2, 7, 1, 9]  \n**Output**: 9  \n**Explanation**: The largest number in the array is 9.\n\n**Input**: nums = [3]  \n**Output**: 3  \n**Explanation**: The only number in the array is 3.\n\n**Input**: nums = []  \n**Output**: null  \n**Explanation**: The array is empty, so return null.\n\n### Notes\n\n- A single pass through the array is sufficient to find the maximum.\n- Handle the edge case of an empty array appropriately.\n\n### Real-World Context\n\nThis problem is relevant in applications like finding the maximum value in a dataset, such as the highest stock price or peak performance metric, common in data analysis tasks at companies like Oracle and Cisco.",
    "difficulty": "EASY",
    "tags": [
      "Array",
      "Linear Scan",
      "Tcs",
      "Infosys"
    ],
    "constraints": [
      "0 <= nums.length <= 100",
      "-10^5 <= nums[i] <= 10^5",
      "Return null or equivalent for empty array",
      "Time complexity should be O(n)",
      "Space complexity should be O(1)"
    ],
    "examples": [
      {
        "input": "nums = [4, 2, 7, 1, 9]",
        "output": "9",
        "explanation": "The largest number in the array is 9."
      }
    ],
    "testcases": [
      {
        "input": "[4,2,7,1,9]",
        "output": "9",
        "isHidden": false
      },
      {
        "input": "[3]",
        "output": "3",
        "isHidden": false
      },
      {
        "input": "[]",
        "output": "null",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Iterate through the array and keep track of the largest number seen so far.",
      "2. Handle the empty array case by returning null or a sentinel value.",
      "3. Initialize the maximum with the first element or a very small number."
    ],
    "editorial": "## Editorial: Find the Largest Number in an Array\n\n### Problem Recap\n\nFind the largest integer in an array of integers, or return null if the array is empty.\n\n### Intuition\n\nThis is a simple problem requiring a single pass through the array to track the maximum value. The key is to handle the empty array case and initialize the maximum correctly.\n\n### Approach\n\n#### Linear Scan\n\n- **Idea**: Iterate through the array, updating the maximum whenever a larger value is found.\n- **Steps**:\n  1. If the array is empty, return null (or equivalent).\n  2. Initialize the maximum as the first element or a small number.\n  3. Iterate through the array, updating the maximum if a larger value is found.\n  4. Return the maximum.\n- **Time Complexity**: O(n) for one pass.\n- **Space Complexity**: O(1) as only a single variable is needed.\n\n### Recommended Solution\n\nThe linear scan approach is optimal due to its simplicity and efficiency.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for iterating through the array.\n- **Space Complexity**: O(1) for storing the maximum.\n- **Constraints Handling**:\n  - Array length: 0 <= n <= 100.\n  - Values: -10^5 <= nums[i] <= 10^5.\n\n### Edge Cases\n\n- **Empty array**: nums = [] → null.\n- **Single element**: nums = [5] → 5.\n- **All same values**: nums = [3,3,3] → 3.\n- **Negative numbers**: nums = [-1,-5,2] → 2.\n\n### Implementation Notes\n\n- Ensure proper handling of empty arrays in each language.\n- Use appropriate null/None equivalents based on the language.\n- Avoid integer overflow by using the first element as the initial maximum.\n\n### Visual Explanation\n\nFor nums = [4,2,7,1,9]:\n- Initialize max = 4.\n- Compare: max = max(4,2) = 4, max(4,7) = 7, max(7,1) = 7, max(7,9) = 9.\n- Return 9.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc findLargest(nums []int) *int {\n    // Write your code here\n    return nil\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Print(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    nums := make([]int, 0)\n    if input == \"[]\" {\n        // Handle empty array\n    } else {\n        input = input[1 : len(input)-1]\n        strNums := strings.Split(input, \",\")\n        for _, s := range strNums {\n            num, err := strconv.Atoi(strings.TrimSpace(s))\n            if err != nil {\n                fmt.Print(\"Invalid input format\")\n                return\n            }\n            nums = append(nums, num)\n        }\n    }\n    result := findLargest(nums)\n    if result == nil {\n        fmt.Print(\"null\")\n    } else {\n        fmt.Print(*result)\n    }\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findLargest(vector<int>& nums) {\n        // Write your code here\n        return 0; // Placeholder\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\";\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        if (line.empty()) {\n            // Handle empty array\n        } else {\n            size_t pos = 0;\n            while ((pos = line.find(\",\")) != string::npos) {\n                nums.push_back(stoi(line.substr(0, pos)));\n                line.erase(0, pos + 1);\n            }\n            if (!line.empty()) nums.push_back(stoi(line));\n        }\n        Solution sol;\n        if (nums.empty()) cout << \"null\";\n        else cout << sol.findLargest(nums);\n    } catch (...) {\n        cout << \"Invalid input format\";\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Finds the largest number in an array.\n     * @param nums Array of integers\n     * @return Largest number or null if empty\n     */\n    public Integer findLargest(int[] nums) {\n        // Write your code here\n        return null;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            int[] nums;\n            if (line.equals(\"[]\")) {\n                nums = new int[0]; // Handle empty array\n            } else {\n                String[] strNums = line.substring(1, line.length()-1).split(\",\");\n                nums = new int[strNums.length];\n                for (int i = 0; i < strNums.length; i++) {\n                    nums[i] = Integer.parseInt(strNums[i].trim());\n                }\n            }\n            Main main = new Main();\n            Integer result = main.findLargest(nums);\n            System.out.print(result == null ? \"null\" : result); // Output without newline\n        } catch (Exception e) {\n            System.out.print(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import sys\nimport json\n\nclass Solution:\n    def findLargest(self, nums):\n        \"\"\"\n        Finds the largest number in an array.\n        :param nums: List of integers\n        :return: Largest number or None if empty\n        \"\"\"\n        # Write your code here\n        return None\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.findLargest(nums)\n        print(\"null\" if result is None else result)\n    except Exception:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds the largest number in an array.\n * @param {number[]} nums - Array of integers\n * @return {number|null} - Largest number or null if empty\n */\nfunction findLargest(nums) {\n    // Write your code here\n    return null;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const nums = JSON.parse(line.trim());\n        const result = findLargest(nums);\n        console.log(result === null ? \"null\" : result);\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc findLargest(nums []int) *int {\n    if len(nums) == 0 {\n        return nil\n    }\n    max := nums[0]\n    for _, num := range nums[1:] {\n        if num > max {\n            max = num\n        }\n    }\n    return &max\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Print(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    nums := make([]int, 0)\n    if input == \"[]\" {\n        // Handle empty array\n    } else {\n        input = input[1 : len(input)-1]\n        strNums := strings.Split(input, \",\")\n        for _, s := range strNums {\n            num, err := strconv.Atoi(strings.TrimSpace(s))\n            if err != nil {\n                fmt.Print(\"Invalid input format\")\n                return\n            }\n            nums = append(nums, num)\n        }\n    }\n    result := findLargest(nums)\n    if result == nil {\n        fmt.Print(\"null\")\n    } else {\n        fmt.Print(*result)\n    }\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findLargest(vector<int>& nums) {\n        if (nums.empty()) return 0; // Handled in main\n        int max = nums[0];\n        for (int i = 1; i < nums.size(); i++) {\n            if (nums[i] > max) max = nums[i];\n        }\n        return max;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\";\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        if (line.empty()) {\n            // Handle empty array\n        } else {\n            size_t pos = 0;\n            while ((pos = line.find(\",\")) != string::npos) {\n                nums.push_back(stoi(line.substr(0, pos)));\n                line.erase(0, pos + 1);\n            }\n            if (!line.empty()) nums.push_back(stoi(line));\n        }\n        Solution sol;\n        if (nums.empty()) cout << \"null\";\n        else cout << sol.findLargest(nums);\n    } catch (...) {\n        cout << \"Invalid input format\";\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public Integer findLargest(int[] nums) {\n        if (nums.length == 0) return null;\n        int max = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] > max) max = nums[i];\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            int[] nums;\n            if (line.equals(\"[]\")) {\n                nums = new int[0]; // Handle empty array\n            } else {\n                String[] strNums = line.substring(1, line.length()-1).split(\",\");\n                nums = new int[strNums.length];\n                for (int i = 0; i < strNums.length; i++) {\n                    nums[i] = Integer.parseInt(strNums[i].trim());\n                }\n            }\n            Main main = new Main();\n            Integer result = main.findLargest(nums);\n            System.out.print(result == null ? \"null\" : result); // Output without newline\n        } catch (Exception e) {\n            System.out.print(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import sys\nimport json\n\nclass Solution:\n    def findLargest(self, nums):\n        if not nums:\n            return None\n        max_val = nums[0]\n        for num in nums[1:]:\n            if num > max_val:\n                max_val = num\n        return max_val\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.findLargest(nums)\n        print(\"null\" if result is None else result)\n    except Exception:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds the largest number in an array.\n * @param {number[]} nums - Array of integers\n * @return {number|null} - Largest number or null if empty\n */\nfunction findLargest(nums) {\n    if (nums.length === 0) return null;\n    let max = nums[0];\n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] > max) max = nums[i];\n    }\n    return max;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const nums = JSON.parse(line.trim());\n        const result = findLargest(nums);\n        console.log(result === null ? \"null\" : result);\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    }
  },
  {
    "title": "Find the Smallest Number in an Array",
    "description": "Given an array of integers, find the smallest number in the array.\n\n### Problem Statement\n\nYou are given an array **nums** containing n integers. Find and return the smallest number in the array. If the array is empty, return null or an appropriate sentinel value depending on the language.\n\n### Input\n\n- **nums**: An array of integers (0 <= nums.length <= 100, -10^5 <= nums[i] <= 10^5).\n\n### Output\n\n- An integer representing the smallest number in the array, or null (or equivalent) if the array is empty.\n\n### Example\n\n**Input**: nums = [4, 2, 7, 1, 9]  \n**Output**: 1  \n**Explanation**: The smallest number in the array is 1.\n\n**Input**: nums = [3]  \n**Output**: 3  \n**Explanation**: The only number in the array is 3.\n\n**Input**: nums = []  \n**Output**: null  \n**Explanation**: The array is empty, so return null.\n\n### Notes\n\n- A simple linear scan of the array is sufficient to find the minimum.\n- Handle the edge case of an empty array appropriately.\n\n### Real-World Context\n\nThis problem is common in scenarios like finding the minimum value in a dataset, such as the lowest price in a list of products or the minimum temperature in a weather record, often used in data processing tasks at companies like TCS and Infosys.",
    "difficulty": "EASY",
    "tags": [
      "Array",
      "Linear Scan",
      "Tcs",
      "Infosys"
    ],
    "constraints": [
      "0 <= nums.length <= 100",
      "-10^5 <= nums[i] <= 10^5",
      "Return null or equivalent for empty array",
      "Time complexity should be O(n)",
      "Space complexity should be O(1)"
    ],
    "examples": [
      {
        "input": "nums = [4, 2, 7, 1, 9]",
        "output": "1",
        "explanation": "The smallest number in the array is 1."
      }
    ],
    "testcases": [
      {
        "input": "[4,2,7,1,9]",
        "output": "1",
        "isHidden": false
      },
      {
        "input": "[3]",
        "output": "3",
        "isHidden": false
      },
      {
        "input": "[]",
        "output": "null",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Iterate through the array and keep track of the smallest number seen so far.",
      "2. Handle the empty array case by returning null or a sentinel value.",
      "3. Initialize the minimum with the first element or a very large number."
    ],
    "editorial": "## Editorial: Find the Smallest Number in an Array\n\n### Problem Recap\n\nFind the smallest integer in an array of integers, or return null if the array is empty.\n\n### Intuition\n\nThis is a straightforward problem requiring a single pass through the array to track the minimum value. The challenge lies in handling the empty array case and ensuring correct initialization of the minimum value.\n\n### Approach\n\n#### Linear Scan\n\n- **Idea**: Iterate through the array, updating the minimum whenever a smaller value is found.\n- **Steps**:\n  1. If the array is empty, return null (or equivalent).\n  2. Initialize the minimum as the first element or a large number.\n  3. Iterate through the array, updating the minimum if a smaller value is found.\n  4. Return the minimum.\n- **Time Complexity**: O(n) for one pass.\n- **Space Complexity**: O(1) as only a single variable is needed.\n\n### Recommended Solution\n\nThe linear scan approach is optimal due to its simplicity and efficiency.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for iterating through the array.\n- **Space Complexity**: O(1) for storing the minimum.\n- **Constraints Handling**:\n  - Array length: 0 <= n <= 100.\n  - Values: -10^5 <= nums[i] <= 10^5.\n\n### Edge Cases\n\n- **Empty array**: nums = [] → null.\n- **Single element**: nums = [5] → 5.\n- **All same values**: nums = [3,3,3] → 3.\n- **Negative numbers**: nums = [-1,-5,2] → -5.\n\n### Implementation Notes\n\n- Ensure proper handling of empty arrays in each language.\n- Use appropriate null/None equivalents based on the language.\n- Avoid integer overflow by using the first element as the initial minimum.\n\n### Visual Explanation\n\nFor nums = [4,2,7,1,9]:\n- Initialize min = 4.\n- Compare: min = min(4,2) = 2, min(2,7) = 2, min(2,1) = 1, min(1,9) = 1.\n- Return 1.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc findSmallest(nums []int) *int {\n    // Write your code here\n    return nil\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Print(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    nums := make([]int, 0)\n    if input == \"[]\" {\n        // Handle empty array\n    } else {\n        input = input[1 : len(input)-1]\n        strNums := strings.Split(input, \",\")\n        for _, s := range strNums {\n            num, err := strconv.Atoi(strings.TrimSpace(s))\n            if err != nil {\n                fmt.Print(\"Invalid input format\")\n                return\n            }\n            nums = append(nums, num)\n        }\n    }\n    result := findSmallest(nums)\n    if result == nil {\n        fmt.Print(\"null\")\n    } else {\n        fmt.Print(*result)\n    }\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findSmallest(vector<int>& nums) {\n        // Write your code here\n        return 0; // Placeholder\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        size_t pos = 0;\n        while ((pos = line.find(\",\")) != string::npos) {\n            nums.push_back(stoi(line.substr(0, pos)));\n            line.erase(0, pos + 1);\n        }\n        if (!line.empty()) nums.push_back(stoi(line));\n        Solution sol;\n        int result = sol.findSmallest(nums);\n        if (nums.empty()) cout << \"null\" << endl;\n        else cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Finds the smallest number in an array.\n     * @param nums Array of integers\n     * @return Smallest number or null if empty\n     */\n    public Integer findSmallest(int[] nums) {\n        // Write your code here\n        return null;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            int[] nums;\n            if (line.equals(\"[]\")) {\n                nums = new int[0]; // Handle empty array\n            } else {\n                String[] strNums = line.substring(1, line.length()-1).split(\",\");\n                nums = new int[strNums.length];\n                for (int i = 0; i < strNums.length; i++) {\n                    nums[i] = Integer.parseInt(strNums[i].trim());\n                }\n            }\n            Main main = new Main();\n            Integer result = main.findSmallest(nums);\n            System.out.print(result == null ? \"null\" : result); // Output without newline\n        } catch (Exception e) {\n            System.out.print(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import sys\nimport json\n\nclass Solution:\n    def findSmallest(self, nums):\n        \"\"\"\n        Finds the smallest number in an array.\n        :param nums: List of integers\n        :return: Smallest number or None if empty\n        \"\"\"\n        # Write your code here\n        return None\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.findSmallest(nums)\n        print(\"null\" if result is None else result)\n    except Exception:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds the smallest number in an array.\n * @param {number[]} nums - Array of integers\n * @return {number|null} - Smallest number or null if empty\n */\nfunction findSmallest(nums) {\n    // Write your code here\n    return null;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const nums = JSON.parse(line.trim());\n        const result = findSmallest(nums);\n        console.log(result === null ? \"null\" : result);\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc findSmallest(nums []int) *int {\n    if len(nums) == 0 {\n        return nil\n    }\n    min := nums[0]\n    for _, num := range nums[1:] {\n        if num < min {\n            min = num\n        }\n    }\n    return &min\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Print(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    nums := make([]int, 0)\n    if input == \"[]\" {\n        // Handle empty array\n    } else {\n        input = input[1 : len(input)-1]\n        strNums := strings.Split(input, \",\")\n        for _, s := range strNums {\n            num, err := strconv.Atoi(strings.TrimSpace(s))\n            if err != nil {\n                fmt.Print(\"Invalid input format\")\n                return\n            }\n            nums = append(nums, num)\n        }\n    }\n    result := findSmallest(nums)\n    if result == nil {\n        fmt.Print(\"null\")\n    } else {\n        fmt.Print(*result)\n    }\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findSmallest(vector<int>& nums) {\n        if (nums.empty()) return 0; // Handled in main\n        int min = nums[0];\n        for (int i = 1; i < nums.size(); i++) {\n            if (nums[i] < min) min = nums[i];\n        }\n        return min;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        size_t pos = 0;\n        while ((pos = line.find(\",\")) != string::npos) {\n            nums.push_back(stoi(line.substr(0, pos)));\n            line.erase(0, pos + 1);\n        }\n        if (!line.empty()) nums.push_back(stoi(line));\n        Solution sol;\n        if (nums.empty()) cout << \"null\" << endl;\n        else cout << sol.findSmallest(nums) << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public Integer findSmallest(int[] nums) {\n        if (nums.length == 0) return null;\n        int min = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] < min) min = nums[i];\n        }\n        return min;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            int[] nums;\n            if (line.equals(\"[]\")) {\n                nums = new int[0]; // Handle empty array\n            } else {\n                String[] strNums = line.substring(1, line.length()-1).split(\",\");\n                nums = new int[strNums.length];\n                for (int i = 0; i < strNums.length; i++) {\n                    nums[i] = Integer.parseInt(strNums[i].trim());\n                }\n            }\n            Main main = new Main();\n            Integer result = main.findSmallest(nums);\n            System.out.print(result == null ? \"null\" : result); // Output without newline\n        } catch (Exception e) {\n            System.out.print(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import sys\nimport json\n\nclass Solution:\n    def findSmallest(self, nums):\n        if not nums:\n            return None\n        min_val = nums[0]\n        for num in nums[1:]:\n            if num < min_val:\n                min_val = num\n        return min_val\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.findSmallest(nums)\n        print(\"null\" if result is None else result)\n    except Exception:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds the smallest number in an array.\n * @param {number[]} nums - Array of integers\n * @return {number|null} - Smallest number or null if empty\n */\nfunction findSmallest(nums) {\n    if (nums.length === 0) return null;\n    let min = nums[0];\n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] < min) min = nums[i];\n    }\n    return min;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const nums = JSON.parse(line.trim());\n        const result = findSmallest(nums);\n        console.log(result === null ? \"null\" : result);\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    }
  },
  {
    "title": "Remove Duplicates from Sorted List",
    "description": "Given a sorted linked list, delete all duplicates such that each element appears only once.\n\n### Problem Statement\n\nYou are given the head of a sorted linked list **head**. Remove all duplicate nodes so that each value appears exactly once, and return the head of the modified list.\n\n### Input\n\n- **head**: The head of a sorted linked list (0 <= number of nodes <= 300, -100 <= Node.val <= 100).\n\n### Output\n\n- The head of the linked list after removing duplicates, represented as an array of node values.\n\n### Example\n\n**Input**: head = [1,1,2]  \n**Output**: [1,2]  \n**Explanation**: Remove the duplicate 1, resulting in 1->2.\n\n**Input**: head = [1,1,2,3,3]  \n**Output**: [1,2,3]  \n**Explanation**: Remove duplicates 1 and 3, resulting in 1->2->3.\n\n**Input**: head = []  \n**Output**: []  \n**Explanation**: Empty list remains empty.\n\n### Notes\n\n- The list is guaranteed to be sorted in ascending order.\n- Modify the list in-place by adjusting next pointers.\n\n### Real-World Context\n\nThis problem models tasks like cleaning sorted datasets, such as removing duplicate entries in a database or log file, while preserving order.",
    "difficulty": "EASY",
    "tags": [
      "Linked List",
      "Tcs",
      "Google",
      "Amazon",
      "Oracle",
      "Bloomberg",
      "Atlassian"
    ],
    "constraints": [
      "0 <= number of nodes <= 300",
      "-100 <= Node.val <= 100",
      "The list is sorted in ascending order",
      "Time complexity should be O(n), where n is the number of nodes",
      "Space complexity should be O(1)"
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 2]",
        "output": "[1,2]",
        "explanation": "Remove the duplicate 1, resulting in 1->2."
      }
    ],
    "testcases": [
      {
        "id": "tc1",
        "input": "[1,1,2]",
        "output": "[1,2]",
        "isHidden": false,
        "explanation": "Remove duplicate 1"
      },
      {
        "id": "tc2",
        "input": "[1,1,2,3,3]",
        "output": "[1,2,3]",
        "isHidden": false,
        "explanation": "Remove duplicates 1 and 3"
      },
      {
        "id": "tc3",
        "input": "[]",
        "output": "[]",
        "isHidden": false,
        "explanation": "Empty list"
      },
      {
        "id": "tc4",
        "input": "[1,1,1]",
        "output": "[1]",
        "isHidden": true,
        "explanation": "Remove all duplicate 1s"
      },
      {
        "id": "tc5",
        "input": "[1,2,3]",
        "output": "[1,2,3]",
        "isHidden": true,
        "explanation": "No duplicates to remove"
      }
    ],
    "hints": [
      "1. Since the list is sorted, duplicates are adjacent.",
      "2. Traverse the list with a single pointer, comparing each node with the next.",
      "3. Adjust the next pointer to skip duplicates."
    ],
    "editorial": "## Editorial: Remove Duplicates from Sorted List\n\n### Problem Recap\n\nRemove all duplicates from a sorted linked list so each value appears once.\n\n### Intuition\n\nSince the list is sorted, duplicates are adjacent. A single pass through the list, comparing each node with the next, allows us to skip duplicates by adjusting pointers.\n\n### Approaches\n\n#### 1. Iterative Traversal\n\n- **Idea**: Traverse the list, skipping duplicates by changing next pointers.\n- **Steps**:\n  1. If the list is empty or has one node, return as is.\n  2. Initialize a pointer at head.\n  3. While current and current.next exist:\n     - If current.val == current.next.val, skip the next node.\n     - Else, move to the next node.\n  4. Return head.\n- **Time Complexity**: O(n) for one pass.\n- **Space Complexity**: O(1) for pointer.\n- **Pros**: Simple, in-place.\n\n### Recommended Solution\n\nIterative traversal is optimal and straightforward.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for single pass.\n- **Space Complexity**: O(1).\n- **Constraints Handling**:\n  - Nodes: 0 <= n <= 300.\n  - Values: -100 <= Node.val <= 100.\n\n### Edge Cases\n\n- **Empty list**: head = [] → [].\n- **Single node**: head = [1] → [1].\n- **All duplicates**: head = [1,1,1] → [1].\n- **No duplicates**: head = [1,2,3] → [1,2,3].\n\n### Implementation Notes\n\n- Use a ListNode class/structure for the linked list.\n- Input is a JSON array, converted to a linked list.\n- Output is the modified list as a JSON array.\n- Handle null checks to avoid errors.\n\n### Visual Explanation\n\nFor head = [1,1,2]:\n- Start at 1, next is 1, skip duplicate.\n- Connect 1 to 2.\n- Result: [1,2].",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc deleteDuplicates(head *ListNode) *ListNode {\n    // Write your code here\n    return head\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    input = input[1 : len(input)-1]\n    var values []int\n    if input != \"\" {\n        strNums := strings.Split(input, \",\")\n        for _, s := range strNums {\n            num, err := strconv.Atoi(strings.TrimSpace(s))\n            if err != nil {\n                fmt.Println(\"Invalid input format\")\n                return\n            }\n            values = append(values, num)\n        }\n    }\n    var head, curr *ListNode\n    for _, val := range values {\n        node := &ListNode{Val: val}\n        if head == nil {\n            head = node\n        }\n        if curr != nil {\n            curr.Next = node\n        }\n        curr = node\n    }\n    result := deleteDuplicates(head)\n    fmt.Print(\"[\")\n    for result != nil {\n        fmt.Print(result.Val)\n        result = result.Next\n        if result != nil {\n            fmt.Print(\",\")\n        }\n    }\n    fmt.Println(\"]\")\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        // Write your code here\n        return head;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> values;\n        size_t pos = 0;\n        while ((pos = line.find(\",\")) != string::npos) {\n            values.push_back(stoi(line.substr(0, pos)));\n            line.erase(0, pos + 1);\n        }\n        if (!line.empty()) values.push_back(stoi(line));\n        ListNode* head = nullptr;\n        ListNode* curr = nullptr;\n        for (int val : values) {\n            ListNode* node = new ListNode(val);\n            if (!head) head = node;\n            if (curr) curr->next = node;\n            curr = node;\n        }\n        Solution sol;\n        ListNode* result = sol.deleteDuplicates(head);\n        cout << \"[\";\n        while (result) {\n            cout << result->val;\n            result = result->next;\n            if (result) cout << \",\";\n        }\n        cout << \"]\" << endl;\n        // Clean up memory\n        while (head) {\n            ListNode* temp = head;\n            head = head->next;\n            delete temp;\n        }\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int val) { this.val = val; }\n        ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n    }\n\n    /**\n     * Removes duplicates from a sorted linked list.\n     * @param head Head of the sorted linked list\n     * @return Head of the modified list\n     */\n    public ListNode deleteDuplicates(ListNode head) {\n        // Write your code here\n        return head;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            String[] strNums = line.substring(1, line.length()-1).split(\",\");\n            ListNode head = null, curr = null;\n            for (String s : strNums) {\n                int val = Integer.parseInt(s.trim());\n                ListNode node = new ListNode(val);\n                if (head == null) head = node;\n                if (curr != null) curr.next = node;\n                curr = node;\n            }\n            Main main = new Main();\n            ListNode result = main.deleteDuplicates(head);\n            System.out.print(\"[\");\n            while (result != null) {\n                System.out.print(result.val);\n                result = result.next;\n                if (result != null) System.out.print(\",\");\n            }\n            System.out.println(\"]\");\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\n        \"\"\"\n        Removes duplicates from a sorted linked list.\n        :param head: Head of the sorted linked list\n        :return: Head of the modified list\n        \"\"\"\n        # Write your code here\n        return head\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    import json\n\n    class ListNode:\n        def __init__(self, val=0, next=None):\n            self.val = val\n            self.next = next\n\n    try:\n        arr = json.loads(sys.stdin.readline().strip())\n        head = None\n        curr = None\n        for val in arr:\n            node = ListNode(val)\n            if not head:\n                head = node\n            if curr:\n                curr.next = node\n            curr = node\n        sol = Solution()\n        result = sol.deleteDuplicates(head)\n        output = []\n        while result:\n            output.append(result.val)\n            result = result.next\n        print(json.dumps(output))\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Removes duplicates from a sorted linked list.\n * @param {ListNode} head - Head of the sorted linked list\n * @return {ListNode}\n */\nfunction deleteDuplicates(head) {\n    // Write your code here\n    return head;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nfunction ListNode(val, next) {\n    this.val = (val===undefined ? 0 : val);\n    this.next = (next===undefined ? null : next);\n}\n\nrl.on(\"line\", (line) => {\n    try {\n        const arr = JSON.parse(line.trim());\n        let head = null, curr = null;\n        for (let val of arr) {\n            const node = new ListNode(val);\n            if (!head) head = node;\n            if (curr) curr.next = node;\n            curr = node;\n        }\n        const result = deleteDuplicates(head);\n        const output = [];\n        while (result) {\n            output.push(result.val);\n            result = result.next;\n        }\n        console.log(JSON.stringify(output));\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc deleteDuplicates(head *ListNode) *ListNode {\n    if head == nil {\n        return head\n    }\n    curr := head\n    for curr != nil && curr.Next != nil {\n        if curr.Val == curr.Next.Val {\n            curr.Next = curr.Next.Next\n        } else {\n            curr = curr.Next\n        }\n    }\n    return head\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    input = input[1 : len(input)-1]\n    var values []int\n    if input != \"\" {\n        strNums := strings.Split(input, \",\")\n        for _, s := range strNums {\n            num, err := strconv.Atoi(strings.TrimSpace(s))\n            if err != nil {\n                fmt.Println(\"Invalid input format\")\n                return\n            }\n            values = append(values, num)\n        }\n    }\n    var head, curr *ListNode\n    for _, val := range values {\n        node := &ListNode{Val: val}\n        if head == nil {\n            head = node\n        }\n        if curr != nil {\n            curr.Next = node\n        }\n        curr = node\n    }\n    result := deleteDuplicates(head)\n    fmt.Print(\"[\")\n    for result != nil {\n        fmt.Print(result.Val)\n        result = result.Next\n        if result != nil {\n            fmt.Print(\",\")\n        }\n    }\n    fmt.Println(\"]\")\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        if (!head) return head;\n        ListNode* curr = head;\n        while (curr && curr->next) {\n            if (curr->val == curr->next->val) {\n                ListNode* temp = curr->next;\n                curr->next = curr->next->next;\n                delete temp;\n            } else {\n                curr = curr->next;\n            }\n        }\n        return head;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> values;\n        size_t pos = 0;\n        while ((pos = line.find(\",\")) != string::npos) {\n            values.push_back(stoi(line.substr(0, pos)));\n            line.erase(0, pos + 1);\n        }\n        if (!line.empty()) values.push_back(stoi(line));\n        ListNode* head = nullptr;\n        ListNode* curr = nullptr;\n        for (int val : values) {\n            ListNode* node = new ListNode(val);\n            if (!head) head = node;\n            if (curr) curr->next = node;\n            curr = node;\n        }\n        Solution sol;\n        ListNode* result = sol.deleteDuplicates(head);\n        cout << \"[\";\n        while (result) {\n            cout << result->val;\n            result = result->next;\n            if (result) cout << \",\";\n        }\n        cout << \"]\" << endl;\n        // Clean up memory\n        while (head) {\n            ListNode* temp = head;\n            head = head->next;\n            delete temp;\n        }\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int val) { this.val = val; }\n        ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n    }\n\n    public ListNode deleteDuplicates(ListNode head) {\n        if (head == null) return head;\n        ListNode curr = head;\n        while (curr != null && curr.next != null) {\n            if (curr.val == curr.next.val) {\n                curr.next = curr.next.next;\n            } else {\n                curr = curr.next;\n            }\n        }\n        return head;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            String[] strNums = line.substring(1, line.length()-1).split(\",\");\n            ListNode head = null, curr = null;\n            for (String s : strNums) {\n                int val = Integer.parseInt(s.trim());\n                ListNode node = new ListNode(val);\n                if (head == null) head = node;\n                if (curr != null) curr.next = node;\n                curr = node;\n            }\n            Main main = new Main();\n            ListNode result = main.deleteDuplicates(head);\n            System.out.print(\"[\");\n            while (result != null) {\n                System.out.print(result.val);\n                result = result.next;\n                if (result != null) System.out.print(\",\");\n            }\n            System.out.println(\"]\");\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\n        if not head:\n            return head\n        curr = head\n        while curr and curr.next:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return head\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    import json\n\n    class ListNode:\n        def __init__(self, val=0, next=None):\n            self.val = val\n            self.next = next\n\n    try:\n        arr = json.loads(sys.stdin.readline().strip())\n        head = None\n        curr = None\n        for val in arr:\n            node = ListNode(val)\n            if not head:\n                head = node\n            if curr:\n                curr.next = node\n            curr = node\n        sol = Solution()\n        result = sol.deleteDuplicates(head)\n        output = []\n        while result:\n            output.append(result.val)\n            result = result.next\n        print(json.dumps(output))\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Removes duplicates from a sorted linked list.\n * @param {ListNode} head - Head of the sorted linked list\n * @return {ListNode}\n */\nfunction deleteDuplicates(head) {\n    if (!head) return head;\n    let curr = head;\n    while (curr && curr.next) {\n        if (curr.val === curr.next.val) {\n            curr.next = curr.next.next;\n        } else {\n            curr = curr.next;\n        }\n    }\n    return head;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nfunction ListNode(val, next) {\n    this.val = (val===undefined ? 0 : val);\n    this.next = (next===undefined ? null : next);\n}\n\nrl.on(\"line\", (line) => {\n    try {\n        const arr = JSON.parse(line.trim());\n        let head = null, curr = null;\n        for (let val of arr) {\n            const node = new ListNode(val);\n            if (!head) head = node;\n            if (curr) curr.next = node;\n            curr = node;\n        }\n        const result = deleteDuplicates(head);\n        const output = [];\n        while (result) {\n            output.push(result.val);\n            result = result.next;\n        }\n        console.log(JSON.stringify(output));\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    }
  },
  {
    "title": "Reverse a Given Array",
    "description": "Given an array of integers, reverse the array in-place.\n\n### Problem Statement\n\nYou are given an array **nums** containing n integers. Reverse the array in-place, meaning you must modify the original array without using extra space for another array.\n\n### Input\n\n- **nums**: An array of integers (0 <= nums.length <= 100, -10^5 <= nums[i] <= 10^5).\n\n### Output\n\n- Modify **nums** in-place to have its elements in reverse order.\n\n### Example\n\n**Input**: nums = [1,2,3,4,5]  \n**Output**: [5,4,3,2,1]  \n**Explanation**: The array is reversed in-place.\n\n**Input**: nums = [1]  \n**Output**: [1]  \n**Explanation**: Single element array is already reversed.\n\n**Input**: nums = []  \n**Output**: []  \n**Explanation**: Empty array remains empty.\n\n### Notes\n\n- Use two pointers to swap elements from the start and end of the array.\n- No extra array should be used to achieve O(1) space complexity.\n\n### Real-World Context\n\nThis problem is relevant in scenarios like reversing a sequence of data, such as log entries or transaction records, common in data processing tasks at companies like Cisco and Oracle.",
    "difficulty": "EASY",
    "tags": [
      "Array",
      "Two Pointers",
      "Cisco",
      "Infosys",
      "Tcs"
    ],
    "constraints": [
      "0 <= nums.length <= 100",
      "-10^5 <= nums[i] <= 10^5",
      "Modify the array in-place",
      "Time complexity should be O(n)",
      "Space complexity should be O(1)"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5]",
        "output": "[5,4,3,2,1]",
        "explanation": "The array is reversed in-place."
      }
    ],
    "testcases": [
      {
        "input": "[1,2,3,4,5]",
        "output": "[5,4,3,2,1]",
        "isHidden": false
      },
      {
        "input": "[1]",
        "output": "[1]",
        "isHidden": false
      },
      {
        "input": "[]",
        "output": "[]",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Use two pointers: one starting from the beginning and one from the end.",
      "2. Swap elements at these pointers and move them towards the center.",
      "3. Stop when the pointers meet or cross."
    ],
    "editorial": "## Editorial: Reverse a Given Array\n\n### Problem Recap\n\nReverse an array of integers in-place without using extra space.\n\n### Intuition\n\nThe two-pointer technique is ideal for reversing an array in-place. By swapping elements from the start and end, we can reverse the array in one pass with constant space.\n\n### Approach\n\n#### Two-Pointer Technique\n\n- **Idea**: Use two pointers (left and right) to swap elements from the ends towards the center.\n- **Steps**:\n  1. Initialize left = 0 and right = nums.length - 1.\n  2. While left < right:\n     - Swap nums[left] and nums[right].\n     - Increment left, decrement right.\n  3. The array is reversed in-place.\n- **Time Complexity**: O(n/2) ≈ O(n) for swaps.\n- **Space Complexity**: O(1) for pointers.\n\n### Recommended Solution\n\nThe two-pointer approach is optimal for its simplicity and O(1) space usage.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for iterating through half the array.\n- **Space Complexity**: O(1) for two pointers.\n- **Constraints Handling**:\n  - Array length: 0 <= n <= 100.\n  - Values: -10^5 <= nums[i] <= 10^5.\n\n### Edge Cases\n\n- **Empty array**: nums = [] → [].\n- **Single element**: nums = [1] → [1].\n- **Two elements**: nums = [1,2] → [2,1].\n- **Odd/even length**: Works for both.\n\n### Implementation Notes\n\n- Ensure left < right to avoid redundant swaps.\n- No return value needed as the array is modified in-place.\n- Handle empty and single-element arrays implicitly.\n\n### Visual Explanation\n\nFor nums = [1,2,3,4,5]:\n- left=0, right=4: Swap 1 and 5 → [5,2,3,4,1].\n- left=1, right=3: Swap 2 and 4 → [5,4,3,2,1].\n- Stop when left=2, right=2.\n- Final: [5,4,3,2,1].",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc reverseArray(nums []int) {\n    // Write your code here\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Print(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    nums := make([]int, 0)\n    if input == \"[]\" {\n        // Handle empty array\n    } else {\n        input = input[1 : len(input)-1]\n        strNums := strings.Split(input, \",\")\n        nums = make([]int, len(strNums))\n        for i, s := range strNums {\n            num, err := strconv.Atoi(strings.TrimSpace(s))\n            if err != nil {\n                fmt.Print(\"Invalid input format\")\n                return\n            }\n            nums[i] = num\n        }\n    }\n    reverseArray(nums)\n    fmt.Print(\"[\")\n    for i, num := range nums {\n        fmt.Print(num)\n        if i < len(nums)-1 {\n            fmt.Print(\",\")\n        }\n    }\n    fmt.Print(\"]\") // Output without newline\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    void reverseArray(vector<int>& nums) {\n        // Write your code here\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\";\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        if (line == \"\") {\n            // Handle empty array\n        } else {\n            size_t pos = 0;\n            while ((pos = line.find(\",\")) != string::npos) {\n                nums.push_back(stoi(line.substr(0, pos)));\n                line.erase(0, pos + 1);\n            }\n            if (!line.empty()) nums.push_back(stoi(line));\n        }\n        Solution sol;\n        sol.reverseArray(nums);\n        cout << \"[\";\n        for (size_t i = 0; i < nums.size(); i++) {\n            cout << nums[i];\n            if (i < nums.size() - 1) cout << \",\";\n        }\n        cout << \"]\"; // Output without newline\n    } catch (...) {\n        cout << \"Invalid input format\";\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Reverses an array in-place.\n     * @param nums Array of integers\n     */\n    public void reverseArray(int[] nums) {\n        // Write your code here\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            int[] nums;\n            if (line.equals(\"[]\")) {\n                nums = new int[0]; // Handle empty array\n            } else {\n                String[] strNums = line.substring(1, line.length()-1).split(\",\");\n                nums = new int[strNums.length];\n                for (int i = 0; i < strNums.length; i++) {\n                    nums[i] = Integer.parseInt(strNums[i].trim());\n                }\n            }\n            Main main = new Main();\n            main.reverseArray(nums);\n            System.out.print(\"[\");\n            for (int i = 0; i < nums.length; i++) {\n                System.out.print(nums[i]);\n                if (i < nums.length - 1) System.out.print(\",\");\n            }\n            System.out.print(\"]\"); // Output without newline\n        } catch (Exception e) {\n            System.out.print(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import sys\nimport json\n\nclass Solution:\n    def reverseArray(self, nums):\n        \"\"\"\n        Reverses an array in-place.\n        :param nums: List of integers\n        :return: None, modifies nums in-place\n        \"\"\"\n        # Write your code here\n        pass\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        sol = Solution()\n        sol.reverseArray(nums)\n        sys.stdout.write(\"[\" + \",\".join(map(str, nums)) + \"]\")  # Output without spaces or newline\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Reverses an array in-place.\n * @param {number[]} nums - Array of integers\n * @return {void} - Modifies nums in-place\n */\nfunction reverseArray(nums) {\n    // Write your code here\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const nums = JSON.parse(line.trim());\n        reverseArray(nums);\n        console.log(JSON.stringify(nums));\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc reverseArray(nums []int) {\n    left, right := 0, len(nums)-1\n    for left < right {\n        nums[left], nums[right] = nums[right], nums[left]\n        left++\n        right--\n    }\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Print(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    nums := make([]int, 0)\n    if input == \"[]\" {\n        // Handle empty array\n    } else {\n        input = input[1 : len(input)-1]\n        strNums := strings.Split(input, \",\")\n        nums = make([]int, len(strNums))\n        for i, s := range strNums {\n            num, err := strconv.Atoi(strings.TrimSpace(s))\n            if err != nil {\n                fmt.Print(\"Invalid input format\")\n                return\n            }\n            nums[i] = num\n        }\n    }\n    reverseArray(nums)\n    fmt.Print(\"[\")\n    for i, num := range nums {\n        fmt.Print(num)\n        if i < len(nums)-1 {\n            fmt.Print(\",\")\n        }\n    }\n    fmt.Print(\"]\") // Output without newline\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    void reverseArray(vector<int>& nums) {\n        int left = 0, right = nums.size() - 1;\n        while (left < right) {\n            swap(nums[left], nums[right]);\n            left++;\n            right--;\n        }\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\";\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        if (line == \"\") {\n            // Handle empty array\n        } else {\n            size_t pos = 0;\n            while ((pos = line.find(\",\")) != string::npos) {\n                nums.push_back(stoi(line.substr(0, pos)));\n                line.erase(0, pos + 1);\n            }\n            if (!line.empty()) nums.push_back(stoi(line));\n        }\n        Solution sol;\n        sol.reverseArray(nums);\n        cout << \"[\";\n        for (size_t i = 0; i < nums.size(); i++) {\n            cout << nums[i];\n            if (i < nums.size() - 1) cout << \",\";\n        }\n        cout << \"]\"; // Output without newline\n    } catch (...) {\n        cout << \"Invalid input format\";\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public void reverseArray(int[] nums) {\n        int left = 0, right = nums.length - 1;\n        while (left < right) {\n            int temp = nums[left];\n            nums[left] = nums[right];\n            nums[right] = temp;\n            left++;\n            right--;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            int[] nums;\n            if (line.equals(\"[]\")) {\n                nums = new int[0]; // Handle empty array\n            } else {\n                String[] strNums = line.substring(1, line.length()-1).split(\",\");\n                nums = new int[strNums.length];\n                for (int i = 0; i < strNums.length; i++) {\n                    nums[i] = Integer.parseInt(strNums[i].trim());\n                }\n            }\n            Main main = new Main();\n            main.reverseArray(nums);\n            System.out.print(\"[\");\n            for (int i = 0; i < nums.length; i++) {\n                System.out.print(nums[i]);\n                if (i < nums.length - 1) System.out.print(\",\");\n            }\n            System.out.print(\"]\"); // Output without newline\n        } catch (Exception e) {\n            System.out.print(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import sys\nimport json\n\nclass Solution:\n    def reverseArray(self, nums):\n        left, right = 0, len(nums) - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        sol = Solution()\n        sol.reverseArray(nums)\n        sys.stdout.write(\"[\" + \",\".join(map(str, nums)) + \"]\")  # Output without spaces or newline\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Reverses an array in-place.\n * @param {number[]} nums - Array of integers\n * @return {void} - Modifies nums in-place\n */\nfunction reverseArray(nums) {\n    let left = 0, right = nums.length - 1;\n    while (left < right) {\n        [nums[left], nums[right]] = [nums[right], nums[left]];\n        left++;\n        right--;\n    }\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const nums = JSON.parse(line.trim());\n        reverseArray(nums);\n        console.log(JSON.stringify(nums));\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    }
  },
  {
    "title": "Missing Ranges",
    "description": "Given a sorted integer array **nums**, where the range of elements is in the inclusive range **[lower, upper]**, return its missing ranges as a list of strings. Each missing range should be represented as a single number if the range contains one number, or as \"start->end\" if it contains multiple numbers.\n\n### Problem Statement\n\nReturn a list of strings representing the missing ranges between **lower** and **upper** that are not present in **nums**.\n\n### Input\n\n- **nums**: A sorted array of integers (0 <= nums.length <= 100, -10^9 <= nums[i] <= 10^9).\n- **lower**: The lower bound of the range (inclusive, -10^9 <= lower <= 10^9).\n- **upper**: The upper bound of the range (inclusive, -10^9 <= upper <= 10^9).\n\n### Output\n\n- A list of strings representing the missing ranges.\n\n### Example\n\n**Input**: nums = [0,1,3,50,75], lower = 0, upper = 99  \n**Output**: [\"2\",\"4->49\",\"51->74\",\"76->99\"]  \n**Explanation**: The missing ranges are 2, 4 to 49, 51 to 74, and 76 to 99.\n\n**Input**: nums = [], lower = 1, upper = 1  \n**Output**: [\"1\"]  \n**Explanation**: Only 1 is missing.\n\n### Notes\n\n- The array is sorted and may be empty.\n- Handle large ranges carefully to avoid overflow.\n- Use string formatting for ranges (single number or start->end).\n\n### Real-World Context\n\nThis problem is useful in data validation tasks, such as identifying missing IDs in a database or gaps in time series data, common at companies like Google.",
    "difficulty": "MEDIUM",
    "tags": [
      "Array",
      "Google",
      "Zoho"
    ],
    "constraints": [
      "0 <= nums.length <= 100",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= lower <= upper <= 10^9",
      "Time complexity should be O(n)",
      "Space complexity should be O(1) excluding output"
    ],
    "examples": [
      {
        "input": "nums = [0, 1, 3, 50, 75], lower = 0, upper = 99",
        "output": "[\"2\",\"4->49\",\"51->74\",\"76->99\"]",
        "explanation": "The missing ranges are 2, 4 to 49, 51 to 74, and 76 to 99."
      }
    ],
    "testcases": [
      {
        "id": "tc1",
        "input": "[0,1,3,50,75],0,99",
        "output": "[\"2\",\"4->49\",\"51->74\",\"76->99\"]",
        "isHidden": false,
        "explanation": "Missing ranges are 2, 4-49, 51-74, 76-99"
      },
      {
        "id": "tc2",
        "input": "[],1,1",
        "output": "[\"1\"]",
        "isHidden": false,
        "explanation": "Only 1 is missing"
      },
      {
        "id": "tc3",
        "input": "[1,2,3],1,3",
        "output": "[]",
        "isHidden": true,
        "explanation": "No missing ranges"
      }
    ],
    "hints": [
      "1. Iterate through the array and compare consecutive elements to find gaps.",
      "2. Check the gap between lower and the first element, and upper and the last element.",
      "3. Format single numbers as strings and ranges as 'start->end'."
    ],
    "editorial": "## Editorial: Missing Ranges\n\n### Problem Recap\n\nFind all missing ranges in a sorted array within [lower, upper] and return them as a list of strings.\n\n### Intuition\n\nSince the array is sorted, we can iterate through it to find gaps between consecutive elements, as well as gaps at the boundaries (lower to first element, last element to upper). Each gap is formatted as a single number or a range.\n\n### Approach\n\n#### Linear Scan\n\n- **Idea**: Check gaps between lower, each pair of consecutive elements, and upper.\n- **Steps**:\n  1. Initialize result list and set prev = lower - 1.\n  2. Iterate through nums, setting curr = nums[i] (or upper + 1 for the last gap).\n  3. If curr - prev > 1, add the range [prev + 1, curr - 1] to result.\n  4. Update prev = curr.\n  5. Return result.\n- **Time Complexity**: O(n) for one pass.\n- **Space Complexity**: O(1) excluding output.\n\n### Recommended Solution\n\nThe linear scan is optimal for O(n) time and minimal space.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for iterating through the array.\n- **Space Complexity**: O(1) excluding the output list.\n- **Constraints Handling**:\n  - Array length: 0 <= n <= 100.\n  - Values: -10^9 <= nums[i], lower, upper <= 10^9.\n\n### Edge Cases\n\n- **Empty array**: nums = [], lower = 1, upper = 1 → [\"1\"].\n- **No missing ranges**: nums = [1,2,3], lower = 1, upper = 3 → [].\n- **Large gaps**: nums = [0], lower = -100, upper = 100 → [\"-100->-1\",\"1->100\"].\n\n### Implementation Notes\n\n- Use long for intermediate calculations to avoid overflow.\n- Format single numbers as strings and ranges as 'start->end'.\n- Handle the last gap by checking upper.\n\n### Visual Explanation\n\nFor nums = [0,1,3,50,75], lower = 0, upper = 99:\n- prev = -1, curr = 0: No gap.\n- prev = 0, curr = 1: No gap.\n- prev = 1, curr = 3: Add \"2\".\n- prev = 3, curr = 50: Add \"4->49\".\n- prev = 50, curr = 75: Add \"51->74\".\n- prev = 75, curr = 100: Add \"76->99\".",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc findMissingRanges(nums []int, lower, upper int) []string {\n    // Write your code here\n    return []string{}\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    input = input[1 : len(input)-1]\n    parts := strings.Split(input, \"],\")\n    numsStr := strings.TrimSpace(parts[0][1:])\n    nums := []int{}\n    if numsStr != \"\" {\n        strNums := strings.Split(numsStr, \",\")\n        for _, s := range strNums {\n            num, err := strconv.Atoi(strings.TrimSpace(s))\n            if err != nil {\n                fmt.Println(\"Invalid input format\")\n                return\n            }\n            nums = append(nums, num)\n        }\n    }\n    bounds := strings.Split(parts[1], \",\")\n    lower, _ := strconv.Atoi(strings.TrimSpace(bounds[0]))\n    upper, _ := strconv.Atoi(strings.TrimSpace(bounds[1][:len(bounds[1])-1]))\n    result := findMissingRanges(nums, lower, upper)\n    fmt.Print(\"[\")\n    for i, s := range result {\n        fmt.Print(\"\\\"\" + s + \"\\\"\")\n        if i < len(result)-1 {\n            fmt.Print(\",\")\n        }\n    }\n    fmt.Println(\"]\")\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> findMissingRanges(vector<int>& nums, int lower, int upper) {\n        // Write your code here\n        return {};\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        size_t pos = line.find(\"],\");\n        string numsStr = line.substr(1, pos-1);\n        size_t pos2 = 0;\n        while ((pos2 = numsStr.find(\",\")) != string::npos) {\n            nums.push_back(stoi(numsStr.substr(0, pos2)));\n            numsStr.erase(0, pos2 + 1);\n        }\n        if (!numsStr.empty()) nums.push_back(stoi(numsStr));\n        string bounds = line.substr(pos+2);\n        pos = bounds.find(\",\");\n        int lower = stoi(bounds.substr(0, pos));\n        int upper = stoi(bounds.substr(pos+1));\n        Solution sol;\n        vector<string> result = sol.findMissingRanges(nums, lower, upper);\n        cout << \"[\";\n        for (size_t i = 0; i < result.size(); i++) {\n            cout << \"\\\"\" << result[i] << \"\\\"\";\n            if (i < result.size()-1) cout << \",\";\n        }\n        cout << \"]\" << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.*;\n\npublic class Main {\n    /**\n     * Finds missing ranges in a sorted array.\n     * @param nums Sorted array of integers\n     * @param lower Lower bound\n     * @param upper Upper bound\n     * @return List of missing ranges\n     */\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\n        // Write your code here\n        return new ArrayList<>();\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            String[] parts = line.substring(1, line.length()-1).split(\"\\],\");\n            String[] strNums = parts[0].substring(1).split(\",\");\n            int[] nums = new int[strNums.length];\n            for (int i = 0; i < strNums.length; i++) {\n                nums[i] = Integer.parseInt(strNums[i].trim());\n            }\n            String[] bounds = parts[1].split(\",\");\n            int lower = Integer.parseInt(bounds[0].trim());\n            int upper = Integer.parseInt(bounds[1].substring(0, bounds[1].length()-1).trim());\n            Main main = new Main();\n            List<String> result = main.findMissingRanges(nums, lower, upper);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def findMissingRanges(self, nums: List[int], lower: int, upper: int) -> List[str]:\n        \"\"\"\n        Finds missing ranges in a sorted array.\n        :param nums: Sorted list of integers\n        :param lower: Lower bound\n        :param upper: Upper bound\n        :return: List of missing ranges\n        \"\"\"\n        # Write your code here\n        return []\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    import json\n    try:\n        nums, lower, upper = json.loads(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.findMissingRanges(nums, lower, upper)\n        print(json.dumps(result))\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds missing ranges in a sorted array.\n * @param {number[]} nums - Sorted array of integers\n * @param {number} lower - Lower bound\n * @param {number} upper - Upper bound\n * @return {string[]} - List of missing ranges\n */\nfunction findMissingRanges(nums, lower, upper) {\n    // Write your code here\n    return [];\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const [nums, lower, upper] = JSON.parse(line.trim());\n        const result = findMissingRanges(nums, lower, upper);\n        console.log(JSON.stringify(result));\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc findMissingRanges(nums []int, lower, upper int) []string {\n    result := []string{}\n    prev := int64(lower) - 1\n    for i := 0; i <= len(nums); i++ {\n        curr := int64(upper) + 1\n        if i < len(nums) {\n            curr = int64(nums[i])\n        }\n        if curr-prev > 1 {\n            if curr-prev == 2 {\n                result = append(result, strconv.FormatInt(prev+1, 10))\n            } else {\n                result = append(result, strconv.FormatInt(prev+1, 10)+\"->\"+strconv.FormatInt(curr-1, 10))\n            }\n        }\n        prev = curr\n    }\n    return result\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    input = input[1 : len(input)-1]\n    parts := strings.Split(input, \"],\")\n    numsStr := strings.TrimSpace(parts[0][1:])\n    nums := []int{}\n    if numsStr != \"\" {\n        strNums := strings.Split(numsStr, \",\")\n        for _, s := range strNums {\n            num, err := strconv.Atoi(strings.TrimSpace(s))\n            if err != nil {\n                fmt.Println(\"Invalid input format\")\n                return\n            }\n            nums = append(nums, num)\n        }\n    }\n    bounds := strings.Split(parts[1], \",\")\n    lower, _ := strconv.Atoi(strings.TrimSpace(bounds[0]))\n    upper, _ := strconv.Atoi(strings.TrimSpace(bounds[1][:len(bounds[1])-1]))\n    result := findMissingRanges(nums, lower, upper)\n    fmt.Print(\"[\")\n    for i, s := range result {\n        fmt.Print(\"\\\"\" + s + \"\\\"\")\n        if i < len(result)-1 {\n            fmt.Print(\",\")\n        }\n    }\n    fmt.Println(\"]\")\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> findMissingRanges(vector<int>& nums, int lower, int upper) {\n        vector<string> result;\n        long long prev = (long long)lower - 1;\n        for (int i = 0; i <= nums.size(); i++) {\n            long long curr = i < nums.size() ? nums[i] : (long long)upper + 1;\n            if (curr - prev > 1) {\n                if (curr - prev == 2) result.push_back(to_string(prev + 1));\n                else result.push_back(to_string(prev + 1) + \"->\" + to_string(curr - 1));\n            }\n            prev = curr;\n        }\n        return result;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        size_t pos = line.find(\"],\");\n        string numsStr = line.substr(1, pos-1);\n        size_t pos2 = 0;\n        while ((pos2 = numsStr.find(\",\")) != string::npos) {\n            nums.push_back(stoi(numsStr.substr(0, pos2)));\n            numsStr.erase(0, pos2 + 1);\n        }\n        if (!numsStr.empty()) nums.push_back(stoi(numsStr));\n        string bounds = line.substr(pos+2);\n        pos = bounds.find(\",\");\n        int lower = stoi(bounds.substr(0, pos));\n        int upper = stoi(bounds.substr(pos+1));\n        Solution sol;\n        vector<string> result = sol.findMissingRanges(nums, lower, upper);\n        cout << \"[\";\n        for (size_t i = 0; i < result.size(); i++) {\n            cout << \"\\\"\" << result[i] << \"\\\"\";\n            if (i < result.size()-1) cout << \",\";\n        }\n        cout << \"]\" << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.*;\n\npublic class Main {\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\n        List<String> result = new ArrayList<>();\n        long prev = (long)lower - 1;\n        for (int i = 0; i <= nums.length; i++) {\n            long curr = i < nums.length ? nums[i] : (long)upper + 1;\n            if (curr - prev > 1) {\n                if (curr - prev == 2) result.add(String.valueOf(prev + 1));\n                else result.add((prev + 1) + \"->\" + (curr - 1));\n            }\n            prev = curr;\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            String[] parts = line.substring(1, line.length()-1).split(\"\\],\");\n            String[] strNums = parts[0].substring(1).split(\",\");\n            int[] nums = new int[strNums.length];\n            for (int i = 0; i < strNums.length; i++) {\n                nums[i] = Integer.parseInt(strNums[i].trim());\n            }\n            String[] bounds = parts[1].split(\",\");\n            int lower = Integer.parseInt(bounds[0].trim());\n            int upper = Integer.parseInt(bounds[1].substring(0, bounds[1].length()-1).trim());\n            Main main = new Main();\n            List<String> result = main.findMissingRanges(nums, lower, upper);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def findMissingRanges(self, nums: List[int], lower: int, upper: int) -> List[str]:\n        result = []\n        prev = lower - 1\n        for i in range(len(nums) + 1):\n            curr = nums[i] if i < len(nums) else upper + 1\n            if curr - prev > 1:\n                if curr - prev == 2:\n                    result.append(str(prev + 1))\n                else:\n                    result.append(f\"{prev + 1}->{curr - 1}\")\n            prev = curr\n        return result\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    import json\n    try:\n        nums, lower, upper = json.loads(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.findMissingRanges(nums, lower, upper)\n        print(json.dumps(result))\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds missing ranges in a sorted array.\n * @param {number[]} nums - Sorted array of integers\n * @param {number} lower - Lower bound\n * @param {number} upper - Upper bound\n * @return {string[]} - List of missing ranges\n */\nfunction findMissingRanges(nums, lower, upper) {\n    const result = [];\n    let prev = lower - 1;\n    for (let i = 0; i <= nums.length; i++) {\n        let curr = i < nums.length ? nums[i] : upper + 1;\n        if (curr - prev > 1) {\n            if (curr - prev == 2) result.push(String(prev + 1));\n            else result.push(`${prev + 1}->${curr - 1}`);\n        }\n        prev = curr;\n    }\n    return result;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const [nums, lower, upper] = JSON.parse(line.trim());\n        const result = findMissingRanges(nums, lower, upper);\n        console.log(JSON.stringify(result));\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    }
  },
  {
    "title": "Find Peak Element",
    "description": "A peak element is an element that is greater than its neighbors. Given an input array **nums**, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks; in that case, return the index of any one of the peaks. You may imagine that nums[-1] = nums[n] = -∞.\n\n### Problem Statement\n\nReturn the index of a peak element in the array, where a peak element is strictly greater than its neighbors.\n\n### Input\n\n- **nums**: An array of integers (1 <= nums.length <= 1000, -2^31 <= nums[i] <= 2^31 - 1, nums[i] ≠ nums[i+1] for all valid i).\n\n### Output\n\n- An integer representing the index of a peak element.\n\n### Example\n\n**Input**: nums = [1,2,3,1]  \n**Output**: 2  \n**Explanation**: 3 is a peak element at index 2, as it is greater than its neighbors (2 and 1).\n\n**Input**: nums = [1,2,1,3,5,6,4]  \n**Output**: 1 or 5  \n**Explanation**: 2 at index 1 is a peak (greater than 1 and 1), and 6 at index 5 is a peak (greater than 5 and 4). Either is valid.\n\n### Notes\n\n- The solution should have O(log n) time complexity.\n- The array guarantees no two adjacent elements are equal.\n- Assume nums[-1] = nums[n] = -∞ for boundary conditions.\n\n### Real-World Context\n\nThis problem is relevant in scenarios like finding local maxima in datasets, such as signal processing or stock price analysis, common in algorithmic tasks at companies like Google.",
    "difficulty": "MEDIUM",
    "tags": [
      "Array",
      "Binary Search",
      "Google",
      "Cisco"
    ],
    "constraints": [
      "1 <= nums.length <= 1000",
      "-2^31 <= nums[i] <= 2^31 - 1",
      "nums[i] ≠ nums[i+1] for all valid i",
      "Time complexity should be O(log n)",
      "Space complexity should be O(1)"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 1]",
        "output": "2",
        "explanation": "3 is a peak element at index 2, as it is greater than its neighbors (2 and 1)."
      }
    ],
    "testcases": [
      {
        "input": "[1,2,3,1]",
        "output": "2",
        "isHidden": false
      },
      {
        "input": "[1,2,1,3,5,6,4]",
        "output": "5",
        "isHidden": false
      },
      {
        "input": "[1]",
        "output": "0",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Use binary search to find a peak by comparing the middle element with its neighbors.",
      "2. If the middle element is not a peak, move towards the side with a larger neighbor.",
      "3. Since nums[-1] = nums[n] = -∞, a peak is guaranteed to exist."
    ],
    "editorial": "## Editorial: Find Peak Element\n\n### Problem Recap\n\nFind the index of a peak element in an array, where a peak is strictly greater than its neighbors, with O(log n) time complexity.\n\n### Intuition\n\nSince the array has no adjacent equal elements and boundaries are -∞, a peak is guaranteed. Binary search can exploit this by checking the middle element and moving towards the side with a larger neighbor, as a peak must exist in that direction.\n\n### Approach\n\n#### Binary Search\n\n- **Idea**: Use binary search to find a peak by comparing the middle element with its neighbors.\n- **Steps**:\n  1. Initialize left = 0, right = nums.length - 1.\n  2. While left <= right:\n     - Compute mid = left + (right - left) / 2.\n     - If mid is a peak (greater than both neighbors), return mid.\n     - If nums[mid] < nums[mid+1], a peak exists on the right, so set left = mid + 1.\n     - Else, a peak exists on the left, so set right = mid - 1.\n  3. Return left (or any peak index).\n- **Time Complexity**: O(log n) for binary search.\n- **Space Complexity**: O(1) for constant space.\n\n### Recommended Solution\n\nBinary search is optimal due to the O(log n) requirement.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(log n) for halving the search space.\n- **Space Complexity**: O(1) for pointers.\n- **Constraints Handling**:\n  - Array length: 1 <= n <= 1000.\n  - Values: -2^31 <= nums[i] <= 2^31 - 1.\n\n### Edge Cases\n\n- **Single element**: nums = [1] → 0 (single element is a peak).\n- **Two elements**: nums = [1,2] → 1 (2 is a peak).\n- **Multiple peaks**: nums = [1,2,1,3,5,6,4] → 1 or 5.\n\n### Implementation Notes\n\n- Handle boundaries carefully (check if mid is at 0 or n-1).\n- Use integer division to avoid overflow in mid calculation.\n- The solution leverages the guarantee of no equal adjacent elements.\n\n### Visual Explanation\n\nFor nums = [1,2,3,1]:\n- left=0, right=3, mid=1: nums[1]=2 < nums[2]=3, so left=2.\n- left=2, right=3, mid=2: nums[2]=3 > nums[1]=2 and nums[2]=3 > nums[3]=1, return 2.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc findPeakElement(nums []int) int {\n    if len(nums) == 1 {\n        return 0\n    }\n    left, right := 0, len(nums)-1\n    for left < right {\n        mid := left + (right-left)/2\n        if nums[mid] > nums[mid+1] {\n            right = mid\n        } else {\n            left = mid + 1\n        }\n    }\n    return left\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Print(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    nums := make([]int, 0)\n    if input == \"[]\" {\n        // Handle empty array\n        fmt.Print(\"-1\")\n        return\n    } else {\n        input = input[1 : len(input)-1]\n        strNums := strings.Split(input, \",\")\n        nums = make([]int, len(strNums))\n        for i, s := range strNums {\n            num, err := strconv.Atoi(strings.TrimSpace(s))\n            if err != nil {\n                fmt.Print(\"Invalid input format\")\n                return\n            }\n            nums[i] = num\n        }\n    }\n    result := findPeakElement(nums)\n    fmt.Print(result) // Output without newline\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n        // Write your code here\n        return 0;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\";\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        if (line == \"\") {\n            cout << \"-1\";\n            return 0;\n        } else {\n            size_t pos = 0;\n            while ((pos = line.find(\",\")) != string::npos) {\n                nums.push_back(stoi(line.substr(0, pos)));\n                line.erase(0, pos + 1);\n            }\n            if (!line.empty()) nums.push_back(stoi(line));\n        }\n        Solution sol;\n        int result = sol.findPeakElement(nums);\n        cout << result; // Output without newline\n    } catch (...) {\n        cout << \"Invalid input format\";\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Finds the index of a peak element.\n     * @param nums Array of integers\n     * @return Index of a peak element\n     */\n    public int findPeakElement(int[] nums) {\n        // Write your code here\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            int[] nums;\n            if (line.equals(\"[]\")) {\n                System.out.print(\"-1\");\n                return;\n            } else {\n                String[] strNums = line.substring(1, line.length()-1).split(\",\");\n                nums = new int[strNums.length];\n                for (int i = 0; i < strNums.length; i++) {\n                    nums[i] = Integer.parseInt(strNums[i].trim());\n                }\n            }\n            Main main = new Main();\n            int result = main.findPeakElement(nums);\n            System.out.print(result); // Output without newline\n        } catch (Exception e) {\n            System.out.print(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import sys\nimport json\n\nclass Solution:\n    def findPeakElement(self, nums):\n        \"\"\"\n        Finds the index of a peak element.\n        :param nums: List of integers\n        :return: Index of a peak element\n        \"\"\"\n        # Write your code here\n        return 0\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        if len(nums) == 0:\n            sys.stdout.write(\"-1\")\n            sys.exit(0)\n        sol = Solution()\n        result = sol.findPeakElement(nums)\n        sys.stdout.write(str(result))  # Output without newline\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds the index of a peak element.\n * @param {number[]} nums - Array of integers\n * @return {number} - Index of a peak element\n */\nfunction findPeakElement(nums) {\n    // Write your code here\n    return 0;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        line = line.trim();\n        let nums = [];\n        if (line === \"[]\") {\n            nums = []; // Handle empty array\n        } else {\n            nums = JSON.parse(line);\n        }\n        if (nums.length === 0) {\n            process.stdout.write(\"-1\");\n            rl.close();\n            return;\n        }\n        const result = findPeakElement(nums);\n        process.stdout.write(result.toString()); // Output without newline\n        rl.close();\n    } catch (e) {\n        process.stdout.write(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc findPeakElement(nums []int) int {\n    left, right := 0, len(nums)-1\n    for left < right {\n        mid := left + (right-left)/2\n        if nums[mid] > nums[mid+1] {\n            right = mid\n        } else {\n            left = mid + 1\n        }\n    }\n    return left\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    input = input[1 : len(input)-1]\n    strNums := strings.Split(input, \",\")\n    nums := make([]int, 0)\n    for _, s := range strNums {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        nums = append(nums, num)\n    }\n    result := findPeakElement(nums)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n        if (nums.size() == 1) return 0;\n        int left = 0, right = nums.size() - 1;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] > nums[mid + 1]) right = mid;\n            else left = mid + 1;\n        }\n        return left;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\";\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        if (line == \"\") {\n            cout << \"-1\"; // Handle empty array\n            return 0;\n        } else {\n            size_t pos = 0;\n            while ((pos = line.find(\",\")) != string::npos) {\n                nums.push_back(stoi(line.substr(0, pos)));\n                line.erase(0, pos + 1);\n            }\n            if (!line.empty()) nums.push_back(stoi(line));\n        }\n        Solution sol;\n        int result = sol.findPeakElement(nums);\n        cout << result; // Output without newline\n    } catch (...) {\n        cout << \"Invalid input format\";\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public int findPeakElement(int[] nums) {\n        if (nums.length == 1) return 0;\n        int left = 0, right = nums.length - 1;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] > nums[mid + 1]) right = mid;\n            else left = mid + 1;\n        }\n        return left;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            int[] nums;\n            if (line.equals(\"[]\")) {\n                System.out.print(\"-1\"); // Handle empty array\n                return;\n            } else {\n                String[] strNums = line.substring(1, line.length()-1).split(\",\");\n                nums = new int[strNums.length];\n                for (int i = 0; i < strNums.length; i++) {\n                    nums[i] = Integer.parseInt(strNums[i].trim());\n                }\n            }\n            Main main = new Main();\n            int result = main.findPeakElement(nums);\n            System.out.print(result); // Output without newline\n        } catch (Exception e) {\n            System.out.print(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import sys\nimport json\n\nclass Solution:\n    def findPeakElement(self, nums):\n        if len(nums) == 1:\n            return 0\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        if len(nums) == 0:\n            sys.stdout.write(\"-1\")\n            sys.exit(0)\n        sol = Solution()\n        result = sol.findPeakElement(nums)\n        sys.stdout.write(str(result))  # Output without newline\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds the index of a peak element.\n * @param {number[]} nums - Array of integers\n * @return {number} - Index of a peak element\n */\nfunction findPeakElement(nums) {\n    if (nums.length === 1) return 0;\n    if (nums.length === 2) return nums[0] > nums[1] ? 0 : 1;\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        let mid = left + Math.floor((right - left) / 2);\n        // Check if mid is a peak\n        let leftVal = mid > 0 ? nums[mid - 1] : Number.NEGATIVE_INFINITY;\n        let rightVal = mid < nums.length - 1 ? nums[mid + 1] : Number.NEGATIVE_INFINITY;\n        if (nums[mid] > leftVal && nums[mid] > rightVal) return mid;\n        // Move to the side with a larger neighbor\n        if (rightVal > nums[mid]) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        line = line.trim();\n        let nums = [];\n        if (line === \"[]\") {\n            nums = []; // Handle empty array\n        } else {\n            nums = JSON.parse(line);\n        }\n        if (nums.length === 0) {\n            process.stdout.write(\"-1\");\n            rl.close();\n            return;\n        }\n        const result = findPeakElement(nums);\n        process.stdout.write(result.toString()); // Output without newline\n        rl.close();\n    } catch (e) {\n        process.stdout.write(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    }
  },
  {
    "title": "Isomorphic Strings",
    "description": "Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.\n\n### Problem Statement\n\nYou are given two strings **s** and **t** of equal length. Check if there exists a one-to-one mapping of characters from s to t.\n\n### Input\n\n- **s**: A string of lowercase letters (1 <= s.length <= 10^5).\n- **t**: A string of lowercase letters (s.length == t.length).\n\n### Output\n\n- A boolean: true if s and t are isomorphic, false otherwise.\n\n### Example\n\n**Input**: s = 'egg', t = 'add'  \n**Output**: true  \n**Explanation**: Map 'e' to 'a' and 'g' to 'd'. The pattern is preserved.\n\n**Input**: s = 'foo', t = 'bar'  \n**Output**: false  \n**Explanation**: 'f' maps to 'b', but 'o' cannot map to both 'a' and 'r'.\n\n**Input**: s = 'paper', t = 'title'  \n**Output**: true  \n**Explanation**: Map 'p' to 't', 'a' to 'i', 'e' to 'l', 'r' to 'e'.\n\n### Notes\n\n- Use a hash map to track character mappings.\n- Ensure no two characters in s map to the same character in t.\n\n### Real-World Context\n\nThis problem is relevant in pattern matching, data transformation, or encoding schemes where consistent substitution is needed.",
    "difficulty": "EASY",
    "tags": [
      "String",
      "Hash Map",
      "Google",
      "Uber",
      "Paypal"
    ],
    "constraints": [
      "1 <= s.length, t.length <= 10^5",
      "s.length == t.length",
      "s and t consist of lowercase letters",
      "Time complexity should be O(n), where n is string length",
      "Space complexity should be O(1) since character set is limited"
    ],
    "examples": [
      {
        "input": "s = \"egg\", t = \"add\"",
        "output": "true",
        "explanation": "Map 'e' to 'a' and 'g' to 'd'. The pattern is preserved."
      }
    ],
    "testcases": [
      {
        "input": "egg\nadd",
        "output": "true",
        "isHidden": false
      },
      {
        "input": "foo\nbar",
        "output": "false",
        "isHidden": false
      },
      {
        "input": "ab\naa",
        "output": "false",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Use a hash map to store mappings from s to t.",
      "2. Check that each character in s maps to exactly one character in t.",
      "3. Use a second map or set to ensure no two characters in s map to the same character in t."
    ],
    "editorial": "## Editorial: Isomorphic Strings\n\n### Problem Recap\n\nDetermine if two strings s and t are isomorphic by checking if characters in s can be mapped to t while preserving order and ensuring a one-to-one mapping.\n\n### Intuition\n\nThis is a mapping problem. Use a hash map to track each character in s to its corresponding character in t. Additionally, ensure no two characters in s map to the same character in t using a set or second map.\n\n### Approaches\n\n#### 1. Hash Map with Set\n\n- **Idea**: Map each character in s to t and use a set to track used characters in t.\n- **Steps**:\n  1. Create a hash map for s to t mappings and a set for used t characters.\n  2. Iterate through s and t simultaneously.\n  3. If s[i] is unmapped, map it to t[i] if t[i] is unused; else return false.\n  4. If s[i] is mapped, check if it maps to t[i]; else return false.\n- **Time Complexity**: O(n), where n is string length.\n- **Space Complexity**: O(1) since character set is limited (26 lowercase letters).\n- **Pros**: Simple, efficient.\n\n### Recommended Solution\n\nHash Map with Set is recommended for clarity and efficiency.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for one pass through strings.\n- **Space Complexity**: O(1) for fixed-size maps (26 letters).\n- **Constraints Handling**:\n  - String length: 1 <= n <= 10^5.\n  - Characters: lowercase letters.\n\n### Edge Cases\n\n- **Single character**: s = 'a', t = 'b' → true.\n- **Same characters**: s = 'aa', t = 'bb' → true.\n- **Invalid mapping**: s = 'ab', t = 'aa' → false.\n\n### Implementation Notes\n\n- Use arrays instead of hash maps for O(1) space since characters are lowercase.\n- Validate equal lengths implicitly by constraint.\n\n### Visual Explanation\n\nFor s = 'egg', t = 'add':\n- Map 'e'→'a', 'g'→'d'.\n- All mappings consistent, return true.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"bufio\"\n    \"os\"\n)\n\nfunc isIsomorphic(s, t string) bool {\n    // Write your code here\n    return false\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    var s, t string\n    if scanner.Scan() {\n        s = scanner.Text()\n    }\n    if scanner.Scan() {\n        t = scanner.Text()\n    }\n    if s == \"\" || t == \"\" {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := isIsomorphic(s, t)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        // Write your code here\n        return false;\n    }\n};\n\nint main() {\n    try {\n        string s, t;\n        if (!getline(cin, s) || !getline(cin, t)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        Solution sol;\n        bool result = sol.isIsomorphic(s, t);\n        cout << (result ? \"true\" : \"false\") << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Checks if two strings are isomorphic.\n     * @param s First string\n     * @param t Second string\n     * @return True if isomorphic, false otherwise\n     */\n    public boolean isIsomorphic(String s, String t) {\n        // Write your code here\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String s = scanner.nextLine().trim();\n            String t = scanner.nextLine().trim();\n            Main main = new Main();\n            boolean result = main.isIsomorphic(s, t);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import sys\n\nclass Solution:\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        Checks if two strings are isomorphic.\n        :param s: First string\n        :param t: Second string\n        :return: True if isomorphic, false otherwise\n        \"\"\"\n        # Write your code here\n        return False\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        s = sys.stdin.readline().strip()\n        t = sys.stdin.readline().strip()\n        if not s or not t or len(s) != len(t):\n            raise ValueError(\"Invalid input format\")\n        sol = Solution()\n        result = sol.isIsomorphic(s, t)\n        print str(result).lower()  # Output true/false\n    except Exception:\n        print \"Invalid input format\"\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Checks if two strings are isomorphic.\n * @param {string} s - First string\n * @param {string} t - Second string\n * @return {boolean} - True if isomorphic, false otherwise\n */\nfunction isIsomorphic(s, t) {\n    // Write your code here\n    return false;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nlet lines = [];\nrl.on(\"line\", (line) => {\n    lines.push(line.trim());\n    if (lines.length === 2) {\n        try {\n            const result = isIsomorphic(lines[0], lines[1]);\n            console.log(result);\n            rl.close();\n        } catch (e) {\n            console.log(\"Invalid input format\");\n            process.exit(1);\n        }\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"bufio\"\n    \"os\"\n)\n\nfunc isIsomorphic(s, t string) bool {\n    mapS := make([]int, 128)\n    usedT := make([]int, 128)\n    for i := 0; i < len(s); i++ {\n        if mapS[s[i]] == 0 {\n            if usedT[t[i]] != 0 {\n                return false\n            }\n            mapS[s[i]] = int(t[i])\n            usedT[t[i]] = 1\n        } else if mapS[s[i]] != int(t[i]) {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    var s, t string\n    if scanner.Scan() {\n        s = scanner.Text()\n    }\n    if scanner.Scan() {\n        t = scanner.Text()\n    }\n    if s == \"\" || t == \"\" {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := isIsomorphic(s, t)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        int map[128] = {0};\n        int used[128] = {0};\n        for (size_t i = 0; i < s.length(); i++) {\n            if (map[s[i]] == 0) {\n                if (used[t[i]] != 0) return false;\n                map[s[i]] = t[i];\n                used[t[i]] = 1;\n            } else if (map[s[i]] != t[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    try {\n        string s, t;\n        if (!getline(cin, s) || !getline(cin, t)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        Solution sol;\n        bool result = sol.isIsomorphic(s, t);\n        cout << (result ? \"true\" : \"false\") << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public boolean isIsomorphic(String s, String t) {\n        int[] map = new int[128];\n        int[] used = new int[128];\n        for (int i = 0; i < s.length(); i++) {\n            if (map[s.charAt(i)] == 0) {\n                if (used[t.charAt(i)] != 0) return false;\n                map[s.charAt(i)] = t.charAt(i);\n                used[t.charAt(i)] = 1;\n            } else if (map[s.charAt(i)] != t.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String s = scanner.nextLine().trim();\n            String t = scanner.nextLine().trim();\n            Main main = new Main();\n            boolean result = main.isIsomorphic(s, t);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import sys\n\nclass Solution:\n    def isIsomorphic(self, s, t):\n        if len(s) != len(t):\n            return False\n        map_s = [0] * 128\n        used_t = [0] * 128\n        for c1, c2 in zip(s, t):\n            if map_s[ord(c1)] == 0:\n                if used_t[ord(c2)] != 0:\n                    return False\n                map_s[ord(c1)] = ord(c2)\n                used_t[ord(c2)] = 1\n            elif map_s[ord(c1)] != ord(c2):\n                return False\n        return True\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        s = sys.stdin.readline().strip()\n        t = sys.stdin.readline().strip()\n        if not s or not t or len(s) != len(t):\n            raise ValueError(\"Invalid input format\")\n        sol = Solution()\n        result = sol.isIsomorphic(s, t)\n        print str(result).lower()  # Output true/false\n    except Exception:\n        print \"Invalid input format\"\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Checks if two strings are isomorphic.\n * @param {string} s - First string\n * @param {string} t - Second string\n * @return {boolean} - True if isomorphic, false otherwise\n */\nfunction isIsomorphic(s, t) {\n    const map = new Array(128).fill(0);\n    const used = new Array(128).fill(0);\n    for (let i = 0; i < s.length; i++) {\n        if (map[s.charCodeAt(i)] === 0) {\n            if (used[t.charCodeAt(i)] !== 0) return false;\n            map[s.charCodeAt(i)] = t.charCodeAt(i);\n            used[t.charCodeAt(i)] = 1;\n        } else if (map[s.charCodeAt(i)] !== t.charCodeAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nlet lines = [];\nrl.on(\"line\", (line) => {\n    lines.push(line.trim());\n    if (lines.length === 2) {\n        try {\n            const result = isIsomorphic(lines[0], lines[1]);\n            console.log(result);\n            rl.close();\n        } catch (e) {\n            console.log(\"Invalid input format\");\n            process.exit(1);\n        }\n    }\n});"
    }
  },
  {
    "title": "Dungeon Game",
    "description": "The demons have captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Write a function to determine the knight's minimum initial health so that he is able to rescue the princess.\n\n### Problem Statement\n\nReturn the minimum initial health required for the knight to reach the princess.\n\n### Input\n\n- **dungeon**: A 2D array of integers (1 <= m, n <= 200, -1000 <= dungeon[i][j] <= 1000).\n\n### Output\n\n- An integer representing the minimum initial health.\n\n### Example\n\n**Input**: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]  \n**Output**: 7  \n**Explanation**: The optimal path is RIGHT -> RIGHT -> DOWN -> DOWN with initial health 7 (path: [-2,-3,1,-5]).\n\n**Input**: dungeon = [[0]]  \n**Output**: 1  \n**Explanation**: Single room with no health change requires 1 health.\n\n### Notes\n\n- The knight’s health has no upper bound.\n- Use dynamic programming to compute the minimum health needed backward from the princess.\n- Ensure health doesn’t drop to 0 at any point.\n\n### Real-World Context\n\nThis problem is relevant in path optimization scenarios, such as game design or resource allocation, common at companies like Uber.",
    "difficulty": "HARD",
    "tags": [
      "Dynamic Programming",
      "2D Array",
      "Grid",
      "Uber",
      "Google",
      "Facebook",
      "Amazon",
      "Microsoft"
    ],
    "constraints": [
      "1 <= m, n <= 200",
      "-1000 <= dungeon[i][j] <= 1000",
      "Time complexity should be O(m*n)",
      "Space complexity should be O(m*n) or O(n) for optimized"
    ],
    "examples": [
      {
        "input": "dungeon = [[-2, -3, 3], [-5, -10, 1], [10, 30, -5]]",
        "output": "7",
        "explanation": "The optimal path requires initial health of 7."
      }
    ],
    "testcases": [
      {
        "input": "[[-2,-3,3],[-5,-10,1],[10,30,-5]]",
        "output": "7",
        "isHidden": false
      },
      {
        "input": "[[0]]",
        "output": "1",
        "isHidden": false
      },
      {
        "input": "[[-5]]",
        "output": "6",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Use dynamic programming to calculate the minimum health needed to reach each cell.",
      "2. Work backward from the princess to ensure the knight survives with at least 1 health.",
      "3. At each cell, compute the minimum health needed based on the health change and next cells."
    ],
    "editorial": "## Editorial: Dungeon Game\n\n### Problem Recap\n\nDetermine the minimum initial health for a knight to reach the princess in a dungeon, moving only right or down.\n\n### Intuition\n\nSince the knight must maintain at least 1 health at all times, work backward from the princess to compute the minimum health needed at each cell, considering health changes and the minimum health needed for the next possible moves.\n\n### Approach\n\n#### Dynamic Programming (Bottom-Up)\n\n- **Idea**: Use a DP table where dp[i][j] is the minimum health needed before entering cell (i,j).\n- **Steps**:\n  1. Initialize dp[m][n] based on dungeon[m-1][n-1] (princess cell).\n  2. Fill the last row and column, computing health needed for each cell.\n  3. For other cells from bottom-right to top-left, compute dp[i][j] as:\n     - min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], ensuring health ≥ 1.\n  4. Return dp[0][0].\n- **Time Complexity**: O(m*n) for filling DP table.\n- **Space Complexity**: O(m*n) for DP table, or O(n) with optimization.\n\n### Recommended Solution\n\nUse a single row or column for DP to reduce space to O(n).\n\n### Complexity Analysis\n\n- **Time Complexity**: O(m*n) for iterating through the grid.\n- **Space Complexity**: O(m*n), or O(n) for optimized.\n- **Constraints Handling**:\n  - Grid size: 1 <= m, n <= 200.\n  - Values: -1000 <= dungeon[i][j] <= 1000.\n\n### Edge Cases\n\n- **Single cell**: dungeon = [[-5]] → 6.\n- **Single row/column**: dungeon = [[-2,-3,-5]] → 11.\n- **All negative**: dungeon = [[-2,-3],[-5,-10]] → 16.\n- **All positive**: dungeon = [[1,2,3]] → 1.\n\n### Implementation Notes\n\n- Handle negative health changes by ensuring health ≥ 1.\n- Use long for intermediate calculations to avoid overflow.\n- Optimize space by using a 1D DP array.\n\n### Visual Explanation\n\nFor dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]:\n- dp[2][2] = max(1, 1 - (-5)) = 1.\n- dp[2][1] = max(1, 1 - 30) = 1.\n- dp[2][0] = max(1, 1 - 10) = 1.\n- dp[1][2] = max(1, 1 - 1) = 1.\n- dp[1][1] = max(1, 1 - (-10)) = 1.\n- dp[1][0] = max(1, 1 - (-5)) = 1.\n- dp[0][2] = max(1, 1 - 3) = 1.\n- dp[0][1] = max(1, 1 - (-3)) = 1.\n- dp[0][0] = max(1, 1 - (-2)) = 7.\n- Return 7.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc calculateMinimumHP(dungeon [][]int) int {\n    // Write your code here\n    return 1\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    input = input[2 : len(input)-2]\n    rows := strings.Split(input, \"],[\")\n    dungeon := make([][]int, len(rows))\n    for i, rowStr := range rows {\n        nums := strings.Split(rowStr, \",\")\n        dungeon[i] = make([]int, len(nums))\n        for j, s := range nums {\n            num, err := strconv.Atoi(strings.TrimSpace(s))\n            if err != nil {\n                fmt.Println(\"Invalid input format\")\n                return\n            }\n            dungeon[i][j] = num\n        }\n    }\n    result := calculateMinimumHP(dungeon)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\n        // Write your code here\n        return 1;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        line = line.substr(2, line.length()-4);\n        vector<vector<int>> dungeon;\n        size_t pos = line.find(\"],[\");\n        while (pos != string::npos) {\n            string rowStr = line.substr(0, pos);\n            vector<int> row;\n            size_t pos2 = 0;\n            while ((pos2 = rowStr.find(\",\")) != string::npos) {\n                row.push_back(stoi(rowStr.substr(0, pos2)));\n                rowStr.erase(0, pos2 + 1);\n            }\n            if (!rowStr.empty()) row.push_back(stoi(rowStr));\n            dungeon.push_back(row);\n            line.erase(0, pos + 3);\n            pos = line.find(\"],[\");\n        }\n        vector<int> row;\n        size_t pos2 = 0;\n        while ((pos2 = line.find(\",\")) != string::npos) {\n            row.push_back(stoi(line.substr(0, pos2)));\n            line.erase(0, pos2 + 1);\n        }\n        if (!line.empty()) row.push_back(stoi(line));\n        dungeon.push_back(row);\n        Solution sol;\n        int result = sol.calculateMinimumHP(dungeon);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Calculates minimum initial health for the dungeon game.\n     * @param dungeon 2D array of integers\n     * @return Minimum initial health\n     */\n    public int calculateMinimumHP(int[][] dungeon) {\n        // Write your code here\n        return 1;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            // Fix: Properly escape square brackets in regex\n            String[] rows = line.substring(2, line.length()-2).split(\"\\\\],\\\\[\");\n            int m = rows.length;\n            int[][] dungeon = new int[m][];\n            for (int i = 0; i < m; i++) {\n                String[] nums = rows[i].split(\",\");\n                dungeon[i] = new int[nums.length];\n                for (int j = 0; j < nums.length; j++) {\n                    dungeon[i][j] = Integer.parseInt(nums[j].trim());\n                }\n            }\n            Main main = new Main();\n            int result = main.calculateMinimumHP(dungeon);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        Calculates minimum initial health for the dungeon game.\n        :param dungeon: 2D grid of integers\n        :return: Minimum initial health\n        \"\"\"\n        # Write your code here\n        return 1\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    import json\n    try:\n        dungeon = json.loads(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.calculateMinimumHP(dungeon)\n        print result  \n    except Exception as e:\n        print \"Invalid input format\"\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Calculates minimum initial health for the dungeon game.\n * @param {number[][]} dungeon - 2D grid of integers\n * @return {number} - Minimum initial health\n */\nfunction calculateMinimumHP(dungeon) {\n    // Write your code here\n    return 1;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const dungeon = JSON.parse(line.trim());\n        const result = calculateMinimumHP(dungeon);\n        console.log(result);\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n    \"math\"\n)\n\nfunc calculateMinimumHP(dungeon [][]int) int {\n    m, n := len(dungeon), len(dungeon[0])\n    dp := make([][]int, m+1)\n    for i := range dp {\n        dp[i] = make([]int, n+1)\n        for j := range dp[i] {\n            dp[i][j] = math.MaxInt32 / 2\n        }\n    }\n    dp[m][n-1], dp[m-1][n] = 1, 1\n    for i := m-1; i >= 0; i-- {\n        for j := n-1; j >= 0; j-- {\n            dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1])-dungeon[i][j])\n        }\n    }\n    return dp[0][0]\n}\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    input = input[2 : len(input)-2]\n    rows := strings.Split(input, \"],[\")\n    dungeon := make([][]int, len(rows))\n    for i, rowStr := range rows {\n        nums := strings.Split(rowStr, \",\")\n        dungeon[i] = make([]int, len(nums))\n        for j, s := range nums {\n            num, err := strconv.Atoi(strings.TrimSpace(s))\n            if err != nil {\n                fmt.Println(\"Invalid input format\")\n                return\n            }\n            dungeon[i][j] = num\n        }\n    }\n    result := calculateMinimumHP(dungeon)\n    fmt.Println(result)\n}\n",
      "C++": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nclass Solution {\npublic:\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\n        int m = dungeon.size(), n = dungeon[0].size();\n        vector<vector<int>> dp(m+1, vector<int>(n+1, INT_MAX / 2));\n        dp[m][n-1] = dp[m-1][n] = 1;\n        for (int i = m-1; i >= 0; i--) {\n            for (int j = n-1; j >= 0; j--) {\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);\n            }\n        }\n        return dp[0][0];\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        line = line.substr(2, line.length()-4);\n        vector<vector<int>> dungeon;\n        size_t pos = line.find(\"],[\");\n        while (pos != string::npos) {\n            string rowStr = line.substr(0, pos);\n            vector<int> row;\n            size_t pos2 = 0;\n            while ((pos2 = rowStr.find(\",\")) != string::npos) {\n                row.push_back(stoi(rowStr.substr(0, pos2)));\n                rowStr.erase(0, pos2 + 1);\n            }\n            if (!rowStr.empty()) row.push_back(stoi(rowStr));\n            dungeon.push_back(row);\n            line.erase(0, pos + 3);\n            pos = line.find(\"],[\");\n        }\n        vector<int> row;\n        size_t pos2 = 0;\n        while ((pos2 = line.find(\",\")) != string::npos) {\n            row.push_back(stoi(line.substr(0, pos2)));\n            line.erase(0, pos2 + 1);\n        }\n        if (!line.empty()) row.push_back(stoi(line));\n        dungeon.push_back(row);\n        Solution sol;\n        int result = sol.calculateMinimumHP(dungeon);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public int calculateMinimumHP(int[][] dungeon) {\n        int m = dungeon.length, n = dungeon[0].length;\n        int[][] dp = new int[m+1][n+1];\n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= n; j++) {\n                dp[i][j] = Integer.MAX_VALUE / 2;\n            }\n        }\n        dp[m][n-1] = dp[m-1][n] = 1;\n        for (int i = m-1; i >= 0; i--) {\n            for (int j = n-1; j >= 0; j--) {\n                dp[i][j] = Math.max(1, Math.min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);\n            }\n        }\n        return dp[0][0];\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            // Fix: Properly escape square brackets in regex\n            String[] rows = line.substring(2, line.length()-2).split(\"\\\\],\\\\[\");\n            int m = rows.length;\n            int[][] dungeon = new int[m][];\n            for (int i = 0; i < m; i++) {\n                String[] nums = rows[i].split(\",\");\n                dungeon[i] = new int[nums.length];\n                for (int j = 0; j < nums.length; j++) {\n                    dungeon[i][j] = Integer.parseInt(nums[j].trim());\n                }\n            }\n            Main main = new Main();\n            int result = main.calculateMinimumHP(dungeon);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def calculateMinimumHP(self, dungeon):\n        m, n = len(dungeon), len(dungeon[0])\n        # Initialize dp array with infinity\n        dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n        # Base cases: health needed at the princess or beyond\n        dp[m][n-1] = 1\n        dp[m-1][n] = 1\n        # Fill dp table from bottom-right to top-left\n        for i in range(m-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])\n        return dp[0][0]\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    import json\n    try:\n        dungeon = json.loads(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.calculateMinimumHP(dungeon)\n        print result  \n    except Exception as e:\n        print \"Invalid input format\"\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Calculates minimum initial health for the dungeon game.\n * @param {number[][]} dungeon - 2D grid of integers\n * @return {number} - Minimum initial health\n */\nfunction calculateMinimumHP(dungeon) {\n    const m = dungeon.length, n = dungeon[0].length;\n    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(Infinity));\n    dp[m][n-1] = 1; dp[m-1][n] = 1;\n    for (let i = m-1; i >= 0; i--) {\n        for (let j = n-1; j >= 0; j--) {\n            dp[i][j] = Math.max(1, Math.min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);\n        }\n    }\n    return dp[0][0];\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const dungeon = JSON.parse(line.trim());\n        const result = calculateMinimumHP(dungeon);\n        console.log(result);\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    }
  },
  {
    "title": "Valid Anagram",
    "description": "Given two strings s and t, write a function to determine if t is an anagram of s. An anagram is a word formed by rearranging the letters of another, using all the original letters exactly once.\n\n### Problem Statement\n\nYou are given two strings **s** and **t**. Return true if t is an anagram of s, false otherwise.\n\n### Input\n\n- **s**: A string of lowercase letters (0 <= s.length <= 5 * 10^4).\n- **t**: A string of lowercase letters (t.length == s.length).\n\n### Output\n\n- A boolean: true if t is an anagram of s, false otherwise.\n\n### Example\n\n**Input**: s = 'anagram', t = 'nagaram'  \n**Output**: true  \n**Explanation**: 'nagaram' is a rearrangement of 'anagram'.\n\n**Input**: s = 'rat', t = 'car'  \n**Output**: false  \n**Explanation**: Different letters, not an anagram.\n\n**Input**: s = 'a', t = 'a'  \n**Output**: true  \n**Explanation**: Single character, same in both.\n\n### Notes\n\n- Use a frequency count array or hash map to compare character counts.\n- For Unicode characters, adapt by using a hash map instead of a fixed-size array.\n\n### Real-World Context\n\nThis problem is relevant in text processing, data validation, or cryptographic applications where character frequency matters.",
    "difficulty": "EASY",
    "tags": [
      "String",
      "Hash Map",
      "Sorting",
      "Amazon",
      "Microsoft",
      "Google",
      "Tcs",
      "Oracle",
      "VM Ware"
    ],
    "constraints": [
      "0 <= s.length, t.length <= 5 * 10^4",
      "s.length == t.length",
      "s and t consist of lowercase letters",
      "Time complexity should be O(n), where n is string length",
      "Space complexity should be O(1) for fixed-size array"
    ],
    "examples": [
      {
        "input": "s = \"anagram\", t = \"nagaram\"",
        "output": "true",
        "explanation": "'nagaram' is a rearrangement of 'anagram'."
      }
    ],
    "testcases": [
      {
        "input": "anagram\nnagaram",
        "output": "true",
        "isHidden": false
      },
      {
        "input": "rat\ncar",
        "output": "false",
        "isHidden": false
      },
      {
        "input": "rome\nmore",
        "output": "true",
        "isHidden": false
      }
    ],
    "hints": [
      "1. Count the frequency of each character in s and t.",
      "2. Use a fixed-size array for lowercase letters to track counts.",
      "3. For Unicode, use a hash map to handle arbitrary characters."
    ],
    "editorial": "## Editorial: Valid Anagram\n\n### Problem Recap\n\nDetermine if two strings s and t are anagrams by checking if they have the same characters with the same frequencies.\n\n### Intuition\n\nThis is a frequency counting problem. Use a fixed-size array (for lowercase letters) to count characters in s and decrement for t. If all counts are zero, the strings are anagrams.\n\n### Approaches\n\n#### 1. Frequency Array\n\n- **Idea**: Use a 26-element array to count frequencies of lowercase letters.\n- **Steps**:\n  1. Check if lengths of s and t are equal; if not, return false.\n  2. Create an array of size 26 for letters 'a' to 'z'.\n  3. Increment counts for s, decrement for t.\n  4. If all counts are 0, return true; else false.\n- **Time Complexity**: O(n), where n is string length.\n- **Space Complexity**: O(1) for fixed-size array.\n- **Pros**: Fast, constant space for lowercase letters.\n\n#### 2. Sorting\n\n- **Idea**: Sort both strings and compare them.\n- **Steps**:\n  1. Check if lengths are equal.\n  2. Sort s and t.\n  3. Compare sorted strings.\n- **Time Complexity**: O(n log n) for sorting.\n- **Space Complexity**: O(1) or O(n) depending on sorting implementation.\n- **Cons**: Slower than frequency array.\n\n### Recommended Solution\n\nFrequency Array is recommended for O(n) time and O(1) space.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for one pass through strings.\n- **Space Complexity**: O(1) for 26-element array.\n- **Constraints Handling**:\n  - String length: 0 <= n <= 5 * 10^4.\n  - Characters: lowercase letters.\n\n### Edge Cases\n\n- **Empty strings**: s = '', t = '' → true.\n- **Single character**: s = 'a', t = 'a' → true.\n- **Different lengths**: s = 'ab', t = 'a' → false.\n\n### Implementation Notes\n\n- Use char code subtraction ('a' = 97) for indexing.\n- Handle empty strings explicitly if needed.\n\n### Visual Explanation\n\nFor s = 'anagram', t = 'nagaram':\n- Count 'a': 3 in both, 'n': 1, 'g': 1, 'r': 1, 'm': 1.\n- All counts match, return true.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"bufio\"\n    \"os\"\n)\n\nfunc isAnagram(s, t string) bool {\n    // Write your code here\n    return false\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    var s, t string\n    if scanner.Scan() {\n        s = scanner.Text()\n    }\n    if scanner.Scan() {\n        t = scanner.Text()\n    }\n    if s == \"\" && t == \"\" {\n        fmt.Println(true)\n        return\n    }\n    if s == \"\" || t == \"\" {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := isAnagram(s, t)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        // Write your code here\n        return false;\n    }\n};\n\nint main() {\n    try {\n        string s, t;\n        if (!getline(cin, s) || !getline(cin, t)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        Solution sol;\n        bool result = sol.isAnagram(s, t);\n        cout << (result ? \"true\" : \"false\") << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Checks if t is an anagram of s.\n     * @param s First string\n     * @param t Second string\n     * @return True if anagram, false otherwise\n     */\n    public boolean isAnagram(String s, String t) {\n        // Write your code here\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String s = scanner.nextLine().trim();\n            String t = scanner.nextLine().trim();\n            Main main = new Main();\n            boolean result = main.isAnagram(s, t);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def isAnagram(self, s, t):\n        \"\"\"\n        Checks if t is an anagram of s.\n        :param s: First string\n        :param t: Second string\n        :return: True if anagram, false otherwise\n        \"\"\"\n        # Write your code here\n        return False\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        s = sys.stdin.readline().strip()\n        t = sys.stdin.readline().strip()\n        if s == \"\" and t == \"\":\n            print \"true\"  # Lowercase for consistency\n            sys.exit(0)\n        sol = Solution()\n        result = sol.isAnagram(s, t)\n        print \"true\" if result else \"false\"  # Lowercase boolean output\n    except Exception as e:\n        print \"Invalid input format\"\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Checks if t is an anagram of s.\n * @param {string} s - First string\n * @param {string} t - Second string\n * @return {boolean} - True if anagram, false otherwise\n */\nfunction isAnagram(s, t) {\n // Write your code here\n return false;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n input: process.stdin,\n output: process.stdout,\n terminal: false\n});\n\nlet lines = [];\nrl.on(\"line\", (line) => {\n lines.push(line.trim());\n if (lines.length === 2) {\n try {\n // Handle empty strings case\n if (lines[0] === \"\" && lines[1] === \"\") {\n console.log(true);\n rl.close();\n return;\n }\n const result = isAnagram(lines[0], lines[1]);\n console.log(result);\n rl.close();\n } catch (e) {\n console.log(\"Invalid input format\");\n process.exit(1);\n }\n }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"bufio\"\n    \"os\"\n)\n\nfunc isAnagram(s, t string) bool {\n    if len(s) != len(t) {\n        return false\n    }\n    count := make([]int, 26)\n    for i := 0; i < len(s); i++ {\n        count[s[i]-'a']++\n        count[t[i]-'a']--\n    }\n    for _, c := range count {\n        if c != 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    var s, t string\n    if scanner.Scan() {\n        s = scanner.Text()\n    }\n    if scanner.Scan() {\n        t = scanner.Text()\n    }\n    if s == \"\" && t == \"\" {\n        fmt.Println(true)\n        return\n    }\n    if s == \"\" || t == \"\" {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := isAnagram(s, t)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if (s.length() != t.length()) return false;\n        int count[26] = {0};\n        for (size_t i = 0; i < s.length(); i++) {\n            count[s[i] - 'a']++;\n            count[t[i] - 'a']--;\n        }\n        for (int c : count) if (c != 0) return false;\n        return true;\n    }\n};\n\nint main() {\n    try {\n        string s, t;\n        if (!getline(cin, s) || !getline(cin, t)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        Solution sol;\n        bool result = sol.isAnagram(s, t);\n        cout << (result ? \"true\" : \"false\") << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) return false;\n        int[] count = new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            count[s.charAt(i) - 'a']++;\n            count[t.charAt(i) - 'a']--;\n        }\n        for (int c : count) if (c != 0) return false;\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String s = scanner.nextLine().trim();\n            String t = scanner.nextLine().trim();\n            Main main = new Main();\n            boolean result = main.isAnagram(s, t);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def isAnagram(self, s, t):\n        if len(s) != len(t):\n            return False\n        if len(s) == 0 and len(t) == 0:\n            return True\n        count = [0] * 26\n        for c1, c2 in zip(s, t):\n            count[ord(c1) - ord('a')] += 1\n            count[ord(c2) - ord('a')] -= 1\n        return all(c == 0 for c in count)\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        s = sys.stdin.readline().strip()\n        t = sys.stdin.readline().strip()\n        if s == \"\" and t == \"\":\n            print \"true\"  # Lowercase for consistency\n            sys.exit(0)\n        sol = Solution()\n        result = sol.isAnagram(s, t)\n        print \"true\" if result else \"false\"  # Lowercase boolean output\n    except Exception as e:\n        print \"Invalid input format\"\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Checks if t is an anagram of s.\n * @param {string} s - First string\n * @param {string} t - Second string\n * @return {boolean} - True if anagram, false otherwise\n */\nfunction isAnagram(s, t) {\n if (s.length !== t.length) return false;\n if (s.length === 0 && t.length === 0) return true;\n const count = new Array(26).fill(0);\n for (let i = 0; i < s.length; i++) {\n count[s.charCodeAt(i) - 97]++;\n count[t.charCodeAt(i) - 97]--;\n }\n return count.every(c => c === 0);\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n input: process.stdin,\n output: process.stdout,\n terminal: false\n});\n\nlet lines = [];\nrl.on(\"line\", (line) => {\n lines.push(line.trim());\n if (lines.length === 2) {\n try {\n // Handle empty strings case\n if (lines[0] === \"\" && lines[1] === \"\") {\n console.log(true);\n rl.close();\n return;\n }\n const result = isAnagram(lines[0], lines[1]);\n console.log(result);\n rl.close();\n } catch (e) {\n console.log(\"Invalid input format\");\n process.exit(1);\n }\n }\n});"
    }
  },
  {
    "title": "Strobogrammatic Number",
    "description": "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Write a function to determine if a number is strobogrammatic. The number is represented as a string.\n\n### Problem Statement\n\nYou are given a string **num** representing a number. Return true if the number is strobogrammatic, false otherwise. A strobogrammatic number remains the same when rotated 180 degrees, meaning each digit must either be invariant (0, 1, 8) or pair with its rotated counterpart (6 with 9, 9 with 6).\n\n### Input\n\n- **num**: A string of digits (1 <= num.length <= 50).\n\n### Output\n\n- A boolean: true if num is strobogrammatic, false otherwise.\n\n### Example\n\n**Input**: num = '69'  \n**Output**: true  \n**Explanation**: '6' rotates to '9' and '9' rotates to '6', so '69' is strobogrammatic.\n\n**Input**: num = '88'  \n**Output**: true  \n**Explanation**: '8' rotates to '8', so '88' is strobogrammatic.\n\n**Input**: num = '962'  \n**Output**: false  \n**Explanation**: '2' does not have a valid rotation, so '962' is not strobogrammatic.\n\n### Notes\n\n- Use a two-pointer approach to compare digits from both ends.\n- Valid digits are 0, 1, 8 (self-mapping) and 6, 9 (map to each other).\n\n### Real-World Context\n\nThis problem is relevant in pattern recognition, display systems, or puzzles where symmetry under rotation is important.",
    "difficulty": "EASY",
    "tags": [
      "String",
      "Two Pointers",
      "Hash Map",
      "Google",
      "Facebook",
      "Oracle",
      "Paypal"
    ],
    "constraints": [
      "1 <= num.length <= 50",
      "num consists of digits",
      "Time complexity should be O(n), where n is string length",
      "Space complexity should be O(1) for fixed-size mapping"
    ],
    "examples": [
      {
        "input": "num = \"69\"",
        "output": "true",
        "explanation": "'6' rotates to '9' and '9' rotates to '6', so '69' is strobogrammatic."
      }
    ],
    "testcases": [
      {
        "input": "69",
        "output": "true",
        "isHidden": false
      },
      {
        "input": "88",
        "output": "true",
        "isHidden": false
      },
      {
        "input": "962",
        "output": "false",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Use two pointers to compare digits from start and end.",
      "2. Check if each pair of digits is valid (0→0, 1→1, 8→8, 6→9, 9→6).",
      "3. Use a hash map or array to store valid mappings."
    ],
    "editorial": "## Editorial: Strobogrammatic Number\n\n### Problem Recap\n\nDetermine if a number string is strobogrammatic, meaning it looks the same when rotated 180 degrees. Valid digits are 0, 1, 8 (self-mapping) and 6, 9 (map to each other).\n\n### Intuition\n\nThis is a string comparison problem with a symmetry constraint. Use two pointers to compare digits from the start and end of the string, checking if each pair is a valid strobogrammatic mapping (e.g., 6 pairs with 9). A hash map or array can store these mappings.\n\n### Approaches\n\n#### 1. Two Pointers with Hash Map\n\n- **Idea**: Compare digits from both ends using a map of valid rotations.\n- **Steps**:\n  1. Create a map: {'0':'0', '1':'1', '8':'8', '6':'9', '9':'6'}.\n  2. Use two pointers (left, right) starting from string ends.\n  3. For each pair, check if left digit maps to right digit.\n  4. If any pair is invalid, return false; else true.\n- **Time Complexity**: O(n), where n is string length.\n- **Space Complexity**: O(1) for fixed-size map (5 digits).\n- **Pros**: Simple, efficient, constant space.\n\n#### 2. String Reversal\n\n- **Idea**: Create the rotated string and compare with original.\n- **Steps**:\n  1. Reverse the string and map each digit (0→0, 1→1, 8→8, 6→9, 9→6).\n  2. Compare rotated string with original.\n- **Time Complexity**: O(n) for reversal and comparison.\n- **Space Complexity**: O(n) for new string.\n- **Cons**: Extra space for string creation.\n\n### Recommended Solution\n\nTwo Pointers with Hash Map is recommended for O(1) space and clarity.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for one pass through string.\n- **Space Complexity**: O(1) for fixed-size map.\n- **Constraints Handling**:\n  - String length: 1 <= n <= 50.\n  - Input: digits only.\n\n### Edge Cases\n\n- **Single digit**: num = '1' → true (1 maps to 1).\n- **Empty string**: Not applicable per constraint.\n- **Invalid digits**: num = '2' → false.\n\n### Implementation Notes\n\n- Use a hash map or array for mappings.\n- Validate digits to ensure they are in {0,1,6,8,9}.\n\n### Visual Explanation\n\nFor num = '69':\n- Left=6, Right=9: 6 maps to 9, valid.\n- Return true.\nFor num = '962':\n- Left=9, Right=2: 2 is not a valid strobogrammatic digit, return false.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"bufio\"\n    \"os\"\n)\n\nfunc isStrobogrammatic(num string) bool {\n    // Write your code here\n    return false\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    if scanner.Scan() {\n        num := scanner.Text()\n        result := isStrobogrammatic(num)\n        fmt.Println(result)\n    } else {\n        fmt.Println(\"Invalid input format\")\n    }\n}",
      "C++": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isStrobogrammatic(string num) {\n        // Write your code here\n        return false;\n    }\n};\n\nint main() {\n    try {\n        string num;\n        if (!getline(cin, num)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        Solution sol;\n        bool result = sol.isStrobogrammatic(num);\n        cout << (result ? \"true\" : \"false\") << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Checks if a number is strobogrammatic.\n     * @param num Number as a string\n     * @return True if strobogrammatic, false otherwise\n     */\n    public boolean isStrobogrammatic(String num) {\n        // Write your code here\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String num = scanner.nextLine().trim();\n            Main main = new Main();\n            boolean result = main.isStrobogrammatic(num);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def isStrobogrammatic(self, num):\n        \"\"\"\n        Checks if a number is strobogrammatic.\n        :param num: Number as a string\n        :return: True if strobogrammatic, false otherwise\n        \"\"\"\n        # Write your code here\n        return False\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        num = sys.stdin.readline().strip()\n        sol = Solution()\n        result = sol.isStrobogrammatic(num)\n        print \"true\" if result else \"false\"  # Lowercase for consistency\n    except Exception as e:\n        print \"Invalid input format\"\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Checks if a number is strobogrammatic.\n * @param {string} num - Number as a string\n * @return {boolean} - True if strobogrammatic, false otherwise\n */\nfunction isStrobogrammatic(num) {\n    // Write your code here\n    return false;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const result = isStrobogrammatic(line.trim());\n        console.log(result);\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"bufio\"\n    \"os\"\n)\n\nfunc isStrobogrammatic(num string) bool {\n    mapping := map[byte]byte{'0': '0', '1': '1', '8': '8', '6': '9', '9': '6'}\n    left, right := 0, len(num)-1\n    for left <= right {\n        mapped, exists := mapping[num[left]]\n        if !exists || mapped != num[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    if scanner.Scan() {\n        num := scanner.Text()\n        result := isStrobogrammatic(num)\n        fmt.Println(result)\n    } else {\n        fmt.Println(\"Invalid input format\")\n    }\n}",
      "C++": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isStrobogrammatic(string num) {\n        char map[128] = {0};\n        map['0'] = '0'; map['1'] = '1'; map['8'] = '8'; map['6'] = '9'; map['9'] = '6';\n        int left = 0, right = num.length() - 1;\n        while (left <= right) {\n            if (map[num[left]] == 0 || map[num[left]] != num[right]) return false;\n            left++;\n            right--;\n        }\n        return true;\n    }\n};\n\nint main() {\n    try {\n        string num;\n        if (!getline(cin, num)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        Solution sol;\n        bool result = sol.isStrobogrammatic(num);\n        cout << (result ? \"true\" : \"false\") << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public boolean isStrobogrammatic(String num) {\n        char[] map = new char[128];\n        map['0'] = '0'; map['1'] = '1'; map['8'] = '8'; map['6'] = '9'; map['9'] = '6';\n        int left = 0, right = num.length() - 1;\n        while (left <= right) {\n            if (map[num.charAt(left)] == 0 || map[num.charAt(left)] != num.charAt(right)) return false;\n            left++;\n            right--;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String num = scanner.nextLine().trim();\n            Main main = new Main();\n            boolean result = main.isStrobogrammatic(num);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def isStrobogrammatic(self, num):\n        mapping = {'0': '0', '1': '1', '8': '8', '6': '9', '9': '6'}\n        left, right = 0, len(num) - 1\n        while left <= right:\n            if num[left] not in mapping or mapping[num[left]] != num[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        num = sys.stdin.readline().strip()\n        sol = Solution()\n        result = sol.isStrobogrammatic(num)\n        print \"true\" if result else \"false\"  # Lowercase for consistency\n    except Exception as e:\n        print \"Invalid input format\"\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Checks if a number is strobogrammatic.\n * @param {string} num - Number as a string\n * @return {boolean} - True if strobogrammatic, false otherwise\n */\nfunction isStrobogrammatic(num) {\n    const map = { '0': '0', '1': '1', '8': '8', '6': '9', '9': '6' };\n    let left = 0, right = num.length - 1;\n    while (left <= right) {\n        if (!(num[left] in map) || map[num[left]] !== num[right]) return false;\n        left++;\n        right--;\n    }\n    return true;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const result = isStrobogrammatic(line.trim());\n        console.log(result);\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    }
  },
  {
    "title": "House Robber",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, and the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected, and it will automatically contact the police if two adjacent houses are broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\n\n### Problem Statement\n\nReturn the maximum amount of money that can be robbed without robbing adjacent houses.\n\n### Input\n\n- **nums**: An array of non-negative integers (0 <= nums.length <= 100, 0 <= nums[i] <= 400).\n\n### Output\n\n- An integer representing the maximum amount of money that can be robbed.\n\n### Example\n\n**Input**: nums = [1,2,3,1]  \n**Output**: 4  \n**Explanation**: Rob house 1 (money=1) and then rob house 3 (money=3). Total amount = 1 + 3 = 4.\n\n**Input**: nums = [2,7,9,3,1]  \n**Output**: 12  \n**Explanation**: Rob house 1 (money=2), rob house 3 (money=9), and rob house 5 (money=1). Total amount = 2 + 9 + 1 = 12.\n\n### Notes\n\n- Use dynamic programming to track the maximum money robable up to each house.\n- Consider whether to rob the current house based on previous decisions.\n\n### Real-World Context\n\nThis problem is relevant in optimization scenarios, such as scheduling or resource allocation with constraints, common at companies like Uber.",
    "difficulty": "EASY",
    "tags": [
      "Dynamic Programming",
      "Array",
      "Uber",
      "Google",
      "Atlassian"
    ],
    "constraints": [
      "0 <= nums.length <= 100",
      "0 <= nums[i] <= 400",
      "Time complexity should be O(n)",
      "Space complexity should be O(1) for optimized"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 1]",
        "output": "4",
        "explanation": "Rob house 1 (money=1) and then rob house 3 (money=3). Total amount = 1 + 3 = 4."
      }
    ],
    "testcases": [
      {
        "input": "[1,2,3,1]",
        "output": "4",
        "isHidden": false
      },
      {
        "input": "[2,7,9,3,1]",
        "output": "12",
        "isHidden": false
      },
      {
        "input": "[]",
        "output": "0",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Use dynamic programming to store the maximum money robable up to each house.",
      "2. For each house, decide whether to rob it (adding its money to the amount from two houses back) or skip it.",
      "3. Optimize space by using two variables instead of an array."
    ],
    "editorial": "## Editorial: House Robber\n\n### Problem Recap\n\nDetermine the maximum amount of money that can be robbed from non-adjacent houses in an array.\n\n### Intuition\n\nSince adjacent houses cannot be robbed, we decide for each house whether to rob it (adding its money to the amount from two houses back) or skip it (taking the amount from the previous house). Dynamic programming tracks these decisions efficiently.\n\n### Approach\n\n#### Dynamic Programming (Bottom-Up)\n\n- **Idea**: Use two variables to track the maximum money robable up to the previous two houses.\n- **Steps**:\n  1. Initialize prev2 = 0 (two houses back), prev1 = 0 (previous house).\n  2. For each house num in nums:\n     - Compute current = max(prev2 + num, prev1).\n     - Update prev2 = prev1, prev1 = current.\n  3. Return prev1.\n- **Time Complexity**: O(n) for one pass.\n- **Space Complexity**: O(1) for two variables.\n\n### Recommended Solution\n\nThe two-variable DP approach is optimal for O(n) time and O(1) space.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for iterating through the array.\n- **Space Complexity**: O(1) for two variables.\n- **Constraints Handling**:\n  - Array length: 0 <= n <= 100.\n  - Values: 0 <= nums[i] <= 400.\n\n### Edge Cases\n\n- **Empty array**: nums = [] → 0.\n- **Single house**: nums = [1] → 1.\n- **Two houses**: nums = [1,2] → 2.\n- **All zeros**: nums = [0,0,0] → 0.\n\n### Implementation Notes\n\n- Handle empty array by returning 0.\n- Use long for intermediate calculations to avoid overflow (though not needed for given constraints).\n- The solution is simple and efficient with constant space.\n\n### Visual Explanation\n\nFor nums = [2,7,9,3,1]:\n- prev2 = 0, prev1 = 2.\n- num=7: current = max(0+7, 2) = 7, prev2=2, prev1=7.\n- num=9: current = max(2+9, 7) = 11, prev2=7, prev1=11.\n- num=3: current = max(7+3, 11) = 11, prev2=11, prev1=11.\n- num=1: current = max(11+1, 11) = 12, prev2=11, prev1=12.\n- Return 12.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc robHouse(nums []int) int {\n    // Write your code here\n    return 0\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    // Handle empty array case\n    if input == \"[]\" {\n        fmt.Println(0)\n        return\n    }\n    // Parse non-empty array\n    input = input[1:len(input)-1]\n    strNums := strings.Split(input, \",\")\n    nums := make([]int, len(strNums))\n    for i, s := range strNums {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        nums[i] = num\n    }\n    result := robHouse(nums)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int robHouse(vector<int>& nums) {\n        // Write your code here\n        return 0;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        size_t pos = 0;\n        while ((pos = line.find(\",\")) != string::npos) {\n            nums.push_back(stoi(line.substr(0, pos)));\n            line.erase(0, pos + 1);\n        }\n        if (!line.empty()) nums.push_back(stoi(line));\n        Solution sol;\n        int result = sol.robHouse(nums);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Finds maximum money that can be robbed.\n     * @param nums Array of non-negative integers\n     * @return Maximum money\n     */\n    public int robHouse(int[] nums) {\n        // Write your code here\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            // Handle empty array case\n            if (line.equals(\"[]\")) {\n                System.out.println(0);\n                return;\n            }\n            // Parse non-empty array\n            String[] strNums = line.substring(1, line.length()-1).split(\",\");\n            int[] nums = new int[strNums.length];\n            for (int i = 0; i < strNums.length; i++) {\n                nums[i] = Integer.parseInt(strNums[i].trim());\n            }\n            Main main = new Main();\n            int result = main.robHouse(nums);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def rob(self, nums):\n        \"\"\"\n        Finds maximum money that can be robbed.\n        :param nums: Array of non-negative integers\n        :return: Maximum money\n        \"\"\"\n        # Write your code here\n        return 0\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    import json\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.rob(nums)\n        print result  \n    except Exception as e:\n        print \"Invalid input format\"\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds maximum money that can be robbed.\n * @param {number[]} nums - Array of non-negative integers\n * @return {number} - Maximum money\n */\nfunction robHouse(nums) {\n    // Write your code here\n    return 0;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const nums = JSON.parse(line.trim());\n        const result = robHouse(nums);\n        console.log(result);\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc robHouse(nums []int) int {\n    if len(nums) == 0 {\n        return 0\n    }\n    prev2, prev1 := 0, 0\n    for _, num := range nums {\n        current := max(prev2+num, prev1)\n        prev2 = prev1\n        prev1 = current\n    }\n    return prev1\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    // Handle empty array case\n    if input == \"[]\" {\n        fmt.Println(0)\n        return\n    }\n    // Parse non-empty array\n    input = input[1:len(input)-1]\n    strNums := strings.Split(input, \",\")\n    nums := make([]int, len(strNums))\n    for i, s := range strNums {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        nums[i] = num\n    }\n    result := robHouse(nums)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int robHouse(vector<int>& nums) {\n        int prev2 = 0, prev1 = 0;\n        for (int num : nums) {\n            int current = max(prev2 + num, prev1);\n            prev2 = prev1;\n            prev1 = current;\n        }\n        return prev1;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        size_t pos = 0;\n        while ((pos = line.find(\",\")) != string::npos) {\n            nums.push_back(stoi(line.substr(0, pos)));\n            line.erase(0, pos + 1);\n        }\n        if (!line.empty()) nums.push_back(stoi(line));\n        Solution sol;\n        int result = sol.robHouse(nums);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public int robHouse(int[] nums) {\n        if (nums.length == 0) return 0;\n        int prev2 = 0, prev1 = 0;\n        for (int num : nums) {\n            int current = Math.max(prev2 + num, prev1);\n            prev2 = prev1;\n            prev1 = current;\n        }\n        return prev1;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            // Handle empty array case\n            if (line.equals(\"[]\")) {\n                System.out.println(0);\n                return;\n            }\n            // Parse non-empty array\n            String[] strNums = line.substring(1, line.length()-1).split(\",\");\n            int[] nums = new int[strNums.length];\n            for (int i = 0; i < strNums.length; i++) {\n                nums[i] = Integer.parseInt(strNums[i].trim());\n            }\n            Main main = new Main();\n            int result = main.robHouse(nums);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def rob(self, nums):\n        if not nums:\n            return 0\n        prev2, prev1 = 0, 0\n        for num in nums:\n            current = max(prev2 + num, prev1)\n            prev2 = prev1\n            prev1 = current\n        return prev1\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    import json\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.rob(nums)\n        print result  \n    except Exception as e:\n        print \"Invalid input format\"\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds maximum money that can be robbed.\n * @param {number[]} nums - Array of non-negative integers\n * @return {number} - Maximum money\n */\nfunction robHouse(nums) {\n    let prev2 = 0, prev1 = 0;\n    for (let num of nums) {\n        let current = Math.max(prev2 + num, prev1);\n        prev2 = prev1;\n        prev1 = current;\n    }\n    return prev1;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const nums = JSON.parse(line.trim());\n        const result = robHouse(nums);\n        console.log(result);\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    }
  },
  {
    "title": "Maximum Depth of Binary Tree",
    "description": "Given the root of a binary tree, return its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n### Problem Statement\n\nYou are given the root of a binary tree. Return the maximum depth of the tree.\n\n### Input\n\n- **root**: The root node of a binary tree (0 <= number of nodes <= 10^4, -100 <= Node.val <= 100).\n\n### Output\n\n- An integer: the maximum depth of the tree.\n\n### Example\n\n**Input**: root = [3,9,20,null,null,15,7]  \n**Output**: 3  \n**Explanation**: The longest path is 3->20->15 or 3->20->7, with 3 nodes.\n\n**Input**: root = [1,null,2]  \n**Output**: 2  \n**Explanation**: The longest path is 1->2, with 2 nodes.\n\n**Input**: root = []  \n**Output**: 0  \n**Explanation**: Empty tree has depth 0.\n\n### Notes\n\n- Use DFS or BFS to compute the depth.\n- A leaf is a node with no children.\n\n### Real-World Context\n\nThis problem is relevant in hierarchical data structures, network routing, or file system traversal.",
    "difficulty": "EASY",
    "tags": [
      "Tree",
      "DFS",
      "BFS",
      "TCS",
      "Cisco",
      "Oracle"
    ],
    "constraints": [
      "0 <= number of nodes <= 10^4",
      "-100 <= Node.val <= 100",
      "Time complexity should be O(n), where n is number of nodes",
      "Space complexity should be O(h) for recursion stack, where h is tree height"
    ],
    "examples": [
      {
        "input": "root = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))",
        "output": "3",
        "explanation": "Longest path has 3 nodes."
      }
    ],
    "testcases": [
      {
        "input": "[3,9,20,null,null,15,7]",
        "output": "3",
        "isHidden": false
      },
      {
        "input": "[1,null,2]",
        "output": "2",
        "isHidden": false
      },
      {
        "input": "[]",
        "output": "0",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Use recursion to compute the depth of left and right subtrees.\\n2. Return the maximum of left and right depths plus 1.\\n3. Handle the empty tree case by returning 0."
    ],
    "editorial": "## Editorial: Maximum Depth of Binary Tree\n\n### Problem Recap\n\nFind the maximum depth of a binary tree, defined as the number of nodes in the longest root-to-leaf path.\n\n### Intuition\n\nThis is a tree traversal problem. Use DFS (recursion) to compute the depth of each subtree and return the maximum. Alternatively, BFS can count levels.\n\n### Approaches\n\n#### 1. Recursive DFS\n\n- **Idea**: Recursively compute left and right subtree depths, return max + 1.\n- **Steps**:\n  1. If root is null, return 0.\n  2. Compute leftDepth = maxDepth(left).\n  3. Compute rightDepth = maxDepth(right).\n  4. Return max(leftDepth, rightDepth) + 1.\n- **Time Complexity**: O(n), visiting each node once.\n- **Space Complexity**: O(h) for recursion stack, where h is height.\n- **Pros**: Simple, elegant.\n\n#### 2. BFS (Level-Order)\n\n- **Idea**: Traverse tree level by level, counting levels.\n- **Steps**:\n  1. Use a queue, initialize with root.\n  2. Process each level, increment depth.\n  3. Return depth after queue is empty.\n- **Time Complexity**: O(n).\n- **Space Complexity**: O(w), where w is max width.\n\n### Recommended Solution\n\nRecursive DFS is recommended for simplicity and lower space in balanced trees.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for visiting all nodes.\n- **Space Complexity**: O(h) for recursion stack.\n- **Constraints Handling**:\n  - Nodes: 0 <= n <= 10^4.\n  - Values: -100 <= val <= 100.\n\n### Edge Cases\n\n- **Empty tree**: Return 0.\n- **Single node**: Return 1.\n- **Skewed tree**: Depth equals number of nodes.\n\n### Implementation Notes\n\n- Use a TreeNode class with val, left, right.\n- Handle null nodes explicitly.\n\n### Visual Explanation\n\nFor [3,9,20,null,null,15,7]:\n- Left depth (9): 2.\n- Right depth (20->15,7): 3.\n- Return max(2,3) + 1 = 3.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n)\n\ntype TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n\nfunc maxDepth(root *TreeNode) int {\n    // Write your code here\n    return 0\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    scanner.Scan()\n    line := strings.TrimSpace(scanner.Text())\n    if scanner.Err() != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    if line == \"[]\" {\n        fmt.Println(0)\n        return\n    }\n    arr := strings.Split(line[1:len(line)-1], \",\")\n    if len(arr) == 0 || arr[0] == \"\" {\n        fmt.Println(0)\n        return\n    }\n    nodes := make([]*TreeNode, len(arr))\n    for i, s := range arr {\n        s = strings.TrimSpace(s)\n        if s != \"null\" {\n            val, err := strconv.Atoi(s)\n            if err != nil {\n                fmt.Println(\"Invalid input format\")\n                return\n            }\n            nodes[i] = &TreeNode{Val: val}\n        }\n    }\n    for i := 0; i < len(arr); i++ {\n        if nodes[i] != nil {\n            if 2*i+1 < len(nodes) {\n                nodes[i].Left = nodes[2*i+1]\n            }\n            if 2*i+2 < len(nodes) {\n                nodes[i].Right = nodes[2*i+2]\n            }\n        }\n    }\n    result := maxDepth(nodes[0])\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <stdexcept>\n#include <algorithm> // Added for std::remove\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        // Write your code here\n        return 0;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) throw runtime_error(\"Invalid input format\");\n        line.erase(remove(line.begin(), line.end(), ' '), line.end()); // Remove all whitespace\n        if (line == \"[]\") {\n            cout << 0 << endl; // Empty tree\n            return 0;\n        }\n        line = line.substr(1, line.length() - 2); // Remove [ and ]\n        vector<string> arr;\n        stringstream ss(line);\n        string token;\n        while (getline(ss, token, ',')) {\n            arr.push_back(token);\n        }\n        vector<TreeNode*> nodes(arr.size(), nullptr);\n        for (int i = 0; i < arr.size(); i++) {\n            if (arr[i] != \"null\") {\n                nodes[i] = new TreeNode(stoi(arr[i]));\n            }\n        }\n        for (int i = 0; i < arr.size(); i++) {\n            if (nodes[i]) {\n                if (2 * i + 1 < nodes.size()) nodes[i]->left = nodes[2 * i + 1];\n                if (2 * i + 2 < nodes.size()) nodes[i]->right = nodes[2 * i + 2];\n            }\n        }\n        Solution sol;\n        int result = sol.maxDepth(nodes.empty() ? nullptr : nodes[0]);\n        cout << result << endl;\n        // Clean up memory\n        for (TreeNode* node : nodes) {\n            if (node) delete node;\n        }\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int val) { this.val = val; }\n}\n\npublic class Main {\n    public int maxDepth(TreeNode root) {\n        // Write your code here\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            if (line.equals(\"[]\")) {\n                System.out.println(0); // Empty tree\n                return;\n            }\n            String[] arrStr = line.substring(1, line.length() - 1).split(\",\");\n            TreeNode[] nodes = new TreeNode[arrStr.length];\n            for (int i = 0; i < arrStr.length; i++) {\n                if (!arrStr[i].trim().equals(\"null\")) {\n                    nodes[i] = new TreeNode(Integer.parseInt(arrStr[i].trim()));\n                }\n            }\n            for (int i = 0; i < arrStr.length; i++) {\n                if (nodes[i] != null) {\n                    if (2 * i + 1 < nodes.length) nodes[i].left = nodes[2 * i + 1];\n                    if (2 * i + 2 < nodes.length) nodes[i].right = nodes[2 * i + 2];\n                }\n            }\n            Main main = new Main();\n            int result = main.maxDepth(nodes.length > 0 ? nodes[0] : null);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxDepth(root):\n    # Write your code here\n    return 0\n\n# Input handling\nif __name__ == '__main__':\n    import sys\n    import json\n    try:\n        arr = json.loads(sys.stdin.readline().strip())\n        def array_to_tree(arr, index=0):\n            if index >= len(arr) or arr[index] is None:\n                return None\n            root = TreeNode(arr[index])\n            root.left = array_to_tree(arr, 2 * index + 1)\n            root.right = array_to_tree(arr, 2 * index + 2)\n            return root\n        root = None if not arr else array_to_tree(arr)\n        result = maxDepth(root)\n        print(result)\n    except Exception:\n        print('Invalid input format')\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = val;\n *     this.left = left;\n *     this.right = right;\n * }\n */\n/**\n * Returns maximum depth of binary tree.\n * @param {TreeNode} root - Root of binary tree\n * @return {number} - Maximum depth\n */\nfunction maxDepth(root) {\n    // Write your code here\n    return 0;\n}\n\n// Input handling\nconst readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on('line', (line) => {\n    try {\n        const arr = JSON.parse(line.trim());\n        function arrayToTree(arr, index = 0) {\n            if (index >= arr.length || arr[index] === null) return null;\n            const root = { val: arr[index], left: null, right: null };\n            root.left = arrayToTree(arr, 2 * index + 1);\n            root.right = arrayToTree(arr, 2 * index + 2);\n            return root;\n        }\n        const root = arr.length === 0 ? null : arrayToTree(arr);\n        const result = maxDepth(root);\n        console.log(result);\n        rl.close();\n    } catch (e) {\n        console.log('Invalid input format');\n        process.exit(1);\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n)\n\ntype TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n\nfunc maxDepth(root *TreeNode) int {\n    if root == nil {\n        return 0\n    }\n    leftDepth := maxDepth(root.Left)\n    rightDepth := maxDepth(root.Right)\n    if leftDepth > rightDepth {\n        return leftDepth + 1\n    }\n    return rightDepth + 1\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    scanner.Scan()\n    line := strings.TrimSpace(scanner.Text())\n    if scanner.Err() != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    if line == \"[]\" {\n        fmt.Println(0)\n        return\n    }\n    arr := strings.Split(line[1:len(line)-1], \",\")\n    if len(arr) == 0 || arr[0] == \"\" {\n        fmt.Println(0)\n        return\n    }\n    nodes := make([]*TreeNode, len(arr))\n    for i, s := range arr {\n        s = strings.TrimSpace(s)\n        if s != \"null\" {\n            val, err := strconv.Atoi(s)\n            if err != nil {\n                fmt.Println(\"Invalid input format\")\n                return\n            }\n            nodes[i] = &TreeNode{Val: val}\n        }\n    }\n    for i := 0; i < len(arr); i++ {\n        if nodes[i] != nil {\n            if 2*i+1 < len(nodes) {\n                nodes[i].Left = nodes[2*i+1]\n            }\n            if 2*i+2 < len(nodes) {\n                nodes[i].Right = nodes[2*i+2]\n            }\n        }\n    }\n    result := maxDepth(nodes[0])\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <stdexcept>\n#include <algorithm> // Added for std::remove\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (!root) return 0;\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) throw runtime_error(\"Invalid input format\");\n        line.erase(remove(line.begin(), line.end(), ' '), line.end()); // Remove all whitespace\n        if (line == \"[]\") {\n            cout << 0 << endl; // Empty tree\n            return 0;\n        }\n        line = line.substr(1, line.length() - 2); // Remove [ and ]\n        vector<string> arr;\n        stringstream ss(line);\n        string token;\n        while (getline(ss, token, ',')) {\n            arr.push_back(token);\n        }\n        vector<TreeNode*> nodes(arr.size(), nullptr);\n        for (int i = 0; i < arr.size(); i++) {\n            if (arr[i] != \"null\") {\n                nodes[i] = new TreeNode(stoi(arr[i]));\n            }\n        }\n        for (int i = 0; i < arr.size(); i++) {\n            if (nodes[i]) {\n                if (2 * i + 1 < nodes.size()) nodes[i]->left = nodes[2 * i + 1];\n                if (2 * i + 2 < nodes.size()) nodes[i]->right = nodes[2 * i + 2];\n            }\n        }\n        Solution sol;\n        int result = sol.maxDepth(nodes.empty() ? nullptr : nodes[0]);\n        cout << result << endl;\n        // Clean up memory\n        for (TreeNode* node : nodes) {\n            if (node) delete node;\n        }\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int val) { this.val = val; }\n}\n\npublic class Main {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            if (line.equals(\"[]\")) {\n                System.out.println(0); // Empty tree\n                return;\n            }\n            String[] arrStr = line.substring(1, line.length() - 1).split(\",\");\n            TreeNode[] nodes = new TreeNode[arrStr.length];\n            for (int i = 0; i < arrStr.length; i++) {\n                if (!arrStr[i].trim().equals(\"null\")) {\n                    nodes[i] = new TreeNode(Integer.parseInt(arrStr[i].trim()));\n                }\n            }\n            for (int i = 0; i < arrStr.length; i++) {\n                if (nodes[i] != null) {\n                    if (2 * i + 1 < nodes.length) nodes[i].left = nodes[2 * i + 1];\n                    if (2 * i + 2 < nodes.length) nodes[i].right = nodes[2 * i + 2];\n                }\n            }\n            Main main = new Main();\n            int result = main.maxDepth(nodes.length > 0 ? nodes[0] : null);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxDepth(root):\n    if not root:\n        return 0\n    return max(maxDepth(root.left), maxDepth(root.right)) + 1\n\n# Input handling\nif __name__ == '__main__':\n    import sys\n    import json\n    try:\n        arr = json.loads(sys.stdin.readline().strip())\n        def array_to_tree(arr, index=0):\n            if index >= len(arr) or arr[index] is None:\n                return None\n            root = TreeNode(arr[index])\n            root.left = array_to_tree(arr, 2 * index + 1)\n            root.right = array_to_tree(arr, 2 * index + 2)\n            return root\n        root = None if not arr else array_to_tree(arr)\n        result = maxDepth(root)\n        print(result)\n    except Exception:\n        print('Invalid input format')\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = val;\n *     this.left = left;\n *     this.right = right;\n * }\n */\nfunction maxDepth(root) {\n    if (!root) return 0;\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n}\n\n// Input handling\nconst readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on('line', (line) => {\n    try {\n        const arr = JSON.parse(line.trim());\n        function arrayToTree(arr, index = 0) {\n            if (index >= arr.length || arr[index] === null) return null;\n            const root = { val: arr[index], left: null, right: null };\n            root.left = arrayToTree(arr, 2 * index + 1);\n            root.right = arrayToTree(arr, 2 * index + 2);\n            return root;\n        }\n        const root = arr.length === 0 ? null : arrayToTree(arr);\n        const result = maxDepth(root);\n        console.log(result);\n        rl.close();\n    } catch (e) {\n        console.log('Invalid input format');\n        process.exit(1);\n    }\n});"
    }
  },
  {
    "title": "Merge Two Sorted Lists",
    "description": "Merge two sorted linked lists into a new sorted linked list.\n\n### Problem Statement\nGiven two sorted linked lists **list1** and **list2**, merge them into a single sorted linked list.\n\n### Input\n- **list1**: First sorted linked list (0 <= length <= 50, -100 <= Node.val <= 100).\n- **list2**: Second sorted linked list (0 <= length <= 50, -100 <= Node.val <= 100).\n\n### Output\n- A sorted linked list.\n\n### Example\n**Input**: list1 = [1,2,4], list2 = [1,3,4]  \n**Output**: [1,1,2,3,4,4]  \n**Input**: list1 = [], list2 = []  \n**Output**: []  \n**Input**: list1 = [], list2 = [0]  \n**Output**: [0]\n\n### Notes\nLists are sorted in non-decreasing order. Use iterative or recursive merging.\n\n### Real-World Context\nRelevant for merging sorted data in databases or stream processing.",
    "difficulty": "EASY",
    "tags": [
      "Linked List",
      "Recursion",
      "Microsoft",
      "Cisco",
      "Oracle"
    ],
    "constraints": [
      "0 <= list length <= 50",
      "-100 <= Node.val <= 100",
      "Time: O(n + m), where n, m are list lengths",
      "Space: O(1) for iterative solution"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 2, 4], nums2 = [1, 3, 4]",
        "output": "[1,1,2,3,4,4]",
        "explanation": "Merged sorted lists."
      }
    ],
    "testcases": [
      {
        "input": "[1,2,4]\n[1,3,4]",
        "output": "[1,1,2,3,4,4]",
        "isHidden": false
      },
      {
        "input": "[]\n[]",
        "output": "[]",
        "isHidden": false
      },
      {
        "input": "[]\n[0]",
        "output": "[0]",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Use a dummy node to simplify iterative merging.\\n2. Compare nodes and link the smaller one.\\n3. For recursion, merge the smaller head with the rest."
    ],
    "editorial": "## Editorial: Merge Two Sorted Lists\n\n### Problem Recap\nMerge two sorted linked lists into one sorted list.\n\n### Intuition\nCompare nodes from both lists, linking the smaller one to the result. Use a dummy node for iterative merging or recurse by selecting the smaller head.\n\n### Approach\n**Iterative**:\n1. Create dummy node, set curr = dummy.\n2. While both lists exist, link smaller node to curr.next, advance list and curr.\n3. Append remaining nodes.\n4. Return dummy.next.\n- Time: O(n + m)\n- Space: O(1)\n\n**Recursive**:\n1. If list1 null, return list2; if list2 null, return list1.\n2. If list1.val <= list2.val, set list1.next = merge(list1.next, list2).\n3. Else, set list2.next = merge(list1, list2.next).\n- Time: O(n + m)\n- Space: O(n + m)\n\n### Recommended\nIterative for O(1) space.\n\n### Edge Cases\n- Empty lists: [], [] → [].\n- One empty: [], [0] → [0].\n- Equal values: [1], [1] → [1,1].",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"bufio\"\n    \"os\"\n)\n\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {\n    // Write your code here\n    return nil\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    var arr1, arr2 []int\n    if scanner.Scan() {\n        if err := json.Unmarshal([]byte(scanner.Text()), &arr1); err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n    } else {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    if scanner.Scan() {\n        if err := json.Unmarshal([]byte(scanner.Text()), &arr2); err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n    } else {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    var buildList = func(arr []int) *ListNode {\n        if len(arr) == 0 {\n            return nil\n        }\n        head := &ListNode{Val: arr[0]}\n        curr := head\n        for _, val := range arr[1:] {\n            curr.Next = &ListNode{Val: val}\n            curr = curr.Next\n        }\n        return head\n    }\n    list1 := buildList(arr1)\n    list2 := buildList(arr2)\n    result := mergeTwoLists(list1, list2)\n    output := []int{}\n    for result != nil {\n        output = append(output, result.Val)\n        result = result.Next\n    }\n    b, _ := json.Marshal(output)\n    fmt.Println(string(b))\n}",
      "C++": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        // Write your code here\n        return nullptr;\n    }\n};\n\nint main() {\n    try {\n        string line1, line2;\n        if (!getline(cin, line1) || !getline(cin, line2)) throw runtime_error(\"Invalid input\");\n        // Handle empty lists explicitly\n        if (line1 == \"[]\" && line2 == \"[]\") {\n            cout << \"[]\" << endl;\n            return 0;\n        }\n        vector<int> arr1, arr2;\n        if (line1 != \"[]\") {\n            line1 = line1.substr(1, line1.length() - 2);\n            stringstream ss1(line1);\n            string token;\n            while (getline(ss1, token, ',')) arr1.push_back(stoi(token));\n        }\n        if (line2 != \"[]\") {\n            line2 = line2.substr(1, line2.length() - 2);\n            stringstream ss2(line2);\n            string token;\n            while (getline(ss2, token, ',')) arr2.push_back(stoi(token));\n        }\n        ListNode *list1 = nullptr, *list2 = nullptr;\n        if (!arr1.empty()) {\n            list1 = new ListNode(arr1[0]);\n            ListNode* curr = list1;\n            for (size_t i = 1; i < arr1.size(); i++) {\n                curr->next = new ListNode(arr1[i]);\n                curr = curr->next;\n            }\n        }\n        if (!arr2.empty()) {\n            list2 = new ListNode(arr2[0]);\n            ListNode* curr = list2;\n            for (size_t i = 1; i < arr2.size(); i++) {\n                curr->next = new ListNode(arr2[i]);\n                curr = curr->next;\n            }\n        }\n        Solution sol;\n        ListNode* result = sol.mergeTwoLists(list1, list2);\n        cout << \"[\";\n        ListNode* temp = result; // Keep pointer for cleanup\n        while (result) {\n            cout << result->val;\n            result = result->next;\n            if (result) cout << \",\";\n        }\n        cout << \"]\" << endl;\n        // Clean up memory for the merged list only\n        while (temp) {\n            ListNode* next = temp->next;\n            delete temp;\n            temp = next;\n        }\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; }\n}\n\npublic class Main {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        // Write your code here\n        return null;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line1 = scanner.nextLine().trim();\n            String line2 = scanner.nextLine().trim();\n            String[] arr1 = line1.equals(\"[]\") ? new String[0] : line1.substring(1, line1.length() - 1).split(\",\");\n            String[] arr2 = line2.equals(\"[]\") ? new String[0] : line2.substring(1, line2.length() - 1).split(\",\");\n            ListNode list1 = null, list2 = null;\n            if (arr1.length > 0) {\n                list1 = new ListNode(Integer.parseInt(arr1[0].trim()));\n                ListNode curr = list1;\n                for (int i = 1; i < arr1.length; i++) {\n                    curr.next = new ListNode(Integer.parseInt(arr1[i].trim()));\n                    curr = curr.next;\n                }\n            }\n            if (arr2.length > 0) {\n                list2 = new ListNode(Integer.parseInt(arr2[0].trim()));\n                ListNode curr = list2;\n                for (int i = 1; i < arr2.length; i++) {\n                    curr.next = new ListNode(Integer.parseInt(arr2[i].trim()));\n                    curr = curr.next;\n                }\n            }\n            Main main = new Main();\n            ListNode result = main.mergeTwoLists(list1, list2);\n            StringBuilder output = new StringBuilder(\"[\");\n            while (result != null) {\n                output.append(result.val);\n                result = result.next;\n                if (result != null) output.append(\",\");\n            }\n            output.append(\"]\");\n            System.out.println(output);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef mergeTwoLists(list1, list2):\n    # Write your code here\n    return None\n\nif __name__ == '__main__':\n    import sys, json\n    try:\n        arr1 = json.loads(sys.stdin.readline().strip())\n        arr2 = json.loads(sys.stdin.readline().strip())\n        def array_to_list(arr):\n            if not arr: return None\n            head = ListNode(arr[0])\n            curr = head\n            for val in arr[1:]:\n                curr.next = ListNode(val)\n                curr = curr.next\n            return head\n        list1 = array_to_list(arr1)\n        list2 = array_to_list(arr2)\n        result = mergeTwoLists(list1, list2)\n        output = []\n        while result:\n            output.append(result.val)\n            result = result.next\n        print(json.dumps(output, separators=(',', ':'))) # No spaces\n    except Exception:\n        print('Invalid input format')\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = val;\n *     this.next = next || null;\n * }\n */\nfunction mergeTwoLists(list1, list2) {\n    return null;\n}\n\nconst readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nlet lines = [];\nrl.on('line', (line) => {\n    lines.push(line.trim());\n    if (lines.length === 2) {\n        try {\n            const arr1 = JSON.parse(lines[0]);\n            const arr2 = JSON.parse(lines[1]);\n            function arrayToList(arr) {\n                if (!arr.length) return null;\n                let head = { val: arr[0], next: null };\n                let curr = head;\n                for (let i = 1; i < arr.length; i++) {\n                    curr.next = { val: arr[i], next: null };\n                    curr = curr.next;\n                }\n                return head;\n            }\n            const list1 = arrayToList(arr1);\n            const list2 = arrayToList(arr2);\n            let result = mergeTwoLists(list1, list2);\n            let output = [];\n            while (result) {\n                output.push(result.val);\n                result = result.next;\n            }\n            console.log(JSON.stringify(output));\n            rl.close();\n        } catch (e) {\n            console.log('Invalid input format');\n            process.exit(1);\n        }\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"bufio\"\n    \"os\"\n)\n\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {\n    dummy := &ListNode{}\n    curr := dummy\n    for list1 != nil && list2 != nil {\n        if list1.Val <= list2.Val {\n            curr.Next = list1\n            list1 = list1.Next\n        } else {\n            curr.Next = list2\n            list2 = list2.Next\n        }\n        curr = curr.Next\n    }\n    if list1 != nil {\n        curr.Next = list1\n    } else {\n        curr.Next = list2\n    }\n    return dummy.Next\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    var arr1, arr2 []int\n    if scanner.Scan() {\n        if err := json.Unmarshal([]byte(scanner.Text()), &arr1); err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n    } else {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    if scanner.Scan() {\n        if err := json.Unmarshal([]byte(scanner.Text()), &arr2); err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n    } else {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    var buildList = func(arr []int) *ListNode {\n        if len(arr) == 0 {\n            return nil\n        }\n        head := &ListNode{Val: arr[0]}\n        curr := head\n        for _, val := range arr[1:] {\n            curr.Next = &ListNode{Val: val}\n            curr = curr.Next\n        }\n        return head\n    }\n    list1 := buildList(arr1)\n    list2 := buildList(arr2)\n    result := mergeTwoLists(list1, list2)\n    output := []int{}\n    for result != nil {\n        output = append(output, result.Val)\n        result = result.Next\n    }\n    b, _ := json.Marshal(output)\n    fmt.Println(string(b))\n}",
      "C++": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy(0);\n        ListNode* curr = &dummy;\n        while (list1 && list2) {\n            if (list1->val <= list2->val) {\n                curr->next = list1;\n                list1 = list1->next;\n            } else {\n                curr->next = list2;\n                list2 = list2->next;\n            }\n            curr = curr->next;\n        }\n        curr->next = list1 ? list1 : list2;\n        return dummy.next;\n    }\n};\n\nint main() {\n    try {\n        string line1, line2;\n        if (!getline(cin, line1) || !getline(cin, line2)) throw runtime_error(\"Invalid input\");\n        // Handle empty lists explicitly\n        if (line1 == \"[]\" && line2 == \"[]\") {\n            cout << \"[]\" << endl;\n            return 0;\n        }\n        vector<int> arr1, arr2;\n        if (line1 != \"[]\") {\n            line1 = line1.substr(1, line1.length() - 2);\n            stringstream ss1(line1);\n            string token;\n            while (getline(ss1, token, ',')) arr1.push_back(stoi(token));\n        }\n        if (line2 != \"[]\") {\n            line2 = line2.substr(1, line2.length() - 2);\n            stringstream ss2(line2);\n            string token;\n            while (getline(ss2, token, ',')) arr2.push_back(stoi(token));\n        }\n        ListNode *list1 = nullptr, *list2 = nullptr;\n        if (!arr1.empty()) {\n            list1 = new ListNode(arr1[0]);\n            ListNode* curr = list1;\n            for (size_t i = 1; i < arr1.size(); i++) {\n                curr->next = new ListNode(arr1[i]);\n                curr = curr->next;\n            }\n        }\n        if (!arr2.empty()) {\n            list2 = new ListNode(arr2[0]);\n            ListNode* curr = list2;\n            for (size_t i = 1; i < arr2.size(); i++) {\n                curr->next = new ListNode(arr2[i]);\n                curr = curr->next;\n            }\n        }\n        Solution sol;\n        ListNode* result = sol.mergeTwoLists(list1, list2);\n        cout << \"[\";\n        ListNode* temp = result; // Keep pointer for cleanup\n        while (result) {\n            cout << result->val;\n            result = result->next;\n            if (result) cout << \",\";\n        }\n        cout << \"]\" << endl;\n        // Clean up memory for the merged list only\n        while (temp) {\n            ListNode* next = temp->next;\n            delete temp;\n            temp = next;\n        }\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; }\n}\n\npublic class Main {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (list1 != null && list2 != null) {\n            if (list1.val <= list2.val) {\n                curr.next = list1;\n                list1 = list1.next;\n            } else {\n                curr.next = list2;\n                list2 = list2.next;\n            }\n            curr = curr.next;\n        }\n        curr.next = list1 != null ? list1 : list2;\n        return dummy.next;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line1 = scanner.nextLine().trim();\n            String line2 = scanner.nextLine().trim();\n            String[] arr1 = line1.equals(\"[]\") ? new String[0] : line1.substring(1, line1.length() - 1).split(\",\");\n            String[] arr2 = line2.equals(\"[]\") ? new String[0] : line2.substring(1, line2.length() - 1).split(\",\");\n            ListNode list1 = null, list2 = null;\n            if (arr1.length > 0) {\n                list1 = new ListNode(Integer.parseInt(arr1[0].trim()));\n                ListNode curr = list1;\n                for (int i = 1; i < arr1.length; i++) {\n                    curr.next = new ListNode(Integer.parseInt(arr1[i].trim()));\n                    curr = curr.next;\n                }\n            }\n            if (arr2.length > 0) {\n                list2 = new ListNode(Integer.parseInt(arr2[0].trim()));\n                ListNode curr = list2;\n                for (int i = 1; i < arr2.length; i++) {\n                    curr.next = new ListNode(Integer.parseInt(arr2[i].trim()));\n                    curr = curr.next;\n                }\n            }\n            Main main = new Main();\n            ListNode result = main.mergeTwoLists(list1, list2);\n            StringBuilder output = new StringBuilder(\"[\");\n            while (result != null) {\n                output.append(result.val);\n                result = result.next;\n                if (result != null) output.append(\",\");\n            }\n            output.append(\"]\");\n            System.out.println(output);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef mergeTwoLists(list1, list2):\n    dummy = ListNode(0)\n    curr = dummy\n    while list1 and list2:\n        if list1.val <= list2.val:\n            curr.next = list1\n            list1 = list1.next\n        else:\n            curr.next = list2\n            list2 = list2.next\n        curr = curr.next\n    curr.next = list1 if list1 else list2\n    return dummy.next\n\nif __name__ == '__main__':\n    import sys, json\n    try:\n        arr1 = json.loads(sys.stdin.readline().strip())\n        arr2 = json.loads(sys.stdin.readline().strip())\n        def array_to_list(arr):\n            if not arr: return None\n            head = ListNode(arr[0])\n            curr = head\n            for val in arr[1:]:\n                curr.next = ListNode(val)\n                curr = curr.next\n            return head\n        list1 = array_to_list(arr1)\n        list2 = array_to_list(arr2)\n        result = mergeTwoLists(list1, list2)\n        output = []\n        while result:\n            output.append(result.val)\n            result = result.next\n        print(json.dumps(output, separators=(',', ':'))) # No spaces\n    except Exception:\n        print('Invalid input format')\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = val;\n *     this.next = next || null;\n * }\n */\nfunction mergeTwoLists(list1, list2) {\n    let dummy = { val: 0, next: null };\n    let curr = dummy;\n    while (list1 && list2) {\n        if (list1.val <= list2.val) {\n            curr.next = list1;\n            list1 = list1.next;\n        } else {\n            curr.next = list2;\n            list2 = list2.next;\n        }\n        curr = curr.next;\n    }\n    curr.next = list1 || list2;\n    return dummy.next;\n}\n\nconst readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nlet lines = [];\nrl.on('line', (line) => {\n    lines.push(line.trim());\n    if (lines.length === 2) {\n        try {\n            const arr1 = JSON.parse(lines[0]);\n            const arr2 = JSON.parse(lines[1]);\n            function arrayToList(arr) {\n                if (!arr.length) return null;\n                let head = { val: arr[0], next: null };\n                let curr = head;\n                for (let i = 1; i < arr.length; i++) {\n                    curr.next = { val: arr[i], next: null };\n                    curr = curr.next;\n                }\n                return head;\n            }\n            const list1 = arrayToList(arr1);\n            const list2 = arrayToList(arr2);\n            let result = mergeTwoLists(list1, list2);\n            let output = [];\n            while (result) {\n                output.push(result.val);\n                result = result.next;\n            }\n            console.log(JSON.stringify(output));\n            rl.close();\n        } catch (e) {\n            console.log('Invalid input format');\n            process.exit(1);\n        }\n    }\n});"
    }
  },
  {
    "title": "Two Sum",
    "description": "Given an array of integers **nums** and an integer **target**, return the indices of the two numbers such that they add up to the target.\n\nYou may assume that each input has **exactly one solution**, and you may not use the same element twice. The answer can be returned in any order.\n\n### Problem Statement\n\nYou are given an array of integers **nums** and an integer **target**. Find two distinct indices **i** and **j** such that **nums[i] + nums[j] = target**. Return the indices as an array **[i, j]**.\n\n### Input\n\n- **nums**: An array of integers (2 <= nums.length <= 10^4).\n- **target**: An integer representing the target sum (-10^9 <= target <= 10^9).\n- Each input is guaranteed to have exactly one valid solution.\n- Each element in **nums** is within the range (-10^9 <= nums[i] <= 10^9).\n- You may not use the same element twice.\n\n### Output\n\n- An array of two integers **[i, j]**, representing the indices of the two numbers in **nums** that add up to **target**.\n\n### Example\n\n**Input**: nums = [2, 7, 11, 15], target = 9  \n**Output**: [0, 1]  \n**Explanation**:  \nBecause nums[0] + nums[1] = 2 + 7 = 9, we return [0, 1].\n\n**Input**: nums = [3, 2, 4], target = 6  \n**Output**: [1, 2]  \n**Explanation**:  \nBecause nums[1] + nums[2] = 2 + 4 = 6, we return [1, 2].\n\n**Input**: nums = [3, 3], target = 6  \n**Output**: [0, 1]  \n**Explanation**:  \nBecause nums[0] + nums[1] = 3 + 3 = 6, we return [0, 1].\n\n### Notes\n\n- There is exactly one valid solution for each input.\n- The solution must be efficient, ideally O(n) time complexity, where n is the length of the input array.\n- The output indices must be distinct (i.e., i ≠ j).\n- The problem is commonly used to introduce hash table applications and two-pointer techniques.\n\n### Real-World Context\n\nThis problem models scenarios like finding pairs of transactions that sum to a specific amount in financial systems or identifying complementary components in inventory management systems.",
    "difficulty": "EASY",
    "tags": [
      "Google",
      "Amazon",
      "Array",
      "Hash Table"
    ],
    "constraints": [
      "- 2 <= nums.length <= 10^4",
      "- -10^9 <= nums[i] <= 10^9",
      "- -10^9 <= target <= 10^9",
      "- There is exactly one valid solution.",
      "- You may not use the same element twice (i.e., indices i and j must be different).",
      "- The output must be an array of two distinct indices [i, j].",
      "- Time complexity should be O(n) or better.",
      "- Space complexity should be O(n) for hash table approaches or O(1) for sorted array approaches (excluding output space)."
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "nums[0] + nums[1] = 2 + 7 = 9, so the indices [0, 1] are returned.\n\n**Visual Path**:\n- Iterate nums[0] = 2, need complement 7, store {2: 0}.\n- Iterate nums[1] = 7, find complement 2 in map, return [0, 1]."
      }
    ],
    "testcases": [
      {
        "input": "2,7,11,15:9",
        "output": "[0, 1]",
        "isHidden": false
      },
      {
        "input": "3,2,4:6",
        "output": "[1, 2]",
        "isHidden": false
      },
      {
        "input": "3,3:6",
        "output": "[0, 1]",
        "isHidden": false
      },
      {
        "input": "-1,-2,-3,-4:-7",
        "output": "[2, 3]",
        "isHidden": true
      },
      {
        "input": "1000000000,-1000000000:0",
        "output": "[0, 1]",
        "isHidden": true
      }
    ],
    "hints": [
      "1. **Brute Force Approach**: Can you check every pair of numbers in the array to see if they sum to the target? What is the time complexity of this approach?",
      "2. **Hash Table Insight**: For each number, what is the complement (target - nums[i])? Can you store numbers and their indices to find the complement quickly?",
      "3. **Optimization**: Instead of checking all pairs, can you process each element in one pass while storing information about previously seen numbers?",
      "4. **Edge Cases**: Consider cases where the array has the minimum size (2 elements) or where the numbers are equal (e.g., [3, 3] with target 6)."
    ],
    "editorial": "## Editorial: Two Sum\n\n### Problem Recap\n\nGiven an array of integers **nums** and an integer **target**, the task is to find two distinct indices **i** and **j** such that **nums[i] + nums[j] = target**. The problem guarantees exactly one valid solution, and the same element cannot be used twice.\n\n### Intuition\n\nTo find two numbers that sum to **target**, we can iterate through the array and, for each number **nums[i]**, determine the **complement** (i.e., **target - nums[i]**) that would complete the sum. The challenge is to find this complement efficiently.\n\n- A naive approach would check every pair of indices, leading to O(n²) time complexity.\n- A more efficient approach uses a hash table to store numbers and their indices, allowing us to check for the complement in O(1) time.\n\n### Approaches\n\n#### 1. Brute Force (Nested Loops)\n\n- **Idea**: Iterate through all pairs of indices (i, j) where i < j, and check if **nums[i] + nums[j] = target**.\n- **Steps**:\n  1. For each index **i** from 0 to **n-1**, iterate over **j** from **i+1** to **n-1**.\n  2. If **nums[i] + nums[j] = target**, return **[i, j]**.\n- **Time Complexity**: O(n²) due to nested loops.\n- **Space Complexity**: O(1) (excluding output).\n- **Pros**: Simple to implement, no extra space needed.\n- **Cons**: Inefficient for large arrays (e.g., n = 10^4).\n\n#### 2. Hash Table (One-Pass)\n\n- **Idea**: Use a hash table to store each number and its index as we iterate through the array. For each number, check if its complement exists in the hash table.\n- **Steps**:\n  1. Initialize an empty hash table (e.g., map or dictionary).\n  2. For each index **i**, compute **complement = target - nums[i]**.\n  3. If **complement** exists in the hash table, return **[hash[complement], i]**.\n  4. Otherwise, add **nums[i]** and its index **i** to the hash table.\n- **Time Complexity**: O(n) for one pass through the array, with O(1) lookups/insertions in the hash table.\n- **Space Complexity**: O(n) for the hash table.\n- **Pros**: Optimal time complexity, simple to implement.\n- **Cons**: Requires extra space.\n\n#### 3. Two-Pointer (Sorted Array)\n\n- **Idea**: Sort the array (with indices preserved) and use two pointers to find the pair summing to **target**.\n- **Steps**:\n  1. Create an array of pairs (value, index) and sort by value.\n  2. Use two pointers (left = 0, right = n-1).\n  3. While **left < right**:\n     - If **nums[left] + nums[right] = target**, return their original indices.\n     - If the sum is too small, increment **left**.\n     - If the sum is too large, decrement **right**.\n- **Time Complexity**: O(n log n) due to sorting.\n- **Space Complexity**: O(n) to store the array of pairs.\n- **Pros**: Space-efficient if sorting in-place is possible.\n- **Cons**: Slower than the hash table approach due to sorting.\n\n### Recommended Solution\n\nThe hash table (one-pass) approach is recommended for its O(n) time complexity and straightforward implementation. It balances efficiency and code simplicity, making it ideal for most use cases.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for the hash table approach, as we make one pass through the array with constant-time hash operations.\n- **Space Complexity**: O(n) for storing up to n elements in the hash table.\n- **Constraints Handling**:\n  - Array size: 2 <= n <= 10^4 ensures the array is non-empty and manageable.\n  - Value range: -10^9 <= nums[i], target <= 10^9 fits within 32-bit integers.\n  - Exactly one solution simplifies the logic.\n\n### Edge Cases\n\n- **Minimum array size**: nums = [3, 3], target = 6 → [0, 1].\n- **Large values**: nums = [-10^9, 10^9], target = 0 → [0, 1].\n- **Duplicate numbers**: nums = [3, 3, 4], target = 6 → [0, 1].\n- **Large array**: nums.length = 10^4 requires efficient O(n) solution.\n\n### Implementation Notes\n\n- Use appropriate data structures (e.g., HashMap in Java, unordered_map in C++, dict in Python) for O(1) average-case lookups.\n- Ensure indices are distinct (i ≠ j), which is handled naturally in the one-pass hash table approach.\n- Handle input validation if required by the platform (though constraints guarantee valid input).\n\n### Visual Explanation\n\nFor nums = [2, 7, 11, 15], target = 9:\n- At i = 0: nums[0] = 2, complement = 9 - 2 = 7. Hash table: {2: 0}.\n- At i = 1: nums[1] = 7, complement = 9 - 7 = 2. Found 2 in hash table at index 0 → return [0, 1].\n- Result: [0, 1].\n\nThis problem introduces hash table applications and is a great starting point for learning efficient data structure usage.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc twoSum(nums []int, target int) []int {\n    // Write your code here\n    return []int{}\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil || input == \"\" || !strings.Contains(input, \":\") {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    parts := strings.Split(input, \":\")\n    if len(parts) != 2 {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    numsStr := strings.Split(parts[0], \",\")\n    nums := make([]int, len(numsStr))\n    for i, s := range numsStr {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        nums[i] = num\n    }\n    target, err := strconv.Atoi(strings.TrimSpace(parts[1]))\n    if err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := twoSum(nums, target)\n    fmt.Printf(\"[%d, %d]\\n\", result[0], result[1])\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        // Write your code here\n        return {};\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line) || line.empty() || line.find(':') == string::npos) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        stringstream ss(line);\n        string numsStr;\n        getline(ss, numsStr, ':');\n        int target;\n        ss >> target;\n        stringstream numsStream(numsStr);\n        vector<int> nums;\n        int num;\n        char comma;\n        while (numsStream >> num) {\n            nums.push_back(num);\n            if (numsStream >> comma && comma != ',') {\n                cout << \"Invalid input format\" << endl;\n                return 1;\n            }\n        }\n        Solution sol;\n        vector<int> result = sol.twoSum(nums, target);\n        cout << \"[\" << result[0] << \", \" << result[1] << \"]\" << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Finds indices of two numbers in nums that add up to target.\n     * @param nums Array of integers\n     * @param target Target sum\n     * @return Array of two indices\n     */\n    public int[] twoSum(int[] nums, int target) {\n        // Write your code here\n        return new int[]{};\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String input = scanner.nextLine().trim();\n            if (input.isEmpty() || !input.contains(\":\")) {\n                System.out.println(\"Invalid input format\");\n                System.exit(1);\n            }\n            String[] parts = input.split(\":\");\n            String[] numsStr = parts[0].split(\",\");\n            int[] nums = new int[numsStr.length];\n            for (int i = 0; i < numsStr.length; i++) {\n                nums[i] = Integer.parseInt(numsStr[i].trim());\n            }\n            int target = Integer.parseInt(parts[1].trim());\n            Main main = new Main();\n            int[] result = main.twoSum(nums, target);\n            System.out.printf(\"[%d, %d]\\n\", result[0], result[1]);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def twoSum(self, nums, target):\n        \"\"\"\n        Finds indices of two numbers in nums that add up to target.\n        :param nums: List of integers\n        :param target: Target sum\n        :return: List of two indices\n        \"\"\"\n        # Write your code here\n        return []\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        if not line or \":\" not in line:\n            print(\"Invalid input format\")\n            sys.exit(1)\n        nums_str, target_str = line.split(\":\")\n        nums = [int(x) for x in nums_str.split(\",\")]\n        target = int(target_str.strip())\n        sol = Solution()\n        result = sol.twoSum(nums, target)\n        print(\"[%d, %d]\" % (result[0], result[1]))\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds indices of two numbers in nums that add up to target.\n * @param {number[]} nums - Array of integers\n * @param {number} target - Target sum\n * @return {number[]} - Indices of the two numbers\n */\nfunction twoSum(nums, target) {\n    // Write your code here\n    return [];\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        if (!line || !line.includes(\":\")) {\n            console.log(\"Invalid input format\");\n            process.exit(1);\n        }\n        const [numsStr, targetStr] = line.split(\":\");\n        const nums = numsStr.split(\",\").map(num => parseInt(num.trim()));\n        const target = parseInt(targetStr.trim());\n        const result = twoSum(nums, target);\n        console.log(`[${result[0]}, ${result[1]}]`);\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc twoSum(nums []int, target int) []int {\n    m := make(map[int]int)\n    for i, num := range nums {\n        complement := target - num\n        if j, exists := m[complement]; exists {\n            return []int{j, i}\n        }\n        m[num] = i\n    }\n    return []int{} // As per problem, this is unreachable\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil || input == \"\" || !strings.Contains(input, \":\") {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    parts := strings.Split(input, \":\")\n    if len(parts) != 2 {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    numsStr := strings.Split(parts[0], \",\")\n    nums := make([]int, len(numsStr))\n    for i, s := range numsStr {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        nums[i] = num\n    }\n    target, err := strconv.Atoi(strings.TrimSpace(parts[1]))\n    if err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := twoSum(nums, target)\n    fmt.Printf(\"[%d, %d]\\n\", result[0], result[1])\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> m;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (m.find(target - nums[i]) == m.end()) {\n                m[nums[i]] = i;\n            } else {\n                return {m[target - nums[i]], i};\n            }\n        }\n        return {}; // As per problem, this is unreachable\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line) || line.empty() || line.find(':') == string::npos) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        stringstream ss(line);\n        string numsStr;\n        getline(ss, numsStr, ':');\n        int target;\n        ss >> target;\n        stringstream numsStream(numsStr);\n        vector<int> nums;\n        int num;\n        char comma;\n        while (numsStream >> num) {\n            nums.push_back(num);\n            if (numsStream >> comma && comma != ',') {\n                cout << \"Invalid input format\" << endl;\n                return 1;\n            }\n        }\n        Solution sol;\n        vector<int> result = sol.twoSum(nums, target);\n        cout << \"[\" << result[0] << \", \" << result[1] << \"]\" << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n    /**\n     * Finds indices of two numbers in nums that add up to target.\n     * @param nums Array of integers\n     * @param target Target sum\n     * @return Array of two indices\n     */\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[]{map.get(complement), i};\n            }\n            map.put(nums[i], i);\n        }\n        return new int[]{}; // As per problem, this is unreachable\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String input = scanner.nextLine().trim();\n            if (input.isEmpty() || !input.contains(\":\")) {\n                System.out.println(\"Invalid input format\");\n                System.exit(1);\n            }\n            String[] parts = input.split(\":\");\n            String[] numsStr = parts[0].split(\",\");\n            int[] nums = new int[numsStr.length];\n            for (int i = 0; i < numsStr.length; i++) {\n                nums[i] = Integer.parseInt(numsStr[i].trim());\n            }\n            int target = Integer.parseInt(parts[1].trim());\n            Main main = new Main();\n            int[] result = main.twoSum(nums, target);\n            System.out.printf(\"[%d, %d]\\n\", result[0], result[1]);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def twoSum(self, nums, target):\n        \"\"\"\n        Finds indices of two numbers in nums that add up to target.\n        :param nums: List of integers\n        :param target: Target sum\n        :return: List of two indices\n        \"\"\"\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []  # As per problem, this is unreachable\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        if not line or \":\" not in line:\n            print(\"Invalid input format\")\n            sys.exit(1)\n        nums_str, target_str = line.split(\":\")\n        nums = [int(x) for x in nums_str.split(\",\")]\n        target = int(target_str.strip())\n        sol = Solution()\n        result = sol.twoSum(nums, target)\n        print(\"[%d, %d]\" % (result[0], result[1]))\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds indices of two numbers in nums that add up to target.\n * @param {number[]} nums - Array of integers\n * @param {number} target - Target sum\n * @return {number[]} - Indices of the two numbers\n */\nfunction twoSum(nums, target) {\n    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (map.has(complement)) {\n            return [map.get(complement), i];\n        }\n        map.set(nums[i], i);\n    }\n    return []; // As per problem, this is unreachable\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        if (!line || !line.includes(\":\")) {\n            console.log(\"Invalid input format\");\n            process.exit(1);\n        }\n        const [numsStr, targetStr] = line.split(\":\");\n        const nums = numsStr.split(\",\").map(num => parseInt(num.trim()));\n        const target = parseInt(targetStr.trim());\n        const result = twoSum(nums, target);\n        console.log(`[${result[0]}, ${result[1]}]`);\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    }
  },
  {
    "title": "Longest Common Prefix",
    "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string `\"\"`.\n\n### Problem Statement\n\nGiven an array of strings, find the longest string that is a prefix of all strings in the array. Return the empty string if no such prefix exists.\n\n### Input\n\n- **strs**: An array of strings (1 <= strs.length <= 200).\n- Each string in **strs** has length between 0 and 200.\n- All strings consist of lowercase English letters (a-z).\n\n### Output\n\n- A string representing the longest common prefix of all strings in the input array.\n- Return `\"\"` if there is no common prefix.\n\n### Example\n\n**Input**: strs = [\"flower\",\"flow\",\"flight\"]  \n**Output**: \"fl\"  \n**Explanation**:  \nAll strings start with \"fl\".\n\n**Input**: strs = [\"dog\",\"racecar\",\"car\"]  \n**Output**: \"\"  \n**Explanation**:  \nThere is no common prefix among the input strings.\n\n### Notes\n\n- The problem requires finding the longest prefix common to all strings.\n- The solution must be efficient, ideally O(S) time complexity, where S is the sum of all characters in all strings.\n- The problem is commonly used to introduce string manipulation and comparison techniques.\n\n### Real-World Context\n\nThis problem models scenarios like finding the common base path in URLs, the common prefix in file directories, or the shared starting sequence in DNA strings.",
    "difficulty": "EASY",
    "tags": [
      "Google",
      "Amazon",
      "String",
      "Trie"
    ],
    "constraints": [
      "- 1 <= strs.length <= 200",
      "- 0 <= strs[i].length <= 200",
      "- strs[i] consists of only lowercase English letters (a-z).",
      "- The solution should efficiently handle the maximum constraints."
    ],
    "examples": [
      {
        "input": "strs = [\"flower\", \"flow\", \"flight\"]",
        "output": "\"fl\"",
        "explanation": "All strings start with \"fl\".\n\nVisual Path:\n- Compare 'f' at index 0: all match.\n- Compare 'l' at index 1: all match.\n- Compare 'o' vs 'i' at index 2: mismatch. Return \"fl\"."
      }
    ],
    "testcases": [
      {
        "input": "flower,flow,flight",
        "output": "\"fl\"",
        "isHidden": false
      },
      {
        "input": "dog,racecar,car",
        "output": "\"\"",
        "isHidden": false
      },
      {
        "input": "apple,ape,apricot",
        "output": "\"ap\"",
        "isHidden": false
      },
      {
        "input": "a",
        "output": "\"a\"",
        "isHidden": true
      },
      {
        "input": "prefix,preference,premonition",
        "output": "\"pre\"",
        "isHidden": true
      }
    ],
    "hints": [
      "1. **Horizontal Scanning**: Compare the first string with the second to find their common prefix, then compare that prefix with the third string, and so on.",
      "2. **Vertical Scanning**: Compare characters at the same index across all strings until a mismatch is found.",
      "3. **Divide and Conquer**: Split the array into two halves, find the LCP of each half, and then find the LCP of the two results.",
      "4. **Binary Search**: Use binary search on the length of the prefix to find the maximum possible common prefix length.",
      "5. **Trie**: Build a trie of all strings and find the deepest node with a single child path."
    ],
    "editorial": "## Editorial: Longest Common Prefix\n\n### Problem Recap\n\nGiven an array of strings, find the longest string that is a prefix of all strings in the array. Return the empty string if no such prefix exists.\n\n### Intuition\n\nThe longest common prefix (LCP) is the longest string that appears at the beginning of all strings in the array. To find it efficiently, we can compare characters at the same position across all strings until a mismatch is found.\n\n### Approaches\n\n#### 1. Horizontal Scanning\n\n- **Idea**: Iteratively compare the current LCP with each string in the array to find the new LCP.\n- **Steps**:\n  1. Initialize LCP as the first string.\n  2. For each subsequent string, update LCP by comparing it with the current LCP.\n  3. If LCP becomes empty, return immediately.\n- **Time Complexity**: O(S), where S is the sum of all characters in all strings.\n- **Space Complexity**: O(1).\n- **Pros**: Simple to implement.\n- **Cons**: Worst-case when all strings are the same (O(S)).\n\n#### 2. Vertical Scanning\n\n- **Idea**: Compare characters at the same index across all strings until a mismatch is found.\n- **Steps**:\n  1. For each character index from 0 to min_len:\n     - Check if all strings have the same character at this index.\n     - If yes, append the character to LCP.\n     - If no, break and return current LCP.\n- **Time Complexity**: O(S).\n- **Space Complexity**: O(1).\n- **Pros**: More efficient in practice (stops early on mismatch).\n- **Cons**: Still O(S) in worst case.\n\n#### 3. Divide and Conquer\n\n- **Idea**: Split the array into two halves, find the LCP of each half, and then find the LCP of the two results.\n- **Steps**:\n  1. Divide the array into left and right halves.\n  2. Recursively find LCP of each half.\n  3. Find LCP of the two results.\n- **Time Complexity**: O(S).\n- **Space Complexity**: O(m log n), where m is the length of the LCP.\n- **Pros**: Parallelizable.\n- **Cons**: Overhead of recursion.\n\n#### 4. Binary Search\n\n- **Idea**: Use binary search on the length of the prefix to find the maximum possible common prefix length.\n- **Steps**:\n  1. Find the minimum string length (min_len).\n  2. Binary search between 0 and min_len to find the maximum LCP length.\n  3. For each mid value, check if the first string's prefix of length mid is common to all strings.\n- **Time Complexity**: O(S log m), where m is the minimum string length.\n- **Space Complexity**: O(1).\n- **Pros**: Efficient for large strings.\n- **Cons**: More complex implementation.\n\n### Recommended Solution\n\nThe vertical scanning approach is recommended for its simplicity and efficiency. It stops early when a mismatch is found and has optimal time complexity.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(S) for vertical scanning, where S is the sum of all characters in all strings.\n- **Space Complexity**: O(1) for storing the LCP.\n- **Constraints Handling**:\n  - Array size: 1 <= n <= 200 ensures the array is non-empty and manageable.\n  - String length: 0 <= len <= 200 fits within standard limits.\n\n### Edge Cases\n\n- **Empty array**: Not possible per constraints.\n- **Single string**: Return the string itself.\n- **Empty string in array**: Return \"\".\n- **All strings identical**: Return any string.\n- **No common prefix**: Return \"\".\n\n### Implementation Notes\n\n- Initialize LCP as \"\".\n- For each character index, check if all strings have the same character at that index.\n- Append the character to LCP if all match.\n- Break and return LCP on first mismatch.\n\n### Visual Explanation\n\nFor strs = [\"flower\",\"flow\",\"flight\"]:\n- Index 0: 'f' is common.\n- Index 1: 'l' is common.\n- Index 2: 'o' vs 'i' → mismatch. Return \"fl\".\n- Result: \"fl\".",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc longestCommonPrefix(strs []string) string {\n    // Write your code here\n    return \"\"\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil || input == \"\" {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    strs := strings.Split(input, \",\")\n    for i := range strs {\n        strs[i] = strings.TrimSpace(strs[i])\n    }\n    result := longestCommonPrefix(strs)\n    fmt.Printf(\"\\\"%s\\\"\\n\", result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        // Write your code here\n        return \"\";\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line) || line.empty()) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        stringstream ss(line);\n        vector<string> strs;\n        string s;\n        char comma;\n        while (getline(ss, s, ',')) {\n            size_t start = s.find_first_not_of(\" \\t\");\n            size_t end = s.find_last_not_of(\" \\t\");\n            if (start != string::npos && end != string::npos) {\n                strs.push_back(s.substr(start, end - start + 1));\n            } else {\n                strs.push_back(\"\");\n            }\n        }\n        Solution sol;\n        string result = sol.longestCommonPrefix(strs);\n        cout << \"\\\"\" << result << \"\\\"\" << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Finds the longest common prefix among an array of strings.\n     * @param strs Array of strings\n     * @return Longest common prefix\n     */\n    public String longestCommonPrefix(String[] strs) {\n        // Write your code here\n        return \"\";\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String input = scanner.nextLine().trim();\n            String[] strs = input.split(\",\");\n            for (int i = 0; i < strs.length; i++) {\n                strs[i] = strs[i].trim();\n            }\n            Main main = new Main();\n            String result = main.longestCommonPrefix(strs);\n            System.out.println(\"\\\"\" + result + \"\\\"\");\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        Finds the longest common prefix among an array of strings.\n        :param strs: List of strings\n        :return: Longest common prefix\n        \"\"\"\n        # Write your code here\n        return \"\"\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        strs = [s.strip('\"') for s in line.split(\",\")]\n        sol = Solution()\n        result = sol.longestCommonPrefix(strs)\n        print(f'\"{result}\"')\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds the longest common prefix among an array of strings.\n * @param {string[]} strs - Array of strings\n * @return {string} - Longest common prefix\n */\nfunction longestCommonPrefix(strs) {\n    // Write your code here\n    return \"\";\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const strs = line.split(\",\").map(s => s.trim());\n        const result = longestCommonPrefix(strs);\n        console.log(`\"${result}\"`);\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc longestCommonPrefix(strs []string) string {\n    if len(strs) == 0 {\n        return \"\"\n    }\n    prefix := strs[0]\n    for _, s := range strs[1:] {\n        for !strings.HasPrefix(s, prefix) {\n            prefix = prefix[:len(prefix)-1]\n            if prefix == \"\" {\n                return \"\"\n            }\n        }\n    }\n    return prefix\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil || input == \"\" {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    strs := strings.Split(input, \",\")\n    for i := range strs {\n        strs[i] = strings.TrimSpace(strs[i])\n    }\n    result := longestCommonPrefix(strs)\n    fmt.Printf(\"\\\"%s\\\"\\n\", result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        if (strs.empty()) return \"\";\n        string prefix = strs[0];\n        for (int i = 1; i < strs.size(); i++) {\n            while (strs[i].find(prefix) != 0) {\n                prefix = prefix.substr(0, prefix.length() - 1);\n                if (prefix.empty()) return \"\";\n            }\n        }\n        return prefix;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line) || line.empty()) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        stringstream ss(line);\n        vector<string> strs;\n        string s;\n        char comma;\n        while (getline(ss, s, ',')) {\n            size_t start = s.find_first_not_of(\" \\t\");\n            size_t end = s.find_last_not_of(\" \\t\");\n            if (start != string::npos && end != string::npos) {\n                strs.push_back(s.substr(start, end - start + 1));\n            } else {\n                strs.push_back(\"\");\n            }\n        }\n        Solution sol;\n        string result = sol.longestCommonPrefix(strs);\n        cout << \"\\\"\" << result << \"\\\"\" << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Finds the longest common prefix among an array of strings.\n     * @param strs Array of strings\n     * @return Longest common prefix\n     */\n    public String longestCommonPrefix(String[] strs) {\n        if (strs.length == 0) return \"\";\n        String prefix = strs[0];\n        for (int i = 1; i < strs.length; i++) {\n            while (strs[i].indexOf(prefix) != 0) {\n                prefix = prefix.substring(0, prefix.length() - 1);\n                if (prefix.isEmpty()) return \"\";\n            }\n        }\n        return prefix;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String input = scanner.nextLine().trim();\n            String[] strs = input.split(\",\");\n            for (int i = 0; i < strs.length; i++) {\n                strs[i] = strs[i].trim();\n            }\n            Main main = new Main();\n            String result = main.longestCommonPrefix(strs);\n            System.out.println(\"\\\"\" + result + \"\\\"\");\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        Finds the longest common prefix among an array of strings.\n        :param strs: List of strings\n        :return: Longest common prefix\n        \"\"\"\n        if not strs:\n            return \"\"\n        prefix = strs[0]\n        for s in strs[1:]:\n            while not s.startswith(prefix):\n                prefix = prefix[:-1]\n                if not prefix:\n                    return \"\"\n        return prefix\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        strs = [s.strip('\"') for s in line.split(\",\")]\n        sol = Solution()\n        result = sol.longestCommonPrefix(strs)\n        print('\"' + result + '\"')\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds the longest common prefix among an array of strings.\n * @param {string[]} strs - Array of strings\n * @return {string} - Longest common prefix\n */\nfunction longestCommonPrefix(strs) {\n    if (strs.length === 0) return \"\";\n    let prefix = strs[0];\n    for (let i = 1; i < strs.length; i++) {\n        while (strs[i].indexOf(prefix) !== 0) {\n            prefix = prefix.substring(0, prefix.length - 1);\n            if (prefix === \"\") return \"\";\n        }\n    }\n    return prefix;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const strs = line.split(\",\").map(s => s.trim());\n        const result = longestCommonPrefix(strs);\n        console.log(`\"${result}\"`);\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    }
  },
  {
    "title": "First Missing Positive",
    "description": "Given an unsorted integer array, find the smallest missing positive integer.\n\n### Problem Statement\n\nGiven an unsorted integer array `nums`, return the smallest missing positive integer. The solution must run in O(n) time and use O(1) auxiliary space.\n\n### Input\n\n- **nums**: An unsorted array of integers (1 <= nums.length <= 10^5).\n- Each element in `nums` is within the range (-2^31 <= nums[i] <= 2^31 - 1).\n\n### Output\n\n- An integer representing the smallest missing positive integer.\n\n### Example\n\n**Input**: nums = [1,2,0]  \n**Output**: 3  \n**Explanation**: The numbers 0, 1, and 2 are present. The smallest missing positive is 3.\n\n**Input**: nums = [3,4,-1,1]  \n**Output**: 2  \n**Explanation**: 1 is present but 2 is missing.\n\n**Input**: nums = [7,8,9,11,12]  \n**Output**: 1  \n**Explanation**: All numbers are positive but 1 is missing.\n\n### Notes\n\n- The solution must run in O(n) time and use O(1) extra space.\n- The problem requires handling both positive and negative numbers.\n- The smallest missing positive is always between 1 and n+1 (where n is the array length).\n\n### Real-World Context\n\nThis problem models scenarios like finding gaps in sequence numbers, detecting missing IDs in a database, or identifying skipped transaction numbers in financial systems.",
    "difficulty": "HARD",
    "tags": [
      "Google",
      "Amazon",
      "Array",
      "Hash Table"
    ],
    "constraints": [
      "- 1 <= nums.length <= 10^5",
      "- -2^31 <= nums[i] <= 2^31 - 1",
      "- Must run in O(n) time and use O(1) extra space"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 0]",
        "output": "3",
        "explanation": "Numbers 0,1,2 present. 3 is missing."
      }
    ],
    "testcases": [
      {
        "input": "[1,2,0]",
        "output": "3",
        "isHidden": false
      },
      {
        "input": "[3,4,-1,1]",
        "output": "2",
        "isHidden": false
      },
      {
        "input": "[7,8,9,11,12]",
        "output": "1",
        "isHidden": false
      },
      {
        "input": "[1,1]",
        "output": "2",
        "isHidden": true
      },
      {
        "input": "[-5,-3,-1]",
        "output": "1",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Think about how you would solve the problem if you could use extra space (like a hash table).",
      "2. The smallest missing positive must be between 1 and n+1, where n is the array size.",
      "3. Consider using the array indices themselves to mark the presence of numbers.",
      "4. The array can be modified in-place to track which positive integers are present."
    ],
    "editorial": "## Editorial: First Missing Positive\n\n### Problem Recap\n\nFind the smallest missing positive integer in an unsorted array with O(n) time and O(1) space constraints.\n\n### Intuition\n\nThe key insight is that the smallest missing positive must be in the range [1, n+1], where n is the array length. We can use the array itself as a pseudo-hash table by placing each positive integer i at index i-1.\n\n### Approaches\n\n#### 1. Index Mapping (Optimal)\n\n- **Idea**: Use the array indices to mark presence of numbers by placing each number in its correct position.\n- **Steps**:\n  1. First pass: Move each number to its correct position (if within 1..n)\n  2. Second pass: Find the first index where nums[i] ≠ i+1\n- **Time Complexity**: O(n) - each element is processed at most twice\n- **Space Complexity**: O(1) - in-place modification\n- **Pros**: Optimal time and space complexity\n- **Cons**: Modifies the original array\n\n#### 2. Boolean Array (Not Optimal)\n\n- **Idea**: Create a boolean array to mark presence (not suitable due to space constraints)\n- **Steps**:\n  1. Initialize a boolean array of size n\n  2. Mark positions for numbers in range\n  3. Scan for first missing\n- **Time Complexity**: O(n)\n- **Space Complexity**: O(n)\n- **Pros**: Simple to understand\n- **Cons**: Violates space constraint\n\n### Recommended Solution\n\nThe index mapping approach is recommended as it satisfies both time and space constraints while being efficient.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) - two passes through the array\n- **Space Complexity**: O(1) - no extra space used\n- **Constraints Handling**:\n  - Array size up to 10^5 is manageable with O(n) algorithm\n  - Integer range is handled by focusing only on positive numbers 1..n\n\n### Edge Cases\n\n- **All negatives**: Return 1\n- **Single element [1]**: Return 2\n- **Numbers exceed array size**: Ignore them\n- **Duplicate numbers**: Handle properly in placement\n\n### Implementation Notes\n\n1. First pass: Place each number in its correct position (nums[i] at index nums[i]-1)\n2. Second pass: Find first index where nums[i] ≠ i+1\n3. If all positions correct, return n+1",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc firstMissingPositive(nums []int) int {\n\t// Write your code here\n\treturn 1\n}\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tif scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tvar nums []int\n\t\terr := json.Unmarshal([]byte(line), &nums)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Invalid input format\")\n\t\t\treturn\n\t\t}\n\t\tresult := firstMissingPositive(nums)\n\t\tfmt.Println(result)\n\t}\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        // Write your code here\n        return 1;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        getline(cin, line);\n        \n        // Handle empty array case\n        if (line == \"[]\") {\n            cout << 1 << endl;\n            return 0;\n        }\n        \n        // Parse array input\n        line = line.substr(1, line.size() - 2); // Remove brackets\n        stringstream ss(line);\n        vector<int> nums;\n        string num;\n        while (getline(ss, num, ',')) {\n            nums.push_back(stoi(num));\n        }\n        \n        Solution sol;\n        int result = sol.firstMissingPositive(nums);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public int firstMissingPositive(int[] nums) {\n        // Write your code here\n        return 1;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String input = scanner.nextLine().trim();\n            // Handle empty array case\n            if (input.equals(\"[]\")) {\n                System.out.println(1);\n                return;\n            }\n            \n            // Parse array input\n            String numsStr = input.replaceAll(\"\\\\[\", \"\").replaceAll(\"\\\\]\", \"\");\n            String[] numStrings = numsStr.split(\",\");\n            int[] nums = new int[numStrings.length];\n            for (int i = 0; i < numStrings.length; i++) {\n                nums[i] = Integer.parseInt(numStrings[i].trim());\n            }\n            \n            Main main = new Main();\n            int result = main.firstMissingPositive(nums);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # Write your code here\n        return 1\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    import json\n    try:\n        line = sys.stdin.readline().strip()\n        nums = json.loads(line)\n        sol = Solution()\n        result = sol.firstMissingPositive(nums)\n        print(result)\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds the smallest missing positive integer\n * @param {number[]} nums - Unsorted integer array\n * @return {number} - Smallest missing positive\n */\nfunction firstMissingPositive(nums) {\n    // Write your code here\n    return 1;\n}\n\n// Input handling\nconst readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on('line', (line) => {\n    try {\n        const nums = JSON.parse(line);\n        const result = firstMissingPositive(nums);\n        console.log(result);\n    } catch (e) {\n        console.log('Invalid input format');\n        process.exit(1);\n    }\n    rl.close();\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc firstMissingPositive(nums []int) int {\n    n := len(nums)\n    \n    // First pass: place numbers in their correct positions\n    for i := 0; i < n; i++ {\n        for nums[i] > 0 && nums[i] <= n && nums[nums[i]-1] != nums[i] {\n            nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\n        }\n    }\n    \n    // Second pass: find first missing positive\n    for i := 0; i < n; i++ {\n        if nums[i] != i+1 {\n            return i + 1\n        }\n    }\n    \n    return n + 1\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    if scanner.Scan() {\n        line := scanner.Text()\n        var nums []int\n        err := json.Unmarshal([]byte(line), &nums)\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        result := firstMissingPositive(nums)\n        fmt.Println(result)\n    }\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        int n = nums.size();\n        \n        // First pass: place numbers in their correct positions\n        for (int i = 0; i < n; i++) {\n            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {\n                swap(nums[nums[i] - 1], nums[i]);\n            }\n        }\n        \n        // Second pass: find first missing positive\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != i + 1) {\n                return i + 1;\n            }\n        }\n        \n        return n + 1;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        getline(cin, line);\n        \n        // Handle empty array case\n        if (line == \"[]\") {\n            cout << 1 << endl;\n            return 0;\n        }\n        \n        // Parse array input\n        line = line.substr(1, line.size() - 2); // Remove brackets\n        stringstream ss(line);\n        vector<int> nums;\n        string num;\n        while (getline(ss, num, ',')) {\n            nums.push_back(stoi(num));\n        }\n        \n        Solution sol;\n        int result = sol.firstMissingPositive(nums);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public int firstMissingPositive(int[] nums) {\n        int n = nums.length;\n        \n        // First pass: place numbers in their correct positions\n        for (int i = 0; i < n; i++) {\n            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {\n                int temp = nums[nums[i] - 1];\n                nums[nums[i] - 1] = nums[i];\n                nums[i] = temp;\n            }\n        }\n        \n        // Second pass: find first missing positive\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != i + 1) {\n                return i + 1;\n            }\n        }\n        \n        return n + 1;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String input = scanner.nextLine().trim();\n            // Handle empty array case\n            if (input.equals(\"[]\")) {\n                System.out.println(1);\n                return;\n            }\n            \n            // Parse array input\n            String numsStr = input.replaceAll(\"\\\\[\", \"\").replaceAll(\"\\\\]\", \"\");\n            String[] numStrings = numsStr.split(\",\");\n            int[] nums = new int[numStrings.length];\n            for (int i = 0; i < numStrings.length; i++) {\n                nums[i] = Integer.parseInt(numStrings[i].trim());\n            }\n            \n            Main main = new Main();\n            int result = main.firstMissingPositive(nums);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        \n        # First pass: place numbers in their correct positions\n        for i in range(n):\n            while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n        \n        # Second pass: find first missing positive\n        for i in range(n):\n            if nums[i] != i + 1:\n                return i + 1\n        \n        return n + 1\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    import json\n    try:\n        line = sys.stdin.readline().strip()\n        nums = json.loads(line)\n        sol = Solution()\n        result = sol.firstMissingPositive(nums)\n        print(result)\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds the smallest missing positive integer\n * @param {number[]} nums - Unsorted integer array\n * @return {number} - Smallest missing positive\n */\nfunction firstMissingPositive(nums) {\n    const n = nums.length;\n    \n    // First pass: place numbers in their correct positions\n    for (let i = 0; i < n; i++) {\n        while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] !== nums[i]) {\n            [nums[nums[i] - 1], nums[i]] = [nums[i], nums[nums[i] - 1]];\n        }\n    }\n    \n    // Second pass: find first missing positive\n    for (let i = 0; i < n; i++) {\n        if (nums[i] !== i + 1) {\n            return i + 1;\n        }\n    }\n    \n    return n + 1;\n}\n\n// Input handling\nconst readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on('line', (line) => {\n    try {\n        const nums = JSON.parse(line);\n        const result = firstMissingPositive(nums);\n        console.log(result);\n    } catch (e) {\n        console.log('Invalid input format');\n        process.exit(1);\n    }\n    rl.close();\n});"
    }
  },
  {
    "title": "Find First and Last Position of Element in Sorted Array",
    "description": "Given an array of integers **nums** sorted in ascending order, find the starting and ending position of a given **target** value.\n\nYour algorithm's runtime complexity must be in the order of **O(log n)**. If the **target** is not found in the array, return **[-1, -1]**.\n\n### Problem Statement\n\nYou are given a sorted array **nums** and an integer **target**. Return the starting and ending indices of **target** in **nums** as an array **[first, last]**. If **target** is not found, return **[-1, -1]**.\n\n### Input\n\n- **nums**: A sorted array of integers (0 <= nums.length <= 10^5).\n- **target**: An integer to find (-10^9 <= target <= 10^9).\n- The array is sorted in ascending order, and may contain duplicates.\n\n### Output\n\n- An array of two integers **[first, last]**, representing the starting and ending indices of **target** in **nums**, or **[-1, -1]** if not found.\n\n### Example\n\n**Input**: nums = [5,7,7,8,8,10], target = 8  \n**Output**: [3, 4]  \n**Explanation**: The number 8 appears at indices 3 and 4.\n\n**Input**: nums = [5,7,7,8,8,10], target = 6  \n**Output**: [-1, -1]  \n**Explanation**: The number 6 does not appear in the array.\n\n**Input**: nums = [], target = 0  \n**Output**: [-1, -1]  \n**Explanation**: The array is empty, so the target is not found.\n\n### Notes\n\n- The solution must use a binary search approach to achieve O(log n) time complexity.\n- The problem tests understanding of binary search modifications for finding boundaries.\n\n### Real-World Context\n\nThis problem models scenarios like searching for a range of timestamps in a sorted log or finding the range of a value in a sorted database.",
    "difficulty": "MEDIUM",
    "tags": [
      "Google",
      "Amazon",
      "Array",
      "Binary Search"
    ],
    "constraints": [
      "- 0 <= nums.length <= 10^5",
      "- -10^9 <= nums[i], target <= 10^9",
      "- nums is sorted in ascending order.",
      "- Return [-1, -1] if target is not found.",
      "- Time complexity must be O(log n).",
      "- Space complexity should be O(1)."
    ],
    "examples": [
      {
        "input": "nums = [5, 7, 7, 8, 8, 10], target = 8",
        "output": "[3, 4]",
        "explanation": "The number 8 appears at indices 3 and 4, so [3, 4] is returned.\n\nVisual Path:\n- Binary search for leftmost 8: Find 8 at index 4, search left, find 8 at index 3.\n- Binary search for rightmost 8: Find 8 at index 3, search right, find 8 at index 4."
      }
    ],
    "testcases": [
      {
        "input": "5,7,7,8,8,10:8",
        "output": "[3, 4]",
        "isHidden": false
      },
      {
        "input": "5,7,7,8,8,10:6",
        "output": "[-1, -1]",
        "isHidden": false
      },
      {
        "input": ":0",
        "output": "[-1, -1]",
        "isHidden": false
      },
      {
        "input": "1:1",
        "output": "[0, 0]",
        "isHidden": true
      },
      {
        "input": "1,1,1,1:1",
        "output": "[0, 3]",
        "isHidden": true
      }
    ],
    "hints": [
      "1. **Binary Search Basics**: Since the array is sorted, can you use binary search to find the target?",
      "2. **Finding Boundaries**: How can you modify binary search to find the leftmost and rightmost occurrences of the target?",
      "3. **Two Searches**: Can you perform one binary search for the first position and another for the last position?",
      "4. **Edge Cases**: Consider empty arrays, single-element arrays, or targets not present in the array."
    ],
    "editorial": "## Editorial: Find First and Last Position of Element in Sorted Array\n\n### Problem Recap\n\nGiven a sorted array **nums** and a **target**, find the first and last indices where **target** appears. Return **[-1, -1]** if the target is not found. The solution must run in O(log n) time.\n\n### Intuition\n\nSince the array is sorted, binary search is ideal for achieving O(log n) complexity. However, we need the first and last occurrences of **target**, so we modify binary search to find the leftmost and rightmost positions separately.\n\n- **Standard Binary Search**: Finds any occurrence of the target.\n- **Modified Binary Search**: Adjusts the search to bias toward the leftmost or rightmost position by updating boundaries differently.\n\n### Approaches\n\n#### 1. Linear Scan\n\n- **Idea**: Iterate through the array to find the first and last occurrences of the target.\n- **Steps**:\n  1. Scan from left to find the first occurrence.\n  2. Scan from right to find the last occurrence.\n- **Time Complexity**: O(n) for scanning the array.\n- **Space Complexity**: O(1).\n- **Cons**: Too slow, does not meet O(log n) requirement.\n\n#### 2. Binary Search for Boundaries\n\n- **Idea**: Use two binary searches: one to find the leftmost occurrence and one for the rightmost.\n- **Steps**:\n  1. **Leftmost Search**:\n     - Perform binary search, but when target is found, continue searching in the left half to find the earliest occurrence.\n     - If nums[mid] == target, update result to mid and search left (high = mid - 1).\n  2. **Rightmost Search**:\n     - Similarly, when target is found, search right (low = mid + 1) to find the latest occurrence.\n  3. Return [first, last] or [-1, -1] if not found.\n- **Time Complexity**: O(log n) for two binary searches.\n- **Space Complexity**: O(1).\n- **Pros**: Meets time complexity requirement, efficient.\n\n### Recommended Solution\n\nThe binary search approach is recommended for its O(log n) time complexity. It’s efficient and straightforward once the boundary search logic is understood.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(log n) for two binary searches.\n- **Space Complexity**: O(1), as only a few variables are used.\n- **Constraints Handling**:\n  - Array size: 0 <= n <= 10^5 allows empty arrays.\n  - Value range: Fits within 32-bit integers.\n  - Sorted array: Enables binary search.\n\n### Edge Cases\n\n- **Empty array**: nums = [], target = 0 → [-1, -1].\n- **Single element**: nums = [1], target = 1 → [0, 0].\n- **Target not found**: nums = [1, 2, 3], target = 4 → [-1, -1].\n- **All elements same**: nums = [1, 1, 1], target = 1 → [0, 2].\n\n### Implementation Notes\n\n- Use two helper functions or inline binary searches for clarity.\n- Ensure boundary updates in binary search bias toward the leftmost or rightmost position.\n- Handle empty array explicitly to return [-1, -1].\n\n### Visual Explanation\n\nFor nums = [5,7,7,8,8,10], target = 8:\n- Leftmost search: Find 8 at mid, continue left to find index 3.\n- Rightmost search: Find 8 at mid, continue right to find index 4.\n- Result: [3, 4].",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc searchRange(nums []int, target int) []int {\n    // Write your code here\n    return []int{-1, -1}\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil || input == \"\" || !strings.Contains(input, \":\") {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    parts := strings.Split(input, \":\")\n    var nums []int\n    if parts[0] != \"\" {\n        numsStr := strings.Split(parts[0], \",\")\n        nums = make([]int, len(numsStr))\n        for i, s := range numsStr {\n            num, err := strconv.Atoi(strings.TrimSpace(s))\n            if err != nil {\n                fmt.Println(\"Invalid input format\")\n                return\n            }\n            nums[i] = num\n        }\n    }\n    target, err := strconv.Atoi(strings.TrimSpace(parts[1]))\n    if err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := searchRange(nums, target)\n    fmt.Printf(\"[%d, %d]\\n\", result[0], result[1])\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        // Write your code here\n        return {-1, -1};\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line) || line.empty() || line.find(':') == string::npos) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        stringstream ss(line);\n        string numsStr;\n        getline(ss, numsStr, ':');\n        int target;\n        ss >> target;\n        stringstream numsStream(numsStr);\n        vector<int> nums;\n        if (!numsStr.empty()) {\n            int num;\n            char comma;\n            while (numsStream >> num) {\n                nums.push_back(num);\n                if (numsStream >> comma && comma != ',') {\n                    cout << \"Invalid input format\" << endl;\n                    return 1;\n                }\n            }\n        }\n        Solution sol;\n        vector<int> result = sol.searchRange(nums, target);\n        cout << \"[\" << result[0] << \", \" << result[1] << \"]\" << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public int[] searchRange(int[] nums, int target) {\n        // Write your code here\n        return new int[]{-1, -1};\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String input = scanner.nextLine().trim();\n            if (input.isEmpty() || !input.contains(\":\")) {\n                System.out.println(\"Invalid input format\");\n                System.exit(1);\n            }\n            String[] parts = input.split(\":\");\n            String[] numsStr = parts[0].split(\",\");\n            int[] nums = new int[numsStr.length > 0 && !parts[0].isEmpty() ? numsStr.length : 0];\n            for (int i = 0; i < nums.length; i++) {\n                nums[i] = Integer.parseInt(numsStr[i].trim());\n            }\n            int target = Integer.parseInt(parts[1].trim());\n            Main main = new Main();\n            int[] result = main.searchRange(nums, target);\n            System.out.printf(\"[%d, %d]\\n\", result[0], result[1]);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def searchRange(self, nums, target):\n        \"\"\"\n        Finds first and last position of target in sorted array.\n        :param nums: List of integers\n        :param target: Target value\n        :return: List of two indices\n        \"\"\"\n        # Write your code here\n        return [-1, -1]\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        if not line or \":\" not in line:\n            print(\"Invalid input format\")\n            sys.exit(1)\n        nums_str, target_str = line.split(\":\")\n        nums = [int(x) for x in nums_str.split(\",\")] if nums_str else []\n        target = int(target_str.strip())\n        sol = Solution()\n        result = sol.searchRange(nums, target)\n        print(\"[%d, %d]\" % (result[0], result[1]))\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds first and last position of target in sorted array.\n * @param {number[]} nums - Sorted array of integers\n * @param {number} target - Target value\n * @return {number[]} - [first, last] indices\n */\nfunction searchRange(nums, target) {\n    // Write your code here\n    return [-1, -1];\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        if (!line || !line.includes(\":\")) {\n            console.log(\"Invalid input format\");\n            process.exit(1);\n        }\n        const [numsStr, targetStr] = line.split(\":\");\n        const nums = numsStr ? numsStr.split(\",\").map(num => parseInt(num.trim())) : [];\n        const target = parseInt(targetStr.trim());\n        const result = searchRange(nums, target);\n        console.log(`[${result[0]}, ${result[1]}]`);\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc searchRange(nums []int, target int) []int {\n    binarySearch := func(nums []int, target int, leftBias bool) int {\n        low, high, result := 0, len(nums)-1, -1\n        for low <= high {\n            mid := low + (high-low)/2\n            if nums[mid] == target {\n                result = mid\n                if leftBias {\n                    high = mid - 1\n                } else {\n                    low = mid + 1\n                }\n            } else if nums[mid] < target {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n        return result\n    }\n    return []int{binarySearch(nums, target, true), binarySearch(nums, target, false)}\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil || input == \"\" || !strings.Contains(input, \":\") {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    parts := strings.Split(input, \":\")\n    var nums []int\n    if parts[0] != \"\" {\n        numsStr := strings.Split(parts[0], \",\")\n        nums = make([]int, len(numsStr))\n        for i, s := range numsStr {\n            num, err := strconv.Atoi(strings.TrimSpace(s))\n            if err != nil {\n                fmt.Println(\"Invalid input format\")\n                return\n            }\n            nums[i] = num\n        }\n    }\n    target, err := strconv.Atoi(strings.TrimSpace(parts[1]))\n    if err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := searchRange(nums, target)\n    fmt.Printf(\"[%d, %d]\\n\", result[0], result[1])\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        auto binarySearch = [](vector<int>& nums, int target, bool leftBias) {\n            int low = 0, high = nums.size() - 1, result = -1;\n            while (low <= high) {\n                int mid = low + (high - low) / 2;\n                if (nums[mid] == target) {\n                    result = mid;\n                    if (leftBias) high = mid - 1;\n                    else low = mid + 1;\n                } else if (nums[mid] < target) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            }\n            return result;\n        };\n        return {binarySearch(nums, target, true), binarySearch(nums, target, false)};\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line) || line.empty() || line.find(':') == string::npos) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        stringstream ss(line);\n        string numsStr;\n        getline(ss, numsStr, ':');\n        int target;\n        ss >> target;\n        stringstream numsStream(numsStr);\n        vector<int> nums;\n        if (!numsStr.empty()) {\n            int num;\n            char comma;\n            while (numsStream >> num) {\n                nums.push_back(num);\n                if (numsStream >> comma && comma != ',') {\n                    cout << \"Invalid input format\" << endl;\n                    return 1;\n                }\n            }\n        }\n        Solution sol;\n        vector<int> result = sol.searchRange(nums, target);\n        cout << \"[\" << result[0] << \", \" << result[1] << \"]\" << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    // Helper method to perform binary search with left or right bias\n    private int binarySearch(int[] nums, int target, boolean leftBias) {\n        int low = 0, high = nums.length - 1, result = -1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (nums[mid] == target) {\n                result = mid;\n                if (leftBias) high = mid - 1;\n                else low = mid + 1;\n            } else if (nums[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return result;\n    }\n\n    // Main method to find the range of the target\n    public int[] searchRange(int[] nums, int target) {\n        return new int[]{binarySearch(nums, target, true), binarySearch(nums, target, false)};\n    }\n\n    // Main method for input/output handling\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String input = scanner.nextLine().trim();\n            if (input.isEmpty() || !input.contains(\":\")) {\n                System.out.println(\"Invalid input format\");\n                System.exit(1);\n            }\n            String[] parts = input.split(\":\");\n            String[] numsStr = parts[0].split(\",\");\n            int[] nums = new int[numsStr.length > 0 && !parts[0].isEmpty() ? numsStr.length : 0];\n            for (int i = 0; i < nums.length; i++) {\n                nums[i] = Integer.parseInt(numsStr[i].trim());\n            }\n            int target = Integer.parseInt(parts[1].trim());\n            Main main = new Main();\n            int[] result = main.searchRange(nums, target);\n            System.out.printf(\"[%d, %d]\\n\", result[0], result[1]);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def searchRange(self, nums, target):\n        def binary_search(nums, target, left_bias):\n            left, right = 0, len(nums) - 1\n            result = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    result = mid\n                    if left_bias:\n                        right = mid - 1\n                    else:\n                        left = mid + 1\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return result\n        return [binary_search(nums, target, True), binary_search(nums, target, False)]\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        if not line or \":\" not in line:\n            print(\"Invalid input format\")\n            sys.exit(1)\n        nums_str, target_str = line.split(\":\")\n        nums = [int(x) for x in nums_str.split(\",\")] if nums_str else []\n        target = int(target_str.strip())\n        sol = Solution()\n        result = sol.searchRange(nums, target)\n        print(\"[%d, %d]\" % (result[0], result[1]))\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds first and last position of target in sorted array.\n * @param {number[]} nums - Sorted array of integers\n * @param {number} target - Target value\n * @return {number[]} - [first, last] indices\n */\nfunction searchRange(nums, target) {\n    const binarySearch = (nums, target, leftBias) => {\n        let low = 0, high = nums.length - 1, result = -1;\n        while (low <= high) {\n            let mid = Math.floor((low + high) / 2);\n            if (nums[mid] === target) {\n                result = mid;\n                if (leftBias) high = mid - 1;\n                else low = mid + 1;\n            } else if (nums[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return result;\n    };\n    return [binarySearch(nums, target, true), binarySearch(nums, target, false)];\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        if (!line || !line.includes(\":\")) {\n            console.log(\"Invalid input format\");\n            process.exit(1);\n        }\n        const [numsStr, targetStr] = line.split(\":\");\n        const nums = numsStr ? numsStr.split(\",\").map(num => parseInt(num.trim())) : [];\n        const target = parseInt(targetStr.trim());\n        const result = searchRange(nums, target);\n        console.log(`[${result[0]}, ${result[1]}]`);\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    }
  },
  {
    "title": "Valid Palindrome",
    "description": "A phrase is a **palindrome** if, after converting all uppercase letters to lowercase and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters (a-z) and numbers (0-9).\n\n### Problem Statement\nGiven a string **s**, determine if it is a palindrome after:\n1. Converting all uppercase letters to lowercase.\n2. Removing all non-alphanumeric characters (e.g., punctuation, spaces, symbols).\nReturn **true** if the resulting string is a palindrome, **false** otherwise.\n\n### Input\n- **s**: A string containing printable ASCII characters (1 <= s.length <= 2 x 10^5).\n\n### Output\n- A boolean: **true** if the processed string is a palindrome, **false** otherwise.\n\n### Example\n**Input**: s = \"A man, a plan, a canal: Panama\"  \n**Output**: true  \n**Explanation**:  \nAfter processing:\n- Convert to lowercase: \"a man, a plan, a canal: panama\"\n- Remove non-alphanumeric: \"amanaplanacanalpanama\"\n- This string reads the same forward and backward, so it's a palindrome.\n\n**Input**: s = \"race a car\"  \n**Output**: false  \n**Explanation**:  \nAfter processing: \"raceacar\" is not a palindrome.\n\n### Notes\n- The input string may contain spaces, punctuation, or special characters.\n- Case sensitivity is ignored (e.g., 'A' equals 'a').\n- An empty string or single character is a palindrome.\n- Optimize for O(n) time complexity, where n is the string length.\n- Consider O(1) extra space (excluding input/output).\n\n### Real-World Context\nThis problem is relevant in text processing, such as validating symmetric identifiers (e.g., usernames, product codes) or checking data integrity in systems ignoring case and formatting.",
    "difficulty": "EASY",
    "tags": [
      "Tcs",
      "Oracle",
      "String",
      "Two Pointers",
      "Character Processing"
    ],
    "constraints": [
      "- 1 <= s.length <= 2 x 10^5",
      "- s consists of printable ASCII characters (e.g., letters, numbers, punctuation, spaces).",
      "- Output is a boolean (true/false).",
      "- Time complexity should be O(n) or better, where n is the string length.",
      "- Space complexity should be O(1), excluding input/output storage."
    ],
    "examples": [
      {
        "input": "s = \"A man, a plan, a canal: Panama\"",
        "output": "true",
        "explanation": "After processing the input:\n1. Original: \"A man, a plan, a canal: Panama\"\n2. Lowercase: \"a man, a plan, a canal: panama\"\n3. Remove non-alphanumeric: \"amanaplanacanalpanama\"\n4. Check: Reads the same forward and backward.\n\n**Two-Pointer Process**:\n- Compare 'a' (index 0) and 'a' (last index) -> match\n- Compare 'm' and 'm' -> match\n- Continue until all characters match."
      }
    ],
    "testcases": [
      {
        "input": "A man, a plan, a canal: Panama",
        "output": "true",
        "isHidden": false
      },
      {
        "input": "race a car",
        "output": "false",
        "isHidden": false
      },
      {
        "input": " ",
        "output": "true",
        "isHidden": false
      },
      {
        "input": "Aa1",
        "output": "false",
        "isHidden": true
      },
      {
        "input": "AAAAAAAAAAaaaaaaaaaa",
        "output": "true",
        "isHidden": true
      },
      {
        "input": "Are we not pure? “No, sir!” Panama’s moody Noriega brags. “It is garbage!” Irony dooms a man—a prisoner up to new era.",
        "output": "true",
        "isHidden": false
      },
      {
        "input": "Dennis, Nell, Edna, Leon, Nedra, Anita, Rolf, Nora, Alice, Carol, Leo, Jane, Reed, Dena, Dale, Basil, Rae, Penny, Lana, Dave, Denny, Lena, Ida, Bernadette, Ben, Ray, Lila, Nina, Jo, Ira, Mara, Sara, Mario, Jan, Ina, Lily, Arne, Bette, Dan, Reba, Diane, Lynn, Ed, Eva, Dana, Lynne, Pearl, Isabel, Ada, Ned, Dee, Rena, Joel, Lora, Cecil, Aaron, Flora, Tina, Arden, Noel, and Ellen sinned.",
        "output": "true",
        "isHidden": false
      },
      {
        "input": "Oozy rat in a sanitary zoo cage.",
        "output": "false",
        "isHidden": false
      }
    ],
    "hints": [
      "1. **Preprocessing**: How can you clean the string to keep only alphanumeric characters and make it case-insensitive?",
      "2. **Palindrome Check**: Consider comparing characters from both ends of the processed string. How would you handle this efficiently?",
      "3. **Two Pointers**: Use two pointers (left and right) moving toward the center. What should you do when characters don't match?",
      "4. **In-Place Check**: Can you check the palindrome property without creating a new string, by skipping non-alphanumeric characters during iteration?"
    ],
    "editorial": "## Editorial: Valid Palindrome\n\n### Problem Recap\nThe task is to determine if a string is a palindrome after converting it to lowercase and removing non-alphanumeric characters. A palindrome reads the same forward and backward.\n\n### Intuition\nTo check if a string is a palindrome:\n1. **Preprocess**: Convert the string to lowercase and filter out non-alphanumeric characters (e.g., spaces, punctuation).\n2. **Verify**: Compare characters from both ends toward the center. If all pairs match, it's a palindrome.\n\nThe challenge is to do this efficiently, ideally in O(n) time and O(1) space, while handling edge cases like empty strings or strings with only non-alphanumeric characters.\n\n### Approaches\n\n#### 1. Two Pointers (In-Place)\n- **Idea**: Use two pointers (left and right) to scan the string, skipping non-alphanumeric characters and comparing valid characters.\n- **Steps**:\n  1. Initialize 'left = 0', 'right = s.length - 1'.\n  2. While 'left < right':\n     - Skip non-alphanumeric characters at 'left' (increment until alphanumeric or 'left >= right').\n     - Skip non-alphanumeric characters at 'right' (decrement until alphanumeric or 'left >= right').\n     - Compare 's[left].toLowerCase()' and 's[right].toLowerCase()'. If they differ, return 'false'.\n     - Move 'left++', 'right--'.\n  3. Return 'true' if the loop completes.\n- **Time Complexity**: O(n) for one pass through the string.\n- **Space Complexity**: O(1) as only pointers are used.\n- **Pros**: Most efficient in space and time, no extra string creation.\n- **Cons**: Slightly more complex due to in-place skipping.\n\n#### 2. Preprocess and Compare\n- **Idea**: Create a new string with only lowercase alphanumeric characters, then check if it's a palindrome.\n- **Steps**:\n  1. Filter 's' to keep only alphanumeric characters (e.g., using regex or character checks) and convert to lowercase.\n  2. Use two pointers or compare the string with its reverse.\n- **Time Complexity**: O(n) for preprocessing and checking.\n- **Space Complexity**: O(n) for the new string.\n- **Pros**: Simpler to implement.\n- **Cons**: Uses extra space, less efficient for large strings.\n\n#### 3. Array Reversal\n- **Idea**: Similar to preprocessing, but reverse the filtered string and compare it with the original filtered string.\n- **Steps**:\n  1. Create a filtered string (lowercase, alphanumeric only).\n  2. Check if 'filtered === filtered.reverse()'.\n- **Time Complexity**: O(n) for preprocessing and reversal.\n- **Space Complexity**: O(n) for the new string.\n- **Pros**: Very intuitive.\n- **Cons**: Inefficient due to string copying and reversal.\n\n### Recommended Solution\nThe in-place two-pointer approach is recommended for its O(n) time and O(1) space complexity, aligning with the problem's constraints and optimizing performance for large inputs.\n\n### Complexity Analysis\n- **Time Complexity**: O(n) for a single pass through the string.\n- **Space Complexity**: O(1) using only two pointers.\n- **Constraints Handling**: Handles strings up to 2 x 10^5 efficiently and processes all ASCII characters correctly.\n\n### Edge Cases\n- **Empty String**: Returns 'true' (empty string is a palindrome).\n- **Single Character**: Returns 'true' (single character is a palindrome).\n- **Non-Alphanumeric Only**: E.g., \"!@#\", returns 'true' (empty after filtering).\n- **Mixed Case**: E.g., \"RaCeCaR\", returns 'true' after lowercase conversion.\n- **Large Input**: E.g., 2 x 10^5 characters, requires efficient O(n) solution.\n\n### Implementation Notes\n- Use language-specific functions to check alphanumeric characters (e.g., 'isalnum()' in Python, 'Character.isLetterOrDigit()' in Java).\n- Ensure case-insensitive comparison (e.g., 'toLowerCase()' in JavaScript/Java).\n- Handle edge cases explicitly to avoid index out-of-bounds errors.\n\n### Visual Explanation\nFor s = \"A man, a plan, a canal: Panama\":\n- Processed: \"amanaplanacanalpanama\"\n- Two pointers:\n  - left = 'a', right = 'a' -> match\n  - left = 'm', right = 'm' -> match\n  - Continue until left >= right\n- Result: 'true'\n\nThis problem teaches string manipulation, two-pointer techniques, and efficient character processing, making it a great exercise for string-handling skills.",
    "codeSnippets": {
      "GO": "package main\r\n\r\nimport (\r\n    \"bufio\"\r\n    \"fmt\"\r\n    \"os\"\r\n    \"strings\"\r\n    \"unicode\"\r\n)\r\n\r\nfunc isPalindrome(s string) bool {\r\n    // Write your Code here:\r\n    var cleaned strings.Builder\r\n    for _, r := range s {\r\n        if unicode.IsLetter(r) || unicode.IsDigit(r) {\r\n            cleaned.WriteRune(unicode.ToLower(r))\r\n        }\r\n    }\r\n    cleanedStr := cleaned.String()\r\n    \r\n    // Two-pointer palindrome check\r\n    left, right := 0, len(cleanedStr)-1\r\n    for left < right {\r\n        if cleanedStr[left] != cleanedStr[right] {\r\n            return false\r\n        }\r\n        left++\r\n        right--\r\n    }\r\n    return true\r\n}\r\n\r\nfunc main() {\r\n    scanner := bufio.NewScanner(os.Stdin)\r\n    var input strings.Builder\r\n    // Read all input until EOF\r\n    for scanner.Scan() {\r\n        input.WriteString(scanner.Text())\r\n    }\r\n    result := isPalindrome(input.String())\r\n    fmt.Println(result) // Output \"true\" (lowercase)\r\n}",
      "C++": "#include <iostream>\r\n#include <cctype>\r\nusing namespace std;\r\n\r\nclass Solution {\r\npublic:\r\n    bool isPalindrome(string s) {\r\n        // Write your Code here:\r\n        int left = 0, right = s.length() - 1;\r\n        while (left < right) {\r\n            while (left < right && !isalnum(s[left])) left++;\r\n            while (left < right && !isalnum(s[right])) right--;\r\n            if (tolower(s[left]) != tolower(s[right])) return false;\r\n            left++;\r\n            right--;\r\n        }\r\n        return true;\r\n    }\r\n};\r\n\r\nint main() {\r\n    string s;\r\n    getline(cin, s);\r\n    Solution sol;\r\n    cout << (sol.isPalindrome(s) ? \"true\" : \"false\") << endl;\r\n    return 0;\r\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Checks if a string is a palindrome after converting to lowercase and removing non-alphanumeric characters.\n     * @param s Input string (1 <= s.length <= 2e5)\n     * @return True if palindrome, false otherwise\n     */\n    public boolean isPalindrome(String s) {\n        // Write your Code here:\n        int left = 0;\n        int right = s.length() - 1;\n        \n        while (left < right) {\n            // Skip non-alphanumeric characters from left\n            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {\n                left++;\n            }\n            // Skip non-alphanumeric characters from right\n            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {\n                right--;\n            }\n            // Compare characters (case-insensitive)\n            if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        Main main = new Main();\n        boolean result = main.isPalindrome(input);\n        System.out.println(result ? \"true\" : \"false\");\n        scanner.close();\n    }\n}",
      "PYTHON": "class Solution:\n    def isPalindrome(self, s):\n        \"\"\"\n        Checks if a string is a palindrome after converting to lowercase and removing non-alphanumeric characters.\n        :param s: Input string (1 <= s.length <= 2e5)\n        :return: True if palindrome, false otherwise\n        \"\"\"\n        # Write your Code here:\n        left, right = 0, len(s) - 1\n        \n        while left < right:\n            # Skip non-alphanumeric characters from left\n            while left < right and not s[left].isalnum():\n                left += 1\n            # Skip non-alphanumeric characters from right\n            while left < right and not s[right].isalnum():\n                right -= 1\n            # Compare characters (case-insensitive)\n            if s[left].lower() != s[right].lower():\n                return False\n            left += 1\n            right -= 1\n        \n        return True\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    s = sys.stdin.readline().strip()\n    sol = Solution()\n    result = sol.isPalindrome(s)\n    print(str(result).lower())",
      "JAVASCRIPT": "/**\n * Checks if a string is a palindrome after converting to lowercase and removing non-alphanumeric characters.\n * @param {string} s - Input string (1 <= s.length <= 2e5)\n * @return {boolean} - True if palindrome, false otherwise\n */\nfunction isPalindrome(s) {\n  // Write your Code here:\n    let left = 0;\n    let right = s.length - 1;\n    \n    while (left < right) {\n        // Skip non-alphanumeric characters from left\n        while (left < right && !/[a-zA-Z0-9]/.test(s[left])) {\n            left++;\n        }\n        // Skip non-alphanumeric characters from right\n        while (left < right && !/[a-zA-Z0-9]/.test(s[right])) {\n            right--;\n        }\n        // Compare characters (case-insensitive)\n        if (s[left].toLowerCase() !== s[right].toLowerCase()) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    const result = isPalindrome(line);\n    console.log(result ? \"true\" : \"false\");\n    rl.close();\n});"
    },
    "referenceSolutions": {
      "GO": "package main\r\n\r\nimport (\r\n    \"bufio\"\r\n    \"fmt\"\r\n    \"os\"\r\n    \"strings\"\r\n    \"unicode\"\r\n)\r\n\r\nfunc isPalindrome(s string) bool {\r\n    // Preprocess: keep only alphanumeric, convert to lowercase\r\n    var cleaned strings.Builder\r\n    for _, r := range s {\r\n        if unicode.IsLetter(r) || unicode.IsDigit(r) {\r\n            cleaned.WriteRune(unicode.ToLower(r))\r\n        }\r\n    }\r\n    cleanedStr := cleaned.String()\r\n    \r\n    // Two-pointer palindrome check\r\n    left, right := 0, len(cleanedStr)-1\r\n    for left < right {\r\n        if cleanedStr[left] != cleanedStr[right] {\r\n            return false\r\n        }\r\n        left++\r\n        right--\r\n    }\r\n    return true\r\n}\r\n\r\nfunc main() {\r\n    scanner := bufio.NewScanner(os.Stdin)\r\n    var input strings.Builder\r\n    // Read all input until EOF\r\n    for scanner.Scan() {\r\n        input.WriteString(scanner.Text())\r\n    }\r\n    result := isPalindrome(input.String())\r\n    fmt.Println(result) // Output \"true\" (lowercase)\r\n}",
      "C++": "#include <iostream>\r\n#include <cctype>\r\nusing namespace std;\r\n\r\nclass Solution {\r\npublic:\r\n    bool isPalindrome(string s) {\r\n        int left = 0, right = s.length() - 1;\r\n        while (left < right) {\r\n            while (left < right && !isalnum(s[left])) left++;\r\n            while (left < right && !isalnum(s[right])) right--;\r\n            if (tolower(s[left]) != tolower(s[right])) return false;\r\n            left++;\r\n            right--;\r\n        }\r\n        return true;\r\n    }\r\n};\r\n\r\nint main() {\r\n    string s;\r\n    getline(cin, s);\r\n    Solution sol;\r\n    cout << (sol.isPalindrome(s) ? \"true\" : \"false\") << endl;\r\n    return 0;\r\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Checks if a string is a palindrome after converting to lowercase and removing non-alphanumeric characters.\n     * @param s Input string (1 <= s.length <= 2e5)\n     * @return True if palindrome, false otherwise\n     */\n    public boolean isPalindrome(String s) {\n        int left = 0;\n        int right = s.length() - 1;\n        \n        while (left < right) {\n            // Skip non-alphanumeric characters from left\n            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {\n                left++;\n            }\n            // Skip non-alphanumeric characters from right\n            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {\n                right--;\n            }\n            // Compare characters (case-insensitive)\n            if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        Main main = new Main();\n        boolean result = main.isPalindrome(input);\n        System.out.println(result ? \"true\" : \"false\");\n        scanner.close();\n    }\n}",
      "PYTHON": "class Solution:\n    def isPalindrome(self, s):\n        \"\"\"\n        Checks if a string is a palindrome after converting to lowercase and removing non-alphanumeric characters.\n        :param s: Input string (1 <= s.length <= 2e5)\n        :return: True if palindrome, false otherwise\n        \"\"\"\n        left, right = 0, len(s) - 1\n        \n        while left < right:\n            # Skip non-alphanumeric characters from left\n            while left < right and not s[left].isalnum():\n                left += 1\n            # Skip non-alphanumeric characters from right\n            while left < right and not s[right].isalnum():\n                right -= 1\n            # Compare characters (case-insensitive)\n            if s[left].lower() != s[right].lower():\n                return False\n            left += 1\n            right -= 1\n        \n        return True\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    s = sys.stdin.readline().strip()\n    sol = Solution()\n    result = sol.isPalindrome(s)\n    print(str(result).lower())",
      "JAVASCRIPT": "/**\n * Checks if a string is a palindrome after converting to lowercase and removing non-alphanumeric characters.\n * @param {string} s - Input string (1 <= s.length <= 2e5)\n * @return {boolean} - True if palindrome, false otherwise\n */\nfunction isPalindrome(s) {\n    let left = 0;\n    let right = s.length - 1;\n    \n    while (left < right) {\n        // Skip non-alphanumeric characters from left\n        while (left < right && !/[a-zA-Z0-9]/.test(s[left])) {\n            left++;\n        }\n        // Skip non-alphanumeric characters from right\n        while (left < right && !/[a-zA-Z0-9]/.test(s[right])) {\n            right--;\n        }\n        // Compare characters (case-insensitive)\n        if (s[left].toLowerCase() !== s[right].toLowerCase()) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    const result = isPalindrome(line);\n    console.log(result ? \"true\" : \"false\");\n    rl.close();\n});"
    }
  },
  {
    "title": "N-Queens",
    "description": "The **n-queens** puzzle is the problem of placing **n** queens on an **n×n** chessboard such that no two queens attack each other.\n\nGiven an integer **n**, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens' placement, where **'Q'** and **'.'** indicate a queen and an empty space, respectively.\n\n### Problem Statement\n\nPlace **n** queens on an **n×n** chessboard so that no two queens can attack each other (i.e., no two queens share the same row, column, or diagonal). Return all possible configurations as a list of boards, where each board is represented as a list of strings.\n\n### Input\n\n- **n**: An integer representing the size of the chessboard (1 <= n <= 9).\n\n### Output\n\n- A list of all distinct solutions, where each solution is a list of strings representing the board configuration.\n\n### Example\n\n**Input**: n = 4  \n**Output**: [  \n  [\".Q..\", \"...Q\", \"Q...\", \"..Q.\"],  \n  [\"..Q.\", \"Q...\", \"...Q\", \".Q..\"]  \n]  \n**Explanation**: There are two distinct solutions for n = 4, as shown.\n\n**Input**: n = 1  \n**Output**: [[\"Q\"]]  \n**Explanation**: A single queen can be placed on a 1×1 board.\n\n### Notes\n\n- Use backtracking to explore all possible placements.\n- Queens cannot share rows, columns, or diagonals (including both 45° and 135° diagonals).\n- The solution should handle small n efficiently (n <= 9).\n\n### Real-World Context\n\nThis problem models constraint satisfaction problems, such as scheduling or resource allocation with mutual exclusion constraints.",
    "difficulty": "HARD",
    "tags": [
      "Google",
      "Amazon",
      "Backtracking",
      "Chess"
    ],
    "constraints": [
      "- 1 <= n <= 9",
      "- Return a list of all distinct solutions.",
      "- Each solution is a list of strings, with 'Q' for queens and '.' for empty spaces.",
      "- Time complexity should be reasonable for n <= 9 (exponential due to combinatorial nature).",
      "- Space complexity is O(n^2) for the board and recursion stack."
    ],
    "examples": [
      {
        "input": "n = 4",
        "output": "[['.Q..','...Q','Q...','..Q.'],['..Q.','Q...','...Q','.Q..']]",
        "explanation": "Two distinct solutions for n = 4.\n\nVisual Path:\n- Place queen in row 0, column 1, recurse to row 1, etc., to get first solution.\n- Backtrack and try other placements for second solution."
      }
    ],
    "testcases": [
      {
        "input": "4",
        "output": "[['.Q..','...Q','Q...','..Q.'],['..Q.','Q...','...Q','.Q..']]",
        "isHidden": false
      },
      {
        "input": "1",
        "output": "[['Q']]",
        "isHidden": false
      },
      {
        "input": "2",
        "output": "[]",
        "isHidden": false
      },
      {
        "input": "3",
        "output": "[]",
        "isHidden": true
      },
      {
        "input": "5",
        "output": "[['Q....','..Q..','....Q','.Q...','...Q.'],['Q....','...Q.','.Q...','....Q','..Q..'],...]",
        "isHidden": true
      }
    ],
    "hints": [
      "1. **Brute Force**: Can you try placing a queen in each cell and checking for conflicts?",
      "2. **Row-by-Row Backtracking**: Can you place queens row by row, ensuring no conflicts in columns or diagonals?",
      "3. **Track Conflicts**: How can you efficiently track occupied columns and diagonals?",
      "4. **Edge Cases**: Consider n = 1 or n = 2 (no solutions for n = 2)."
    ],
    "editorial": "## Editorial: N-Queens\n\n### Problem Recap\n\nPlace **n** queens on an **n×n** chessboard so no two queens attack each other, and return all distinct solutions as board configurations.\n\n### Intuition\n\nThis is a classic backtracking problem. Since each row must contain exactly one queen, we can place queens row by row, ensuring no conflicts in columns or diagonals.\n\n- **Backtracking**: Try placing a queen in each column of the current row, check for validity, and recurse to the next row.\n- **Conflict Tracking**: Use sets to track occupied columns, main diagonals (row - col), and anti-diagonals (row + col).\n\n### Approaches\n\n#### 1. Brute Force\n\n- **Idea**: Try all possible placements and check for conflicts.\n- **Time Complexity**: O(n^n), impractical.\n\n#### 2. Backtracking\n\n- **Idea**: Place queens row by row, tracking conflicts efficiently.\n- **Steps**:\n  1. Initialize an n×n board and sets for columns, main diagonals, and anti-diagonals.\n  2. For each row, try placing a queen in each column.\n  3. Check if the position is valid (no conflicts in column, main diagonal, or anti-diagonal).\n  4. If valid, place queen, update sets, and recurse to next row.\n  5. Backtrack by removing the queen and trying the next column.\n  6. Collect all valid configurations.\n- **Time Complexity**: O(n!), as we explore permutations with pruning.\n- **Space Complexity**: O(n^2) for the board and recursion stack.\n- **Pros**: Efficient for n <= 9, finds all solutions.\n\n### Recommended Solution\n\nThe backtracking approach is recommended, as it’s the standard solution for n-queens and feasible for n <= 9.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n!), as we try all valid placements with pruning.\n- **Space Complexity**: O(n^2) for the board and O(n) for recursion.\n- **Constraints Handling**:\n  - n <= 9 ensures reasonable runtime.\n  - Output format: List of string lists for each solution.\n\n### Edge Cases\n\n- **n = 1**: [[\"Q\"]].\n- **n = 2 or 3**: No solutions, return [].\n- **n = 4**: Two solutions, as shown in example.\n\n### Implementation Notes\n\n- Use sets for O(1) conflict checks.\n- Convert board state to string list for output.\n- Handle edge cases like n = 2 or 3 explicitly if needed.\n\n### Visual Explanation\n\nFor n = 4:\n- Place queen in row 0, try columns, recurse to row 1, etc.\n- Solution 1: Queens at (1,0), (3,1), (0,2), (2,3) → [\".Q..\", \"...Q\", \"Q...\", \"..Q.\"].",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n)\n\nfunc solveNQueens(n int) [][]string {\n    // Write your code here\n    return [][]string{}\n}\n\nfunc main() {\n    var n int\n    if _, err := fmt.Scan(&n); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := solveNQueens(n)\n    fmt.Printf(\"%v\\n\", result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> solveNQueens(int n) {\n        // Write your code here\n        return {};\n    }\n};\n\nint main() {\n    try {\n        int n;\n        if (!(cin >> n)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        Solution sol;\n        vector<vector<string>> result = sol.solveNQueens(n);\n        cout << \"[\";\n        for (int i = 0; i < result.size(); i++) {\n            cout << \"[\";\n            for (int j = 0; j < result[i].size(); j++) {\n                cout << \"\\\"\" << result[i][j] << \"\\\"\";\n                if (j < result[i].size() - 1) cout << \",\";\n            }\n            cout << \"]\";\n            if (i < result.size() - 1) cout << \",\";\n        }\n        cout << \"]\" << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Solves the n-queens puzzle.\n     * @param n Board size\n     * @return List of all distinct solutions\n     */\n    public List<List<String>> solveNQueens(int n) {\n        // Write your code here\n        return new ArrayList<>();\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            int n = Integer.parseInt(scanner.nextLine().trim());\n            Main main = new Main();\n            List<List<String>> result = main.solveNQueens(n);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def solveNQueens(self, n):\n        \"\"\"\n        Solves the n-queens puzzle.\n        :param n: int - Board size\n        :return: List of all distinct solutions\n        \"\"\"\n        # Write your code here\n        return []\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        n = int(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.solveNQueens(n)\n        print(result)\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Solves the n-queens puzzle.\n * @param {number} n - Board size\n * @return {string[][]} - All distinct solutions\n */\nfunction solveNQueens(n) {\n    // Write your code here\n    return [];\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const n = parseInt(line.trim());\n        const result = solveNQueens(n);\n        console.log(JSON.stringify(result));\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc solveNQueens(n int) [][]string {\n    result := [][]string{}\n    board := make([][]byte, n)\n    for i := range board {\n        board[i] = make([]byte, n)\n        for j := range board[i] {\n            board[i][j] = '.'\n        }\n    }\n    cols := map[int]bool{}\n    diag1 := map[int]bool{}\n    diag2 := map[int]bool{}\n\n    var backtrack func(row int)\n    backtrack = func(row int) {\n        if row == n {\n            solution := make([]string, n)\n            for i := 0; i < n; i++ {\n                solution[i] = string(board[i])\n            }\n            result = append(result, solution)\n            return\n        }\n        for col := 0; col < n; col++ {\n            if !cols[col] && !diag1[row-col] && !diag2[row+col] {\n                cols[col] = true\n                diag1[row-col] = true\n                diag2[row+col] = true\n                board[row][col] = 'Q'\n                backtrack(row + 1)\n                cols[col] = false\n                diag1[row-col] = false\n                diag2[row+col] = false\n                board[row][col] = '.'\n            }\n        }\n    }\n\n    backtrack(0)\n    return result\n}\n\nfunc main() {\n    var n int\n    if _, err := fmt.Scan(&n); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := solveNQueens(n)\n    fmt.Printf(\"%v\\n\", result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> solveNQueens(int n) {\n        vector<vector<string>> result;\n        vector<string> board(n, string(n, '.'));\n        set<int> cols, diag1, diag2;\n        backtrack(0, n, cols, diag1, diag2, board, result);\n        return result;\n    }\nprivate:\n    void backtrack(int row, int n, set<int>& cols, set<int>& diag1, set<int>& diag2, vector<string>& board, vector<vector<string>>& result) {\n        if (row == n) {\n            result.push_back(board);\n            return;\n        }\n        for (int col = 0; col < n; col++) {\n            if (!cols.count(col) && !diag1.count(row - col) && !diag2.count(row + col)) {\n                cols.insert(col);\n                diag1.insert(row - col);\n                diag2.insert(row + col);\n                board[row][col] = 'Q';\n                backtrack(row + 1, n, cols, diag1, diag2, board, result);\n                cols.erase(col);\n                diag1.erase(row - col);\n                diag2.erase(row + col);\n                board[row][col] = '.';\n            }\n        }\n    }\n};\n\nint main() {\n    try {\n        int n;\n        if (!(cin >> n)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        Solution sol;\n        vector<vector<string>> result = sol.solveNQueens(n);\n        cout << \"[\";\n        for (int i = 0; i < result.size(); i++) {\n            cout << \"[\";\n            for (int j = 0; j < result[i].size(); j++) {\n                cout << \"\\\"\" << result[i][j] << \"\\\"\";\n                if (j < result[i].size() - 1) cout << \",\";\n            }\n            cout << \"]\";\n            if (i < result.size() - 1) cout << \",\";\n        }\n        cout << \"]\" << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.*;\n\npublic class Main {\n    public List<List<String>> solveNQueens(int n) {\n        List<List<String>> result = new ArrayList<>();\n        char[][] board = new char[n][n];\n        for (int i = 0; i < n; i++) Arrays.fill(board[i], '.');\n        Set<Integer> cols = new HashSet<>(), diag1 = new HashSet<>(), diag2 = new HashSet<>();\n\n        backtrack(0, n, cols, diag1, diag2, board, result);\n        return result;\n    }\n\n    private void backtrack(int row, int n, Set<Integer> cols, Set<Integer> diag1, Set<Integer> diag2, char[][] board, List<List<String>> result) {\n        if (row == n) {\n            List<String> solution = new ArrayList<>();\n            for (char[] r : board) solution.add(new String(r));\n            result.add(solution);\n            return;\n        }\n        for (int col = 0; col < n; col++) {\n            if (!cols.contains(col) && !diag1.contains(row - col) && !diag2.contains(row + col)) {\n                cols.add(col);\n                diag1.add(row - col);\n                diag2.add(row + col);\n                board[row][col] = 'Q';\n                backtrack(row + 1, n, cols, diag1, diag2, board, result);\n                cols.remove(col);\n                diag1.remove(row - col);\n                diag2.remove(row + col);\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            int n = Integer.parseInt(scanner.nextLine().trim());\n            Main main = new Main();\n            List<List<String>> result = main.solveNQueens(n);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def solveNQueens(self, n):\n        def create_board(positions):\n            board = [['.' for _ in range(n)] for _ in range(n)]\n            for row, col in enumerate(positions):\n                board[row][col] = 'Q'\n            return [''.join(row) for row in board]\n\n        def backtrack(row, cols, diag1, diag2, positions):\n            if row == n:\n                result.append(create_board(positions))\n                return\n            for col in range(n):\n                if col not in cols and (row - col) not in diag1 and (row + col) not in diag2:\n                    cols.add(col)\n                    diag1.add(row - col)\n                    diag2.add(row + col)\n                    positions.append(col)\n                    backtrack(row + 1, cols, diag1, diag2, positions)\n                    cols.remove(col)\n                    diag1.remove(row - col)\n                    diag2.remove(row + col)\n                    positions.pop()\n\n        result = []\n        backtrack(0, set(), set(), set(), [])\n        return result\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        n = int(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.solveNQueens(n)\n        print(result)\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Solves the n-queens puzzle.\n * @param {number} n - Board size\n * @return {string[][]} - All distinct solutions\n */\nfunction solveNQueens(n) {\n    const result = [];\n    const board = Array(n).fill().map(() => Array(n).fill('.'));\n    const cols = new Set(), diag1 = new Set(), diag2 = new Set();\n\n    function backtrack(row) {\n        if (row === n) {\n            result.push(board.map(row => row.join('')));\n            return;\n        }\n        for (let col = 0; col < n; col++) {\n            if (!cols.has(col) && !diag1.has(row - col) && !diag2.has(row + col)) {\n                cols.add(col);\n                diag1.add(row - col);\n                diag2.add(row + col);\n                board[row][col] = 'Q';\n                backtrack(row + 1);\n                cols.delete(col);\n                diag1.delete(row - col);\n                diag2.delete(row + col);\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    backtrack(0);\n    return result;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const n = parseInt(line.trim());\n        const result = solveNQueens(n);\n        console.log(JSON.stringify(result));\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    }
  },
  {
    "title": "Permutation Sequence",
    "description": "Given a set of numbers [1,2,3,...,n], there are n! unique permutations. By listing all permutations in lexicographical order, we get a sequence. For example, for n = 3, the sequence is:\n- \"123\"\n- \"132\"\n- \"213\"\n- \"231\"\n- \"312\"\n- \"321\"\nGiven n and k, return the kth permutation sequence as a string.\n\n### Problem Statement\n\nYou are given two integers n and k. Find the kth permutation of the set [1,2,...,n] in lexicographical order.\n\n### Input\n\n- **n**: An integer representing the size of the set (1 <= n <= 9).\n- **k**: An integer representing the kth permutation to find (1 <= k <= n!).\n\n### Output\n\n- A string representing the kth permutation sequence.\n\n### Example\n\n**Input**: n = 3, k = 3  \n**Output**: \"213\"  \n**Explanation**: The permutations are [\"123\", \"132\", \"213\", \"231\", \"312\", \"321\"]. The 3rd permutation is \"213\".\n\n**Input**: n = 4, k = 9  \n**Output**: \"2314\"  \n**Explanation**: The 9th permutation of [1,2,3,4] is \"2314\".\n\n**Input**: n = 2, k = 1  \n**Output**: \"12\"  \n**Explanation**: The 1st permutation of [1,2] is \"12\".\n\n### Notes\n\n- n is guaranteed to be between 1 and 9 inclusive.\n- k is guaranteed to be between 1 and n! inclusive.\n- Use a factorial-based approach for O(n) time complexity.\n- Avoid generating all permutations to prevent O(n!) complexity.\n\n### Real-World Context\n\nThis problem models scenarios like generating ordered sequences for scheduling, ranking, or combinatorial tasks.",
    "difficulty": "HARD",
    "tags": [
      "Math",
      "Backtracking",
      "JP Morgan",
      "Google",
      "Microsoft",
      "Atlassian"
    ],
    "constraints": [
      "1 <= n <= 9",
      "1 <= k <= n!",
      "Return the kth permutation as a string.",
      "Time complexity should be O(n).",
      "Space complexity should be O(n)."
    ],
    "examples": [
      {
        "input": "n = 3, k = 3",
        "output": "213",
        "explanation": "The permutations of [1,2,3] are [\"123\", \"132\", \"213\", \"231\", \"312\", \"321\"]. The 3rd permutation is \"213\".\n\nVisual Path:\n- Factorial: Pick 2, then 1, then 3."
      }
    ],
    "testcases": [
      {
        "input": "3,3",
        "output": "213",
        "isHidden": false
      },
      {
        "input": "4,9",
        "output": "2314",
        "isHidden": false
      },
      {
        "input": "2,1",
        "output": "12",
        "isHidden": false
      },
      {
        "input": "1,1",
        "output": "1",
        "isHidden": true
      },
      {
        "input": "3,6",
        "output": "321",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Generating all permutations is too slow. Can you use factorials to select digits directly?",
      "2. For n digits, (n-1)! permutations start with each digit. How can you use this to pick the first digit?",
      "3. Adjust k to 0-based indexing to simplify calculations.",
      "4. After selecting a digit, remove it and repeat with the remaining digits."
    ],
    "editorial": "## Editorial: Permutation Sequence\n\n### Problem Recap\n\nFind the kth permutation of the set [1,2,...,n] in lexicographical order, given integers n and k.\n\n### Intuition\n\nGenerating all n! permutations is infeasible due to the large number of permutations (e.g., 9! = 362,880). Instead, use a mathematical approach based on factorials to determine each digit of the permutation directly.\n\n### Approaches\n\n#### 1. Generate All Permutations\n\n- **Idea**: Generate all permutations and select the kth one.\n- **Time Complexity**: O(n!), as there are n! permutations.\n- **Space Complexity**: O(n) for recursion stack.\n- **Cons**: Too slow for n up to 9.\n\n#### 2. Factorial-Based Approach\n\n- **Idea**: Use factorials to select digits iteratively.\n- **Steps**:\n  1. Create a list of numbers [1,2,...,n].\n  2. Adjust k to 0-based (k = k - 1).\n  3. For each position:\n     - Compute (n-1)! to find the number of permutations per digit.\n     - Select the index = k / (n-1)! to pick the digit.\n     - Append the digit to the result, remove it from the list.\n     - Update k = k % (n-1)!, n = n - 1.\n  4. Repeat until n = 0.\n- **Time Complexity**: O(n), as we process each digit once.\n- **Space Complexity**: O(n) for the numbers list.\n- **Pros**: Efficient and meets constraints.\n\n### Recommended Solution\n\nThe factorial-based approach is optimal for O(n) time and O(n) space.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for iterating n times.\n- **Space Complexity**: O(n) for storing numbers.\n- **Constraints Handling**:\n  - n <= 9 ensures factorials fit in 64-bit integers.\n  - k <= n! ensures valid input.\n\n### Edge Cases\n\n- **n = 1, k = 1**: Returns \"1\".\n- **n = 2, k = 2**: Returns \"21\".\n- **n = 9, k = 362880**: Returns the last permutation.\n\n### Implementation Notes\n\n- Use a dynamic list to remove digits.\n- Compute factorials iteratively to avoid overflow for n <= 9.\n- Convert digits to strings for the final result.\n\n### Visual Explanation\n\nFor n = 3, k = 3:\n- Numbers = [1,2,3], k = 2.\n- (3-1)! = 2, index = 2/2 = 1 → Pick 2, result = \"2\", numbers = [1,3].\n- (2-1)! = 1, index = 2%2 = 0 → Pick 1, result = \"21\", numbers = [3].\n- (1-1)! = 1, index = 0 → Pick 3, result = \"213\".",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n)\n\nfunc getPermutation(n int, k int) string {\n    // Write your code here\n    return \"\"\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Print(\"Invalid input format\")\n        return\n    }\n    var n, k int\n    _, err := fmt.Sscanf(input, \"%d,%d\", &n, &k)\n    if err != nil {\n        fmt.Print(\"Invalid input format\")\n        return\n    }\n    result := getPermutation(n, k)\n    fmt.Print(result)  \n}",
      "C++": "#include <iostream>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    string getPermutation(int n, int k) {\n        // Write your code here\n        return \"\";\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        stringstream ss(line);\n        int n, k;\n        char comma;\n        if (!(ss >> n >> comma >> k) || comma != ',') {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        Solution sol;\n        string result = sol.getPermutation(n, k);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Finds the kth permutation sequence.\n     * @param n Size of the set\n     * @param k kth permutation (1-based)\n     * @return kth permutation sequence\n     */\n    public String getPermutation(int n, int k) {\n        // Write your code here\n        return \"\";\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String[] input = scanner.nextLine().trim().split(\",\");\n            int n = Integer.parseInt(input[0].trim());\n            int k = Integer.parseInt(input[1].trim());\n            Main main = new Main();\n            String result = main.getPermutation(n, k);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def getPermutation(self, n, k):\n        numbers = list(range(1, n + 1))\n        k = k - 1  # Convert to 0-based index\n        result = []\n        while n > 0:\n            fact = 1\n            for i in range(1, n):\n                fact *= i\n            index = k // fact\n            k = k % fact\n            result.append(str(numbers[index]))\n            numbers.pop(index)\n            n -= 1\n        return ''.join(result)\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        n, k = map(int, line.split(\",\"))\n        sol = Solution()\n        result = sol.getPermutation(n, k)\n        sys.stdout.write(result)  \n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds the kth permutation sequence.\n * @param {number} n - Size of the set\n * @param {number} k - kth permutation (1-based)\n * @return {string} - kth permutation sequence\n */\nfunction getPermutation(n, k) {\n    // Write your code here\n    return \"\";\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const [n, k] = line.trim().split(\",\").map(num => parseInt(num.trim()));\n        const result = getPermutation(n, k);\n        console.log(result);\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n)\n\nfunc getPermutation(n int, k int) string {\n    numbers := make([]int, n)\n    for i := 0; i < n; i++ {\n        numbers[i] = i + 1\n    }\n    k = k - 1\n    result := \"\"\n    for n > 0 {\n        fact := 1\n        for i := 1; i < n; i++ {\n            fact *= i\n        }\n        index := k / fact\n        k = k % fact\n        result += strconv.Itoa(numbers[index])\n        numbers = append(numbers[:index], numbers[index+1:]...)\n        n--\n    }\n    return result\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Print(\"Invalid input format\")\n        return\n    }\n    var n, k int\n    _, err := fmt.Sscanf(input, \"%d,%d\", &n, &k)\n    if err != nil {\n        fmt.Print(\"Invalid input format\")\n        return\n    }\n    result := getPermutation(n, k)\n    fmt.Print(result)  \n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nclass Solution {\npublic:\n    string getPermutation(int n, int k) {\n        vector<int> numbers;\n        for (int i = 1; i <= n; i++) numbers.push_back(i);\n        k = k - 1;\n        string result = \"\";\n        while (n > 0) {\n            long long fact = 1;\n            for (int i = 1; i < n; i++) fact *= i;\n            int index = k / fact;\n            k = k % fact;\n            result += to_string(numbers[index]);\n            numbers.erase(numbers.begin() + index);\n            n--;\n        }\n        return result;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        stringstream ss(line);\n        int n, k;\n        char comma;\n        if (!(ss >> n >> comma >> k) || comma != ',') {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        Solution sol;\n        string result = sol.getPermutation(n, k);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public String getPermutation(int n, int k) {\n        List<Integer> numbers = new ArrayList<>();\n        for (int i = 1; i <= n; i++) numbers.add(i);\n        k = k - 1;\n        StringBuilder result = new StringBuilder();\n        while (n > 0) {\n            long fact = 1;\n            for (int i = 1; i < n; i++) fact *= i;\n            int index = (int)(k / fact);\n            k = (int)(k % fact);\n            result.append(numbers.get(index));\n            numbers.remove(index);\n            n--;\n        }\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String[] input = scanner.nextLine().trim().split(\",\");\n            int n = Integer.parseInt(input[0].trim());\n            int k = Integer.parseInt(input[1].trim());\n            Main main = new Main();\n            String result = main.getPermutation(n, k);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def getPermutation(self, n, k):\n        numbers = list(range(1, n + 1))\n        k = k - 1  # Convert to 0-based index\n        result = []\n        while n > 0:\n            fact = 1\n            for i in range(1, n):\n                fact *= i\n            index = k // fact\n            k = k % fact\n            result.append(str(numbers[index]))\n            numbers.pop(index)\n            n -= 1\n        return ''.join(result)\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        n, k = map(int, line.split(\",\"))\n        sol = Solution()\n        result = sol.getPermutation(n, k)\n        sys.stdout.write(result)  # Use write to avoid trailing newline\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds the kth permutation sequence.\n * @param {number} n - Size of the set\n * @param {number} k - kth permutation (1-based)\n * @return {string} - kth permutation sequence\n */\nfunction getPermutation(n, k) {\n    let numbers = Array.from({length: n}, (_, i) => i + 1);\n    k = k - 1;\n    let result = '';\n    while (n > 0) {\n        let fact = 1;\n        for (let i = 1; i < n; i++) fact *= i;\n        let index = Math.floor(k / fact);\n        k = k % fact;\n        result += numbers[index];\n        numbers.splice(index, 1);\n        n--;\n    }\n    return result;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const [n, k] = line.trim().split(\",\").map(num => parseInt(num.trim()));\n        const result = getPermutation(n, k);\n        console.log(result);\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n    rl.close();\n});"
    }
  },
  {
    "title": "Add Binary",
    "description": "Given two binary strings a and b, return their sum as a binary string. The input strings are non-empty and contain only characters '0' or '1'.\n\n### Problem Statement\n\nYou are given two binary strings **a** and **b**. Compute their sum as a binary string and return it.\n\n### Input\n\n- **a**: A binary string containing only '0' or '1' (1 <= a.length <= 10^4).\n- **b**: A binary string containing only '0' or '1' (1 <= b.length <= 10^4).\n\n### Output\n\n- A binary string representing the sum of a and b.\n\n### Example\n\n**Input**: a = \"11\", b = \"1\"  \n**Output**: \"100\"  \n**Explanation**: Binary 11 + 1 = 100 (3 + 1 = 4 in decimal).\n\n**Input**: a = \"1010\", b = \"1011\"  \n**Output**: \"10101\"  \n**Explanation**: Binary 1010 + 1011 = 10101 (10 + 11 = 21 in decimal).\n\n**Input**: a = \"0\", b = \"0\"  \n**Output**: \"0\"  \n**Explanation**: Binary 0 + 0 = 0.\n\n### Notes\n\n- Process strings from right to left, keeping track of carry.\n- Each string is either \"0\" or does not contain leading zeros.\n- Avoid converting to integers to prevent overflow for large strings.\n\n### Real-World Context\n\nThis problem models binary arithmetic operations in computer systems, such as hardware adders or cryptographic algorithms.",
    "difficulty": "EASY",
    "tags": [
      "String",
      "Bit Manipulation",
      "Amazon",
      "Facebook"
    ],
    "constraints": [
      "1 <= a.length, b.length <= 10^4",
      "Each string consists only of '0' or '1' characters",
      "Each string is either \"0\" or does not contain leading zeros",
      "Return the sum as a binary string.",
      "Time complexity should be O(max(n,m)), where n and m are the lengths of a and b.",
      "Space complexity should be O(max(n,m)) for the result."
    ],
    "examples": [
      {
        "input": "a = \"11\", b = \"1\"",
        "output": "100",
        "explanation": "Binary 11 + 1 = 100 (3 + 1 = 4 in decimal).\n\nVisual Path:\n- Sum digits with carry: 1+1=2 (0, carry=1), 1+0+1=2 (0, carry=1), 1 (1, carry=0). Reverse \"001\" to \"100\"."
      }
    ],
    "testcases": [
      {
        "input": "11\n1",
        "output": "100",
        "isHidden": false
      },
      {
        "input": "1010\n1011",
        "output": "10101",
        "isHidden": false
      },
      {
        "input": "0\n0",
        "output": "0",
        "isHidden": false
      },
      {
        "input": "1\n1",
        "output": "10",
        "isHidden": true
      },
      {
        "input": "1111\n1111",
        "output": "11110",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Process the strings from right to left, keeping track of carry.",
      "2. Convert each character to a number and sum with carry.",
      "3. Append the least significant bit (sum % 2) to the result and update carry (sum / 2).",
      "4. Reverse the result string at the end or build it in reverse."
    ],
    "editorial": "## Editorial: Add Binary\n\n### Problem Recap\n\nGiven two binary strings a and b, compute their sum as a binary string.\n\n### Intuition\n\nBinary addition is similar to decimal addition, but with base 2. Process the strings from right to left, adding corresponding digits and a carry. The sum of two bits and a carry (0 or 1) ranges from 0 to 3 (e.g., 1+1+1 = 3). Append the least significant bit (sum % 2) to the result and update the carry (sum / 2). Since we process right to left, reverse the result or build it in reverse.\n\n### Approaches\n\n#### 1. Convert to Integer\n\n- **Idea**: Convert binary strings to integers, add them, then convert back to binary.\n- **Time Complexity**: O(n + m) for conversion, where n and m are string lengths.\n- **Space Complexity**: O(max(n,m)) for result.\n- **Cons**: Risks overflow for strings up to 10^4 (beyond 64-bit integer limits).\n\n#### 2. Iterative Carry Approach\n\n- **Idea**: Simulate binary addition digit by digit.\n- **Steps**:\n  1. Initialize carry = 0, result = empty string.\n  2. Iterate from the end of both strings (i = a.length-1, j = b.length-1):\n     - Sum = carry + (a[i] or 0) + (b[j] or 0).\n     - Append sum % 2 to result.\n     - Update carry = sum / 2.\n  3. If carry remains, append it.\n  4. Reverse the result string.\n- **Time Complexity**: O(max(n,m)), where n and m are string lengths.\n- **Space Complexity**: O(max(n,m)) for the result string.\n- **Pros**: No overflow, handles all cases.\n\n### Recommended Solution\n\nThe iterative carry approach is optimal for O(max(n,m)) time and O(max(n,m)) space.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(max(n,m)) for processing digits.\n- **Space Complexity**: O(max(n,m)) for the result string.\n- **Constraints Handling**:\n  - String length: 1 <= n, m <= 10^4.\n  - Valid characters: Only '0' or '1'.\n  - No leading zeros except \"0\".\n\n### Edge Cases\n\n- **Equal lengths**: a = \"11\", b = \"11\" → \"110\".\n- **Different lengths**: a = \"11\", b = \"1\" → \"100\".\n- **Zero inputs**: a = \"0\", b = \"0\" → \"0\".\n- **Single digits**: a = \"1\", b = \"1\" → \"10\".\n- **Long strings**: Handle up to 10^4 length.\n\n### Implementation Notes\n\n- Use two pointers to traverse strings from right to left.\n- Convert characters to integers (e.g., '1' - '0' or parseInt).\n- Build result in reverse and reverse at the end, or prepend digits.\n- Handle cases where one string is longer.\n\n### Visual Explanation\n\nFor a = \"11\", b = \"1\":\n- i=1, j=0: sum = 1+1+0=2 → append 0, carry=1.\n- i=0, j=-1: sum = 1+0+1=2 → append 0, carry=1.\n- i=-1, j=-1: sum = 1 → append 1, carry=0.\n- Result = \"001\", reverse to \"100\".",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"bufio\"\n    \"os\"\n    \"strings\"\n)\n\nfunc addBinary(a string, b string) string {\n    // Write your code here\n    return \"\"\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    var lines []string\n    for scanner.Scan() {\n        lines = append(lines, strings.TrimSpace(scanner.Text()))\n        if len(lines) == 2 {\n            break\n        }\n    }\n    if len(lines) != 2 {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := addBinary(lines[0], lines[1])\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        // Write your code here\n        return \"\";\n    }\n};\n\nint main() {\n    try {\n        string a, b;\n        if (!getline(cin, a) || !getline(cin, b)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        Solution sol;\n        string result = sol.addBinary(a, b);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Adds two binary strings and returns their sum as a binary string.\n     * @param a First binary string\n     * @param b Second binary string\n     * @return Sum as a binary string\n     */\n    public String addBinary(String a, String b) {\n        // Write your code here\n        return \"\";\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String a = scanner.nextLine().trim();\n            String b = scanner.nextLine().trim();\n            Main main = new Main();\n            String result = main.addBinary(a, b);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def addBinary(self, a, b):\n        \"\"\"\n        Adds two binary strings and returns their sum as a binary string.\n        :param a: First binary string\n        :param b: Second binary string\n        :return: Sum as a binary string\n        \"\"\"\n        # Write your code here\n        return \"\"\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        a = sys.stdin.readline().strip()\n        b = sys.stdin.readline().strip()\n        sol = Solution()\n        result = sol.addBinary(a, b)\n        sys.stdout.write(result)  # Avoid trailing newline\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Adds two binary strings and returns their sum as a binary string.\n * @param {string} a - First binary string\n * @param {string} b - Second binary string\n * @return {string} - Sum as a binary string\n */\nfunction addBinary(a, b) {\n    // Write your code here\n    return \"\";\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nlet lines = [];\nrl.on(\"line\", (line) => {\n    lines.push(line.trim());\n    if (lines.length === 2) {\n        try {\n            const result = addBinary(lines[0], lines[1]);\n            console.log(result);\n            rl.close();\n        } catch (e) {\n            console.log(\"Invalid input format\");\n            process.exit(1);\n        }\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"bufio\"\n    \"os\"\n    \"strings\"\n)\n\nfunc addBinary(a string, b string) string {\n    result := \"\"\n    carry := 0\n    i, j := len(a)-1, len(b)-1\n    for i >= 0 || j >= 0 || carry > 0 {\n        sum := carry\n        if i >= 0 {\n            sum += int(a[i] - '0')\n            i--\n        }\n        if j >= 0 {\n            sum += int(b[j] - '0')\n            j--\n        }\n        result = fmt.Sprintf(\"%d%s\", sum%2, result)\n        carry = sum / 2\n    }\n    return result\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    var lines []string\n    for scanner.Scan() {\n        lines = append(lines, strings.TrimSpace(scanner.Text()))\n        if len(lines) == 2 {\n            break\n        }\n    }\n    if len(lines) != 2 {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := addBinary(lines[0], lines[1])\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <string>\n#include <algorithm> \nusing namespace std;\n\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        string result;\n        int i = a.length() - 1;\n        int j = b.length() - 1;\n        int carry = 0;\n        while (i >= 0 || j >= 0 || carry) {\n            int sum = carry;\n            if (i >= 0) sum += a[i--] - '0';\n            if (j >= 0) sum += b[j--] - '0';\n            result.push_back((sum % 2) + '0');\n            carry = sum / 2;\n        }\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n\nint main() {\n    try {\n        string a, b;\n        if (!getline(cin, a) || !getline(cin, b)) {\n            cout << \"Invalid input format\";\n            return 1;\n        }\n        Solution sol;\n        string result = sol.addBinary(a, b);\n        cout << result; // Avoid trailing newline\n    } catch (...) {\n        cout << \"Invalid input format\";\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public String addBinary(String a, String b) {\n        StringBuilder result = new StringBuilder();\n        int i = a.length() - 1;\n        int j = b.length() - 1;\n        int carry = 0;\n        while (i >= 0 || j >= 0 || carry > 0) {\n            int sum = carry;\n            if (i >= 0) sum += a.charAt(i--) - '0';\n            if (j >= 0) sum += b.charAt(j--) - '0';\n            result.append(sum % 2);\n            carry = sum / 2;\n        }\n        return result.reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String a = scanner.nextLine().trim();\n            String b = scanner.nextLine().trim();\n            Main main = new Main();\n            String result = main.addBinary(a, b);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def addBinary(self, a, b):\n        result = []\n        carry = 0\n        i, j = len(a) - 1, len(b) - 1\n        while i >= 0 or j >= 0 or carry:\n            sum = carry\n            if i >= 0:\n                sum += int(a[i])\n                i -= 1\n            if j >= 0:\n                sum += int(b[j])\n                j -= 1\n            result.append(str(sum % 2))\n            carry = sum // 2\n        return ''.join(result[::-1])\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        a = sys.stdin.readline().strip()\n        b = sys.stdin.readline().strip()\n        sol = Solution()\n        result = sol.addBinary(a, b)\n        sys.stdout.write(result)  # Avoid trailing newline\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Adds two binary strings and returns their sum as a binary string.\n * @param {string} a - First binary string\n * @param {string} b - Second binary string\n * @return {string} - Sum as a binary string\n */\nfunction addBinary(a, b) {\n    let result = '';\n    let carry = 0;\n    let i = a.length - 1;\n    let j = b.length - 1;\n    while (i >= 0 || j >= 0 || carry) {\n        let sum = carry;\n        if (i >= 0) sum += parseInt(a[i--]);\n        if (j >= 0) sum += parseInt(b[j--]);\n        result = (sum % 2) + result;\n        carry = Math.floor(sum / 2);\n    }\n    return result;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nlet lines = [];\nrl.on(\"line\", (line) => {\n    lines.push(line.trim());\n    if (lines.length === 2) {\n        try {\n            const result = addBinary(lines[0], lines[1]);\n            console.log(result);\n            rl.close();\n        } catch (e) {\n            console.log(\"Invalid input format\");\n            process.exit(1);\n        }\n    }\n});"
    }
  },
  {
    "title": "Sqrt(x)",
    "description": "Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.\n\n### Problem Statement\n\nYou are given a non-negative integer **x**. Compute the integer square root of x, truncating any decimal digits, and return it.\n\n### Input\n\n- **x**: A non-negative integer (0 <= x <= 2^31 - 1).\n\n### Output\n\n- An integer representing the truncated square root of x.\n\n### Example\n\n**Input**: x = 4  \n**Output**: 2  \n**Explanation**: The square root of 4 is 2.\n\n**Input**: x = 8  \n**Output**: 2  \n**Explanation**: The square root of 8 is 2.82842..., truncated to 2.\n\n**Input**: x = 0  \n**Output**: 0  \n**Explanation**: The square root of 0 is 0.\n\n### Notes\n\n- Use binary search to efficiently find the square root.\n- Be cautious of integer overflow when computing squares.\n- The result is the largest integer m such that m * m <= x.\n\n### Real-World Context\n\nThis problem models scenarios like numerical computations in graphics, physics simulations, or algorithms requiring fast square root approximations.",
    "difficulty": "EASY",
    "tags": [
      "Math",
      "Binary Search",
      "Google",
      "Apple"
    ],
    "constraints": [
      "0 <= x <= 2^31 - 1",
      "Return the integer part of the square root of x.",
      "Time complexity should be O(log x).",
      "Space complexity should be O(1)."
    ],
    "examples": [
      {
        "input": "x = 4",
        "output": "2",
        "explanation": "The square root of 4 is 2.\n\nVisual Path:\n- Binary search: mid=2, 2*2=4, exact match, return 2."
      }
    ],
    "testcases": [
      {
        "input": "4",
        "output": "2",
        "isHidden": false
      },
      {
        "input": "8",
        "output": "2",
        "isHidden": false
      },
      {
        "input": "0",
        "output": "0",
        "isHidden": false
      },
      {
        "input": "1",
        "output": "1",
        "isHidden": true
      },
      {
        "input": "2147483647",
        "output": "46340",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Use binary search to find the largest integer whose square is <= x.",
      "2. Be careful with integer overflow when computing squares.",
      "3. Set the search range from 1 to x for non-zero inputs.",
      "4. If mid * mid > x, search in the lower half; otherwise, search in the upper half."
    ],
    "editorial": "## Editorial: Sqrt(x)\n\n### Problem Recap\n\nCompute the integer square root of a non-negative integer x, truncating decimal digits.\n\n### Intuition\n\nThe square root of x is the largest integer m such that m * m <= x. Since x can be large (up to 2^31 - 1), a linear search would be too slow (O(sqrt(x))). Binary search is ideal, reducing the time to O(log x). Search for m in the range [0, x], adjusting based on whether mid * mid is less than, equal to, or greater than x.\n\n### Approaches\n\n#### 1. Linear Search\n\n- **Idea**: Check integers from 0 to sqrt(x) until i * i > x.\n- **Time Complexity**: O(sqrt(x)), too slow for x = 2^31 - 1.\n- **Space Complexity**: O(1).\n- **Cons**: Inefficient for large inputs.\n\n#### 2. Binary Search\n\n- **Idea**: Use binary search to find the largest m where m * m <= x.\n- **Steps**:\n  1. If x = 0, return 0.\n  2. Set left = 1, right = x.\n  3. While left <= right:\n     - Compute mid = (left + right) / 2.\n     - If mid * mid = x, return mid.\n     - If mid * mid < x, search right (left = mid + 1).\n     - If mid * mid > x, search left (right = mid - 1).\n  4. Return right (largest m where m * m <= x).\n- **Time Complexity**: O(log x), as the search space halves each step.\n- **Space Complexity**: O(1).\n- **Pros**: Efficient, handles all cases.\n\n### Recommended Solution\n\nThe binary search approach is optimal for O(log x) time and O(1) space.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(log x) for binary search.\n- **Space Complexity**: O(1) for constant extra space.\n- **Constraints Handling**:\n  - Input range: 0 <= x <= 2^31 - 1.\n  - Output: Integer part of sqrt(x).\n\n### Edge Cases\n\n- **x = 0**: Return 0.\n- **x = 1**: Return 1.\n- **x = 2^31 - 1**: Handle large numbers without overflow.\n- **Perfect squares**: x = 4, 9, 16.\n- **Non-perfect squares**: x = 8 (2.828... → 2).\n\n### Implementation Notes\n\n- Use long for mid * mid to avoid overflow (e.g., mid = 2^16, mid * mid = 2^32).\n- Alternatively, compare x / mid with mid to avoid multiplication.\n- Return right as it holds the largest m where m * m <= x.\n\n### Visual Explanation\n\nFor x = 8:\n- left=1, right=8, mid=4: 4*4=16 > 8 → right=3.\n- left=1, right=3, mid=2: 2*2=4 <= 8 → left=3.\n- left=3, right=3, mid=3: 3*3=9 > 8 → right=2.\n- left=3, right=2, exit. Return right=2.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc mySqrt(x int) int {\n    // Write your code here\n    return 0\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    x, err := strconv.Atoi(strings.TrimSpace(input))\n    if err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := mySqrt(x)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        // Write your code here\n        return 0;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        int x = stoi(line);\n        Solution sol;\n        int result = sol.mySqrt(x);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Computes the integer square root of x.\n     * @param x Non-negative integer\n     * @return Integer square root\n     */\n    public int mySqrt(int x) {\n        // Write your code here\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            int x = Integer.parseInt(scanner.nextLine().trim());\n            Main main = new Main();\n            int result = main.mySqrt(x);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def mySqrt(self, x):\n        \"\"\"\n        Computes the integer square root of x.\n        :param x: Non-negative integer\n        :return: Integer square root\n        \"\"\"\n        # Write your code here\n        return 0\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        x = int(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.mySqrt(x)\n        sys.stdout.write(str(result))  # Avoid trailing newline\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Computes the integer square root of x.\n * @param {number} x - Non-negative integer\n * @return {number} - Integer square root\n */\nfunction mySqrt(x) {\n    // Write your code here\n    return 0;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const x = parseInt(line.trim());\n        const result = mySqrt(x);\n        console.log(result);\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc mySqrt(x int) int {\n    if x == 0 {\n        return 0\n    }\n    left, right := 1, x\n    for left <= right {\n        mid := (left + right) / 2\n        if mid * mid == x {\n            return mid\n        }\n        if mid * mid < x {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return right\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    x, err := strconv.Atoi(strings.TrimSpace(input))\n    if err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := mySqrt(x)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if (x == 0) return 0;\n        long left = 1, right = x;\n        while (left <= right) {\n            long mid = (left + right) / 2;\n            if (mid * mid == x) return mid;\n            if (mid * mid < x) left = mid + 1;\n            else right = mid - 1;\n        }\n        return right;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        int x = stoi(line);\n        Solution sol;\n        int result = sol.mySqrt(x);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public int mySqrt(int x) {\n        if (x == 0) return 0;\n        long left = 1, right = x;\n        while (left <= right) {\n            long mid = (left + right) / 2;\n            if (mid * mid == x) return (int)mid;\n            if (mid * mid < x) left = mid + 1;\n            else right = mid - 1;\n        }\n        return (int)right;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            int x = Integer.parseInt(scanner.nextLine().trim());\n            Main main = new Main();\n            int result = main.mySqrt(x);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def mySqrt(self, x):\n        if x == 0:\n            return 0\n        left, right = 1, x\n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == x:\n                return mid\n            if mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    try:\n        x = int(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.mySqrt(x)\n        sys.stdout.write(str(result))  # Avoid trailing newline\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Computes the integer square root of x.\n * @param {number} x - Non-negative integer\n * @return {number} - Integer square root\n */\nfunction mySqrt(x) {\n    if (x === 0) return 0;\n    let left = 1, right = x;\n    while (left <= right) {\n        let mid = Math.floor((left + right) / 2);\n        if (mid * mid === x) return mid;\n        if (mid * mid < x) left = mid + 1;\n        else right = mid - 1;\n    }\n    return right;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const x = parseInt(line.trim());\n        const result = mySqrt(x);\n        console.log(result);\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    }
  },
  {
    "title": "Subsets",
    "description": "Given a set of distinct integers, nums, return all possible subsets (the power set).\n\n### Problem Statement\n\nYou are given an array **nums** of distinct integers. Compute all possible subsets, including the empty set, without duplicates in the solution set.\n\n**Note**: The solution set must not contain duplicate subsets.\n\n### Input\n\n- **nums**: An array of distinct integers (0 <= nums.length <= 10, -10 <= nums[i] <= 10).\n\n### Output\n\nA list of all possible subsets (each subset is a list of integers). The order of subsets does not matter.\n\n### Example\n\n**Input**: nums = [1,2,3]  \n**Output**: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]  \n**Explanation**: All possible subsets of [1,2,3] are listed.\n\n**Input**: nums = [0]  \n**Output**: [[],[0]]  \n**Explanation**: Subsets are the empty set and [0].\n\n**Input**: nums = []  \n**Output**: [[]]  \n**Explanation**: The only subset of an empty set is the empty set.\n\n### Notes\n\n- Use backtracking or iterative approaches to generate subsets.\n- The power set has 2^n subsets for an array of length n.\n\n### Real-World Context\n\nThis problem is relevant in scenarios like generating all possible combinations of features, options, or configurations, such as in machine learning feature selection or combinatorial optimization.",
    "difficulty": "MEDIUM",
    "tags": [
      "Google",
      "Amazon",
      "VM Ware",
      "JP Morgan",
      "Array",
      "Backtracking",
      "Bit Manipulation"
    ],
    "constraints": [
      "0 <= nums.length <= 10",
      "-10 <= nums[i] <= 10",
      "All integers in nums are distinct",
      "Return all possible subsets without duplicates",
      "Time complexity should be O(2^n), where n is nums.length",
      "Space complexity should be O(2^n) for the output"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
        "explanation": "All possible subsets of [1,2,3] are listed."
      }
    ],
    "testcases": [
      {
        "id": "tc1",
        "input": "[1,2,3]",
        "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
        "isHidden": false,
        "explanation": "All subsets of [1,2,3]"
      },
      {
        "id": "tc2",
        "input": "[0]",
        "output": "[[],[0]]",
        "isHidden": false,
        "explanation": "Subsets of [0]"
      },
      {
        "id": "tc3",
        "input": "[]",
        "output": "[[]]",
        "isHidden": false,
        "explanation": "Empty set has one subset"
      },
      {
        "id": "tc4",
        "input": "[1,2]",
        "output": "[[],[1],[2],[1,2]]",
        "isHidden": true,
        "explanation": "All subsets of [1,2]"
      },
      {
        "id": "tc5",
        "input": "[1]",
        "output": "[[],[1]]",
        "isHidden": true,
        "explanation": "Subsets of [1]"
      }
    ],
    "hints": [
      "1. Use backtracking to build subsets by choosing to include or exclude each element.",
      "2. Alternatively, iterate through numbers 0 to 2^n-1, using their binary representation to select elements.",
      "3. Ensure the empty subset is included in the result."
    ],
    "editorial": "## Editorial: Subsets\n\n### Problem Recap\n\nGenerate all possible subsets of a set of distinct integers.\n\n### Intuition\n\nThe power set of a set with n elements has 2^n subsets, as each element can be included or excluded. Backtracking is a natural approach, systematically exploring all combinations. Alternatively, a bit manipulation approach can map each number from 0 to 2^n-1 to a subset.\n\n### Approaches\n\n#### 1. Backtracking\n\n- **Idea**: Use recursion to decide whether to include each element.\n- **Steps**:\n  1. Initialize an empty result list and current subset.\n  2. For each index i, recursively:\n     - Include nums[i] in the subset, recurse, then backtrack.\n     - Exclude nums[i], recurse.\n  3. Add the current subset to the result at each leaf.\n- **Time Complexity**: O(2^n) to generate all subsets.\n- **Space Complexity**: O(2^n) for output, O(n) for recursion stack.\n- **Pros**: Intuitive, flexible.\n\n#### 2. Iterative (Bit Manipulation)\n\n- **Idea**: Each number from 0 to 2^n-1 represents a subset via its binary bits.\n- **Steps**:\n  1. For each i from 0 to 2^n-1:\n     - Create a subset by checking bits of i.\n     - If the j-th bit is 1, include nums[j].\n  2. Add each subset to the result.\n- **Time Complexity**: O(2^n) for iteration.\n- **Space Complexity**: O(2^n) for output.\n- **Pros**: Non-recursive, concise.\n\n### Recommended Solution\n\nBacktracking is recommended for clarity and ease of understanding.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(2^n) to generate 2^n subsets.\n- **Space Complexity**: O(2^n) for output, O(n) for recursion stack.\n- **Constraints Handling**:\n  - Array length: 0 <= n <= 10.\n  - Values: -10 <= nums[i] <= 10, distinct.\n\n### Edge Cases\n\n- **Empty array**: nums = [] → [[]].\n- **Single element**: nums = [0] → [[],[0]].\n- **Maximum length**: n = 10.\n\n### Implementation Notes\n\n- Use a helper function for backtracking to manage state.\n- Ensure subsets are copied to avoid reference issues.\n- Output format requires JSON array of arrays.\n\n### Visual Explanation\n\nFor nums = [1,2,3]:\n- Backtrack: Start with [], add 1→[1], add 2→[1,2], etc.\n- Result: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]].",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc subsets(nums []int) [][]int {\n    // Write your code here\n    return [][]int{}\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    input = input[1 : len(input)-1]\n    strNums := strings.Split(input, \",\")\n    nums := make([]int, 0)\n    for _, s := range strNums {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        nums = append(nums, num)\n    }\n    result := subsets(nums)\n    fmt.Print(\"[\")\n    for i, subset := range result {\n        fmt.Print(\"[\")\n        for j, num := range subset {\n            fmt.Print(num)\n            if j < len(subset)-1 {\n                fmt.Print(\",\")\n            }\n        }\n        fmt.Print(\"]\")\n        if i < len(result)-1 {\n            fmt.Print(\",\")\n        }\n    }\n    fmt.Println(\"]\")\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        // Write your code here\n        return {};\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        size_t pos = 0;\n        while ((pos = line.find(\",\")) != string::npos) {\n            nums.push_back(stoi(line.substr(0, pos)));\n            line.erase(0, pos + 1);\n        }\n        if (!line.empty()) nums.push_back(stoi(line));\n        Solution sol;\n        vector<vector<int>> result = sol.subsets(nums);\n        cout << \"[\";\n        for (size_t i = 0; i < result.size(); i++) {\n            cout << \"[\";\n            for (size_t j = 0; j < result[i].size(); j++) {\n                cout << result[i][j];\n                if (j < result[i].size() - 1) cout << \",\";\n            }\n            cout << \"]\";\n            if (i < result.size() - 1) cout << \",\";\n        }\n        cout << \"]\" << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Returns all possible subsets of nums.\n     * @param nums Array of distinct integers\n     * @return List of all possible subsets\n     */\n    public List<List<Integer>> subsets(int[] nums) {\n        // Write your code here\n        return new ArrayList<>();\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            String[] strNums = line.substring(1, line.length()-1).split(\",\");\n            int[] nums = new int[strNums.length];\n            for (int i = 0; i < strNums.length; i++) {\n                nums[i] = Integer.parseInt(strNums[i].trim());\n            }\n            Main main = new Main();\n            List<List<Integer>> result = main.subsets(nums);\n            System.out.print(\"[\");\n            for (int i = 0; i < result.size(); i++) {\n                System.out.print(\"[\");\n                for (int j = 0; j < result.get(i).size(); j++) {\n                    System.out.print(result.get(i).get(j));\n                    if (j < result.get(i).size() - 1) System.out.print(\",\");\n                }\n                System.out.print(\"]\");\n                if (i < result.size() - 1) System.out.print(\",\");\n            }\n            System.out.println(\"]\");\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Returns all possible subsets of nums.\n        :param nums: List of distinct integers\n        :return: List of all possible subsets\n        \"\"\"\n        # Write your code here\n        return []\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    import json\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.subsets(nums)\n        print(json.dumps(result))\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Returns all possible subsets of nums.\n * @param {number[]} nums - Array of distinct integers\n * @return {number[][]} - All possible subsets\n */\nfunction subsets(nums) {\n    // Write your code here\n    return [];\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const nums = JSON.parse(line.trim());\n        const result = subsets(nums);\n        console.log(JSON.stringify(result));\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc subsets(nums []int) [][]int {\n    result := [][]int{}\n    var backtrack func(start int, curr []int)\n    backtrack = func(start int, curr []int) {\n        result = append(result, append([]int{}, curr...))\n        for i := start; i < len(nums); i++ {\n            curr = append(curr, nums[i])\n            backtrack(i+1, curr)\n            curr = curr[:len(curr)-1]\n        }\n    }\n    backtrack(0, []int{})\n    return result\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    input = input[1 : len(input)-1]\n    strNums := strings.Split(input, \",\")\n    nums := make([]int, 0)\n    for _, s := range strNums {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        nums = append(nums, num)\n    }\n    result := subsets(nums)\n    fmt.Print(\"[\")\n    for i, subset := range result {\n        fmt.Print(\"[\")\n        for j, num := range subset {\n            fmt.Print(num)\n            if j < len(subset)-1 {\n                fmt.Print(\",\")\n            }\n        }\n        fmt.Print(\"]\")\n        if i < len(result)-1 {\n            fmt.Print(\",\")\n        }\n    }\n    fmt.Println(\"]\")\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> result;\n        vector<int> curr;\n        backtrack(0, nums, curr, result);\n        return result;\n    }\nprivate:\n    void backtrack(int start, vector<int>& nums, vector<int>& curr, vector<vector<int>>& result) {\n        result.push_back(curr);\n        for (int i = start; i < nums.size(); i++) {\n            curr.push_back(nums[i]);\n            backtrack(i + 1, nums, curr, result);\n            curr.pop_back();\n        }\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        size_t pos = 0;\n        while ((pos = line.find(\",\")) != string::npos) {\n            nums.push_back(stoi(line.substr(0, pos)));\n            line.erase(0, pos + 1);\n        }\n        if (!line.empty()) nums.push_back(stoi(line));\n        Solution sol;\n        vector<vector<int>> result = sol.subsets(nums);\n        cout << \"[\";\n        for (size_t i = 0; i < result.size(); i++) {\n            cout << \"[\";\n            for (size_t j = 0; j < result[i].size(); j++) {\n                cout << result[i][j];\n                if (j < result[i].size() - 1) cout << \",\";\n            }\n            cout << \"]\";\n            if (i < result.size() - 1) cout << \",\";\n        }\n        cout << \"]\" << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class Main {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        backtrack(0, nums, new ArrayList<>(), result);\n        return result;\n    }\n\n    private void backtrack(int start, int[] nums, List<Integer> curr, List<List<Integer>> result) {\n        result.add(new ArrayList<>(curr));\n        for (int i = start; i < nums.length; i++) {\n            curr.add(nums[i]);\n            backtrack(i + 1, nums, curr, result);\n            curr.remove(curr.size() - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            String[] strNums = line.substring(1, line.length()-1).split(\",\");\n            int[] nums = new int[strNums.length];\n            for (int i = 0; i < strNums.length; i++) {\n                nums[i] = Integer.parseInt(strNums[i].trim());\n            }\n            Main main = new Main();\n            List<List<Integer>> result = main.subsets(nums);\n            System.out.print(\"[\");\n            for (int i = 0; i < result.size(); i++) {\n                System.out.print(\"[\");\n                for (int j = 0; j < result.get(i).size(); j++) {\n                    System.out.print(result.get(i).get(j));\n                    if (j < result.get(i).size() - 1) System.out.print(\",\");\n                }\n                System.out.print(\"]\");\n                if (i < result.size() - 1) System.out.print(\",\");\n            }\n            System.out.println(\"]\");\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        result = []\n        def backtrack(start: int, curr: List[int]):\n            result.append(curr[:])\n            for i in range(start, len(nums)):\n                curr.append(nums[i])\n                backtrack(i + 1, curr)\n                curr.pop()\n        backtrack(0, [])\n        return result\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    import json\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.subsets(nums)\n        print(json.dumps(result))\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Returns all possible subsets of nums.\n * @param {number[]} nums - Array of distinct integers\n * @return {number[][]} - All possible subsets\n */\nfunction subsets(nums) {\n    const result = [];\n    function backtrack(start, curr) {\n        result.push([...curr]);\n        for (let i = start; i < nums.length; i++) {\n            curr.push(nums[i]);\n            backtrack(i + 1, curr);\n            curr.pop();\n        }\n    }\n    backtrack(0, []);\n    return result;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const nums = JSON.parse(line.trim());\n        const result = subsets(nums);\n        console.log(JSON.stringify(result));\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    }
  },
  {
    "title": "Search in Rotated Sorted Array II",
    "description": "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand (e.g., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array, return true; otherwise, return false.\n\n### Problem Statement\n\nGiven a rotated sorted array **nums** that may contain duplicates, determine if **target** exists in the array.\n\n### Input\n\n- **nums**: An array of integers, sorted and rotated, possibly with duplicates (1 <= nums.length <= 5000, -10^4 <= nums[i] <= 10^4).\n- **target**: An integer to find (-10^4 <= target <= 10^4).\n\n### Output\n\n- A boolean: true if target exists in nums, false otherwise.\n\n### Example\n\n**Input**: nums = [2,5,6,0,0,1,2], target = 0  \n**Output**: true  \n**Explanation**: The target 0 exists in the array.\n\n**Input**: nums = [2,5,6,0,0,1,2], target = 3  \n**Output**: false  \n**Explanation**: The target 3 does not exist in the array.\n\n**Input**: nums = [1], target = 1  \n**Output**: true  \n**Explanation**: The target 1 exists in the single-element array.\n\n### Notes\n\n- Use a modified binary search to handle rotation and duplicates.\n- Duplicates may cause ambiguity in determining which half is sorted, requiring special handling.\n\n### Real-World Context\n\nThis problem models searching in datasets with cyclic or rotated properties, such as time-series data or circular buffers, where duplicates may occur.",
    "difficulty": "MEDIUM",
    "tags": [
      "Array",
      "Binary Search",
      "Amazon",
      "Microsoft",
      "Atlassian"
    ],
    "constraints": [
      "1 <= nums.length <= 5000",
      "-10^4 <= nums[i], target <= 10^4",
      "nums is sorted in ascending order and rotated at some pivot",
      "nums may contain duplicates",
      "Time complexity should be O(log n) on average, O(n) in worst case",
      "Space complexity should be O(1)"
    ],
    "examples": [
      {
        "input": "nums = [2, 5, 6, 0, 0, 1, 2], target = 0",
        "output": "true",
        "explanation": "The target 0 exists in the array."
      }
    ],
    "testcases": [
      {
        "input": "[2,5,6,0,0,1,2]\n0",
        "output": "true",
        "isHidden": false
      },
      {
        "input": "[2,5,6,0,0,1,2]\n3",
        "output": "false",
        "isHidden": false
      },
      {
        "input": "[1]\n1",
        "output": "true",
        "isHidden": false
      },
      {
        "input": "[1,1,1,1]\n2",
        "output": "false",
        "isHidden": true
      },
      {
        "input": "[1,1,2,1]\n2",
        "output": "true",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Use binary search, but account for duplicates which may make it harder to determine the sorted half.",
      "2. When nums[mid] == nums[high], you cannot determine which half is sorted, so exclude the high element and continue.",
      "3. Compare nums[mid] with nums[high] to decide which half to search."
    ],
    "editorial": "## Editorial: Search in Rotated Sorted Array II\n\n### Problem Recap\n\nSearch for a target in a rotated sorted array that may contain duplicates.\n\n### Intuition\n\nThis is a variation of binary search. The array is sorted but rotated, and duplicates complicate determining which half is sorted. When nums[mid] equals nums[high], we cannot decide, so we skip the high element and continue.\n\n### Approaches\n\n#### 1. Modified Binary Search\n\n- **Idea**: Adapt binary search to handle rotation and duplicates.\n- **Steps**:\n  1. Initialize low = 0, high = n-1.\n  2. While low <= high:\n     - Compute mid.\n     - If nums[mid] == target, return true.\n     - If nums[mid] == nums[high], decrement high (cannot determine sorted half).\n     - If nums[mid] < nums[high], right half is sorted:\n       - If target is in right half, search right; else, search left.\n     - If nums[mid] > nums[high], left half is sorted:\n       - If target is in left half, search left; else, search right.\n  3. Return false if not found.\n- **Time Complexity**: O(log n) average, O(n) worst case due to duplicates.\n- **Space Complexity**: O(1).\n- **Pros**: Handles all cases efficiently.\n\n### Recommended Solution\n\nModified binary search is the only practical approach.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(log n) average, O(n) worst case when duplicates force linear-like behavior.\n- **Space Complexity**: O(1).\n- **Constraints Handling**:\n  - Array length: 1 <= n <= 5000.\n  - Values: -10^4 <= nums[i], target <= 10^4.\n\n### Edge Cases\n\n- **Single element**: nums = [1], target = 1 → true.\n- **All same values**: nums = [1,1,1], target = 2 → false.\n- **Duplicates at pivot**: nums = [1,1,2,1], target = 2 → true.\n\n### Implementation Notes\n\n- Handle nums[mid] == nums[high] by decrementing high.\n- Use strict inequalities to avoid infinite loops.\n- Output as boolean (true/false).\n\n### Visual Explanation\n\nFor nums = [2,5,6,0,0,1,2], target = 0:\n- Binary search adjusts for rotation, finds 0 in right half.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"bufio\"\n    \"os\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc search(nums []int, target int) bool {\n    // Write your code here\n    return false\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    var lines []string\n    for scanner.Scan() {\n        lines = append(lines, strings.TrimSpace(scanner.Text()))\n        if len(lines) == 2 {\n            break\n        }\n    }\n    if len(lines) != 2 {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    input := strings.TrimSpace(lines[0])[1 : len(lines[0])-1]\n    strNums := strings.Split(input, \",\")\n    nums := make([]int, len(strNums))\n    for i, s := range strNums {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        nums[i] = num\n    }\n    target, err := strconv.Atoi(strings.TrimSpace(lines[1]))\n    if err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := search(nums, target)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        // Write your code here\n        return false;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        int target;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        cin >> target;\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        size_t pos = 0;\n        while ((pos = line.find(\",\")) != string::npos) {\n            nums.push_back(stoi(line.substr(0, pos)));\n            line.erase(0, pos + 1);\n        }\n        if (!line.empty()) nums.push_back(stoi(line));\n        Solution sol;\n        bool result = sol.search(nums, target);\n        cout << (result ? \"true\" : \"false\") << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Searches for a target in a rotated sorted array.\n     * @param nums Array of integers\n     * @param target Value to find\n     * @return True if target exists, false otherwise\n     */\n    public boolean search(int[] nums, int target) {\n        // Write your code here\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            int target = Integer.parseInt(scanner.nextLine().trim());\n            String[] strNums = line.substring(1, line.length()-1).split(\",\");\n            int[] nums = new int[strNums.length];\n            for (int i = 0; i < strNums.length; i++) {\n                nums[i] = Integer.parseInt(strNums[i].trim());\n            }\n            Main main = new Main();\n            boolean result = main.search(nums, target);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import json\nimport sys\n\nclass Solution:\n    def search(self, nums, target):\n        \"\"\"\n        Checks if target exists in a rotated sorted array.\n        :param nums: List of integers\n        :param target: Integer to find\n        :return: True if target exists, false otherwise\n        \"\"\"\n        # Write your code here\n        return False\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        target = int(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.search(nums, target)\n        sys.stdout.write(str(result).lower())  # Output 'true' or 'false' without newline\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Searches for a target in a rotated sorted array.\n * @param {number[]} nums - Rotated sorted array\n * @param {number} target - Value to find\n * @return {boolean}\n */\nfunction search(nums, target) {\n    // Write your code here\n    return false;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nlet lines = [];\nrl.on(\"line\", (line) => {\n    lines.push(line.trim());\n    if (lines.length === 2) {\n        try {\n            const nums = JSON.parse(lines[0]);\n            const target = parseInt(lines[1]);\n            const result = search(nums, target);\n            console.log(result);\n            rl.close();\n        } catch (e) {\n            console.log(\"Invalid input format\");\n            process.exit(1);\n        }\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"bufio\"\n    \"os\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc search(nums []int, target int) bool {\n    low, high := 0, len(nums)-1\n    for low <= high {\n        mid := (low + high) / 2\n        if nums[mid] == target {\n            return true\n        }\n        if nums[mid] == nums[high] {\n            high--\n        } else if nums[mid] < nums[high] {\n            if nums[mid] < target && target <= nums[high] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if nums[low] <= target && target < nums[mid] {\n                high = mid - 1\n            } else {\n                low = mid + 1\n            }\n        }\n    }\n    return false\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    var lines []string\n    for scanner.Scan() {\n        lines = append(lines, strings.TrimSpace(scanner.Text()))\n        if len(lines) == 2 {\n            break\n        }\n    }\n    if len(lines) != 2 {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    input := strings.TrimSpace(lines[0])[1 : len(lines[0])-1]\n    strNums := strings.Split(input, \",\")\n    nums := make([]int, len(strNums))\n    for i, s := range strNums {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        nums[i] = num\n    }\n    target, err := strconv.Atoi(strings.TrimSpace(lines[1]))\n    if err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := search(nums, target)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        int low = 0, high = nums.size() - 1;\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (nums[mid] == target) return true;\n            if (nums[mid] == nums[high]) {\n                high--;\n            } else if (nums[mid] < nums[high]) {\n                if (nums[mid] < target && target <= nums[high]) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            } else {\n                if (nums[low] <= target && target < nums[mid]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n        }\n        return false;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        int target;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        cin >> target;\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        size_t pos = 0;\n        while ((pos = line.find(\",\")) != string::npos) {\n            nums.push_back(stoi(line.substr(0, pos)));\n            line.erase(0, pos + 1);\n        }\n        if (!line.empty()) nums.push_back(stoi(line));\n        Solution sol;\n        bool result = sol.search(nums, target);\n        cout << (result ? \"true\" : \"false\") << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public boolean search(int[] nums, int target) {\n        int low = 0, high = nums.length - 1;\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (nums[mid] == target) return true;\n            if (nums[mid] == nums[high]) {\n                high--;\n            } else if (nums[mid] < nums[high]) {\n                if (nums[mid] < target && target <= nums[high]) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            } else {\n                if (nums[low] <= target && target < nums[mid]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            int target = Integer.parseInt(scanner.nextLine().trim());\n            String[] strNums = line.substring(1, line.length()-1).split(\",\");\n            int[] nums = new int[strNums.length];\n            for (int i = 0; i < strNums.length; i++) {\n                nums[i] = Integer.parseInt(strNums[i].trim());\n            }\n            Main main = new Main();\n            boolean result = main.search(nums, target);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import json\nimport sys\n\nclass Solution:\n    def search(self, nums, target):\n        low, high = 0, len(nums) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == target:\n                return True\n            if nums[mid] == nums[high]:\n                high -= 1\n            elif nums[mid] < nums[high]:\n                if nums[mid] < target <= nums[high]:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            else:\n                if nums[low] <= target < nums[mid]:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n        return False\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        target = int(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.search(nums, target)\n        sys.stdout.write(str(result).lower())  # Output 'true' or 'false' without newline\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Searches for a target in a rotated sorted array.\n * @param {number[]} nums - Rotated sorted array\n * @param {number} target - Value to find\n * @return {boolean}\n */\nfunction search(nums, target) {\n    let low = 0, high = nums.length - 1;\n    while (low <= high) {\n        let mid = Math.floor((low + high) / 2);\n        if (nums[mid] === target) return true;\n        if (nums[mid] === nums[high]) {\n            high--;\n        } else if (nums[mid] < nums[high]) {\n            if (nums[mid] < target && target <= nums[high]) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            if (nums[low] <= target && target < nums[mid]) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n    return false;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nlet lines = [];\nrl.on(\"line\", (line) => {\n    lines.push(line.trim());\n    if (lines.length === 2) {\n        try {\n            const nums = JSON.parse(lines[0]);\n            const target = parseInt(lines[1]);\n            const result = search(nums, target);\n            console.log(result);\n            rl.close();\n        } catch (e) {\n            console.log(\"Invalid input format\");\n            process.exit(1);\n        }\n    }\n});"
    }
  },
  {
    "title": "Second Smallest and Second Largest Element in an Array",
    "description": "Given an array of integers, find the second smallest and second largest elements in the array.\n\n### Problem Statement\n\nYou are given an array **nums** containing n integers. Find and return the second smallest and second largest elements as a pair [secondSmallest, secondLargest]. If the array has fewer than 2 elements, return [-1, -1].\n\n### Input\n\n- **nums**: An array of integers (2 <= nums.length <= 100, -10^5 <= nums[i] <= 10^5).\n\n### Output\n\n- An array of two integers: [secondSmallest, secondLargest]. If n < 2, return [-1, -1].\n\n### Example\n\n**Input**: nums = [4, 2, 7, 1, 9]  \n**Output**: [2, 7]  \n**Explanation**: The smallest is 1, second smallest is 2, largest is 9, second largest is 7.\n\n**Input**: nums = [3, 3, 3, 3]  \n**Output**: [-1, -1]  \n**Explanation**: All elements are the same, so no second smallest/largest exists.\n\n**Input**: nums = [1, 2]  \n**Output**: [-1, -1]  \n**Explanation**: Only two elements, so no second smallest/largest exists.\n\n### Notes\n\n- A single pass can track both the smallest, second smallest, largest, and second largest.\n- Handle cases where elements are repeated or the array is too small.\n\n### Real-World Context\n\nThis problem is useful in scenarios like finding the second-best performer in a dataset or the second-lowest price in a product list, common in analytics tasks at companies like TCS and Infosys.",
    "difficulty": "EASY",
    "tags": [
      "Array",
      "Linear Scan",
      "Tcs",
      "Infosys"
    ],
    "constraints": [
      "2 <= nums.length <= 100",
      "-10^5 <= nums[i] <= 10^5",
      "Return [-1, -1] if second smallest or second largest does not exist",
      "Time complexity should be O(n)",
      "Space complexity should be O(1)"
    ],
    "examples": [
      {
        "input": "nums = [4, 2, 7, 1, 9]",
        "output": "9",
        "explanation": "The largest number in the array is 9."
      }
    ],
    "testcases": [
      {
        "input": "[4,2,7,1,9]",
        "output": "[2,7]",
        "isHidden": false
      },
      {
        "input": "[3,3,3,3]",
        "output": "[-1,-1]",
        "isHidden": false
      },
      {
        "input": "[1,2]",
        "output": "[-1,-1]",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Use a single pass to track smallest, second smallest, largest, and second largest.",
      "2. Initialize smallest and second smallest to large values, largest and second largest to small values.",
      "3. Handle cases where all elements are identical or array length is less than 2."
    ],
    "editorial": "## Editorial: Second Smallest and Second Largest Element in an Array\n\n### Problem Recap\n\nFind the second smallest and second largest elements in an array, returning [-1, -1] if they don’t exist.\n\n### Intuition\n\nA single pass through the array can track the smallest, second smallest, largest, and second largest elements by updating them appropriately. The challenge is handling cases with fewer than 2 elements or identical elements.\n\n### Approach\n\n#### Linear Scan\n\n- **Idea**: Track four variables: smallest, second smallest, largest, and second largest.\n- **Steps**:\n  1. If nums.length < 2, return [-1, -1].\n  2. Initialize smallest and second smallest to a large number, largest and second largest to a small number.\n  3. For each element:\n     - Update smallest and second smallest if the element is smaller.\n     - Update largest and second largest if the element is larger.\n  4. If second smallest or second largest wasn’t updated (still initial values), return [-1, -1].\n  5. Return [secondSmallest, secondLargest].\n- **Time Complexity**: O(n) for one pass.\n- **Space Complexity**: O(1) for four variables.\n\n### Recommended Solution\n\nThe linear scan approach is optimal for its simplicity and efficiency.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for iterating through the array.\n- **Space Complexity**: O(1) for storing four variables.\n- **Constraints Handling**:\n  - Array length: 2 <= n <= 100.\n  - Values: -10^5 <= nums[i] <= 10^5.\n\n### Edge Cases\n\n- **Less than 2 elements**: nums = [1] → [-1, -1].\n- **All same values**: nums = [3,3,3] → [-1, -1].\n- **Two elements**: nums = [1,2] → [-1, -1].\n- **Distinct values**: nums = [4,2,7,1,9] → [2,7].\n\n### Implementation Notes\n\n- Initialize variables to avoid incorrect updates.\n- Check if second smallest/largest were updated before returning.\n- Handle edge cases explicitly in the code.\n\n### Visual Explanation\n\nFor nums = [4,2,7,1,9]:\n- Initialize: smallest=∞, secondSmallest=∞, largest=-∞, secondLargest=-∞.\n- After pass: smallest=1, secondSmallest=2, largest=9, secondLargest=7.\n- Return [2,7].",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc findSecondSmallestLargest(nums []int) []int {\n    // Write your code here\n    return []int{-1, -1}\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Print(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    nums := make([]int, 0)\n    if input == \"[]\" {\n        // Handle empty array\n    } else {\n        input = input[1 : len(input)-1]\n        strNums := strings.Split(input, \",\")\n        for _, s := range strNums {\n            num, err := strconv.Atoi(strings.TrimSpace(s))\n            if err != nil {\n                fmt.Print(\"Invalid input format\")\n                return\n            }\n            nums = append(nums, num)\n        }\n    }\n    result := findSecondSmallestLargest(nums)\n    fmt.Print(\"[\" + strconv.Itoa(result[0]) + \",\" + strconv.Itoa(result[1]) + \"]\") // Output without newline\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\n#include <climits> \nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findSecondSmallestLargest(vector<int>& nums) {\n        // Write your code here\n        return {-1, -1};\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\";\n            return 1;\n        }\n        vector<int> nums;\n        if (line == \"[]\") {\n            // Handle empty array\n        } else {\n            line = line.substr(1, line.length()-2);\n            size_t pos = 0;\n            while ((pos = line.find(\",\")) != string::npos) {\n                nums.push_back(stoi(line.substr(0, pos)));\n                line.erase(0, pos + 1);\n            }\n            if (!line.empty()) nums.push_back(stoi(line));\n        }\n        Solution sol;\n        vector<int> result = sol.findSecondSmallestLargest(nums);\n        cout << \"[\" << result[0] << \",\" << result[1] << \"]\"; // Output without newline\n    } catch (...) {\n        cout << \"Invalid input format\";\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Finds the second smallest and second largest elements in an array.\n     * @param nums Array of integers\n     * @return [secondSmallest, secondLargest] or [-1,-1] if not possible\n     */\n    public int[] findSecondSmallestLargest(int[] nums) {\n        // Write your code here\n        return new int[]{-1, -1};\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            int[] nums;\n            if (line.equals(\"[]\")) {\n                nums = new int[0]; // Handle empty array\n            } else {\n                String[] strNums = line.substring(1, line.length()-1).split(\",\");\n                nums = new int[strNums.length];\n                for (int i = 0; i < strNums.length; i++) {\n                    nums[i] = Integer.parseInt(strNums[i].trim());\n                }\n            }\n            Main main = new Main();\n            int[] result = main.findSecondSmallestLargest(nums);\n            System.out.print(\"[\" + result[0] + \",\" + result[1] + \"]\"); // Output without newline\n        } catch (Exception e) {\n            System.out.print(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import sys\nimport json\n\nclass Solution:\n    def findSecondSmallestLargest(self, nums):\n        \"\"\"\n        Finds the second smallest and second largest elements in an array.\n        :param nums: List of integers\n        :return: [secondSmallest, secondLargest] or [-1,-1] if not possible\n        \"\"\"\n        # Write your code here\n        return [-1, -1]\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.findSecondSmallestLargest(nums)\n        sys.stdout.write(\"[%d,%d]\" % (result[0], result[1]))  # Output without spaces or newline\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds the second smallest and second largest elements in an array.\n * @param {number[]} nums - Array of integers\n * @return {number[]} - [secondSmallest, secondLargest] or [-1,-1] if not possible\n */\nfunction findSecondSmallestLargest(nums) {\n    // Write your code here\n    return [-1, -1];\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const nums = JSON.parse(line.trim());\n        const result = findSecondSmallestLargest(nums);\n        process.stdout.write(JSON.stringify(result)); // Output without newline\n        rl.close();\n    } catch (e) {\n        process.stdout.write(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n    \"math\"\n)\n\nfunc findSecondSmallestLargest(nums []int) []int {\n    if len(nums) <= 2 { // Handle n <= 2\n        return []int{-1, -1}\n    }\n    smallest, secondSmallest := math.MaxInt32, math.MaxInt32\n    largest, secondLargest := math.MinInt32, math.MinInt32\n    for _, num := range nums {\n        if num < smallest {\n            secondSmallest = smallest\n            smallest = num\n        } else if num < secondSmallest && num != smallest {\n            secondSmallest = num\n        }\n        if num > largest {\n            secondLargest = largest\n            largest = num\n        } else if num > secondLargest && num != largest {\n            secondLargest = num\n        }\n    }\n    if secondSmallest == math.MaxInt32 || secondLargest == math.MinInt32 {\n        return []int{-1, -1}\n    }\n    return []int{secondSmallest, secondLargest}\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Print(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    nums := make([]int, 0)\n    if input == \"[]\" {\n        // Handle empty array\n    } else {\n        input = input[1 : len(input)-1]\n        strNums := strings.Split(input, \",\")\n        for _, s := range strNums {\n            num, err := strconv.Atoi(strings.TrimSpace(s))\n            if err != nil {\n                fmt.Print(\"Invalid input format\")\n                return\n            }\n            nums = append(nums, num)\n        }\n    }\n    result := findSecondSmallestLargest(nums)\n    fmt.Print(\"[\" + strconv.Itoa(result[0]) + \",\" + strconv.Itoa(result[1]) + \"]\") // Output without newline\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\n#include <climits> \nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findSecondSmallestLargest(vector<int>& nums) {\n        if (nums.size() <= 2) return {-1, -1}; // Handle n <= 2\n        int smallest = INT_MAX, secondSmallest = INT_MAX;\n        int largest = INT_MIN, secondLargest = INT_MIN;\n        for (int num : nums) {\n            if (num < smallest) {\n                secondSmallest = smallest;\n                smallest = num;\n            } else if (num < secondSmallest && num != smallest) {\n                secondSmallest = num;\n            }\n            if (num > largest) {\n                secondLargest = largest;\n                largest = num;\n            } else if (num > secondLargest && num != largest) {\n                secondLargest = num;\n            }\n        }\n        if (secondSmallest == INT_MAX || secondLargest == INT_MIN) return {-1, -1};\n        return {secondSmallest, secondLargest};\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\";\n            return 1;\n        }\n        vector<int> nums;\n        if (line == \"[]\") {\n            // Handle empty array\n        } else {\n            line = line.substr(1, line.length()-2);\n            size_t pos = 0;\n            while ((pos = line.find(\",\")) != string::npos) {\n                nums.push_back(stoi(line.substr(0, pos)));\n                line.erase(0, pos + 1);\n            }\n            if (!line.empty()) nums.push_back(stoi(line));\n        }\n        Solution sol;\n        vector<int> result = sol.findSecondSmallestLargest(nums);\n        cout << \"[\" << result[0] << \",\" << result[1] << \"]\"; // Output without newline\n    } catch (...) {\n        cout << \"Invalid input format\";\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public int[] findSecondSmallestLargest(int[] nums) {\n        if (nums.length <= 2) return new int[]{-1, -1}; // Handle n <= 2\n        int smallest = Integer.MAX_VALUE, secondSmallest = Integer.MAX_VALUE;\n        int largest = Integer.MIN_VALUE, secondLargest = Integer.MIN_VALUE;\n        for (int num : nums) {\n            if (num < smallest) {\n                secondSmallest = smallest;\n                smallest = num;\n            } else if (num < secondSmallest && num != smallest) {\n                secondSmallest = num;\n            }\n            if (num > largest) {\n                secondLargest = largest;\n                largest = num;\n            } else if (num > secondLargest && num != largest) {\n                secondLargest = num;\n            }\n        }\n        if (secondSmallest == Integer.MAX_VALUE || secondLargest == Integer.MIN_VALUE) {\n            return new int[]{-1, -1};\n        }\n        return new int[]{secondSmallest, secondLargest};\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            int[] nums;\n            if (line.equals(\"[]\")) {\n                nums = new int[0]; // Handle empty array\n            } else {\n                String[] strNums = line.substring(1, line.length()-1).split(\",\");\n                nums = new int[strNums.length];\n                for (int i = 0; i < strNums.length; i++) {\n                    nums[i] = Integer.parseInt(strNums[i].trim());\n                }\n            }\n            Main main = new Main();\n            int[] result = main.findSecondSmallestLargest(nums);\n            System.out.print(\"[\" + result[0] + \",\" + result[1] + \"]\"); // Output without newline\n        } catch (Exception e) {\n            System.out.print(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import sys\nimport json\n\nclass Solution:\n    def findSecondSmallestLargest(self, nums):\n        if len(nums) <= 2:\n            return [-1, -1]\n        smallest, second_smallest = float('inf'), float('inf')\n        largest, second_largest = float('-inf'), float('-inf')\n        for num in nums:\n            if num < smallest:\n                second_smallest = smallest\n                smallest = num\n            elif num < second_smallest and num != smallest:\n                second_smallest = num\n            if num > largest:\n                second_largest = largest\n                largest = num\n            elif num > second_largest and num != largest:\n                second_largest = num\n        if second_smallest == float('inf') or second_largest == float('-inf'):\n            return [-1, -1]\n        return [second_smallest, second_largest]\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.findSecondSmallestLargest(nums)\n        sys.stdout.write(\"[%d,%d]\" % (result[0], result[1]))  # Output without spaces or newline\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds the second smallest and second largest elements in an array.\n * @param {number[]} nums - Array of integers\n * @return {number[]} - [secondSmallest, secondLargest] or [-1,-1] if not possible\n */\nfunction findSecondSmallestLargest(nums) {\n    if (nums.length <= 2) return [-1, -1]; // Handle n <= 2\n    let smallest = Infinity, secondSmallest = Infinity;\n    let largest = -Infinity, secondLargest = -Infinity;\n    for (let num of nums) {\n        if (num < smallest) {\n            secondSmallest = smallest;\n            smallest = num;\n        } else if (num < secondSmallest && num !== smallest) {\n            secondSmallest = num;\n        }\n        if (num > largest) {\n            secondLargest = largest;\n            largest = num;\n        } else if (num > secondLargest && num !== largest) {\n            secondLargest = num;\n        }\n    }\n    if (secondSmallest === Infinity || secondLargest === -Infinity) return [-1, -1];\n    return [secondSmallest, secondLargest];\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const nums = JSON.parse(line.trim());\n        const result = findSecondSmallestLargest(nums);\n        process.stdout.write(JSON.stringify(result)); // Output without newline\n        rl.close();\n    } catch (e) {\n        process.stdout.write(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    }
  },
  {
    "title": "Count Frequency of Each Element in an Array",
    "description": "Given an array of integers, count the frequency of each element in the array and return the result as a map/dictionary.\n\n### Problem Statement\n\nYou are given an array **nums** containing n integers. Return a map/dictionary where the keys are the unique elements in the array and the values are their respective frequencies. If the array is empty, return an empty map/dictionary.\n\n### Input\n\n- **nums**: An array of integers (0 <= nums.length <= 100, -10^5 <= nums[i] <= 10^5).\n\n### Output\n\n- A map/dictionary with keys as unique integers and values as their frequencies.\n\n### Example\n\n**Input**: nums = [1,2,2,3,1,4]  \n**Output**: {1:2, 2:2, 3:1, 4:1}  \n**Explanation**: 1 appears twice, 2 appears twice, 3 appears once, 4 appears once.\n\n**Input**: nums = [1]  \n**Output**: {1:1}  \n**Explanation**: 1 appears once.\n\n**Input**: nums = []  \n**Output**: {}  \n**Explanation**: The array is empty, so return an empty map.\n\n### Notes\n\n- Use a hash map/dictionary to store the frequency of each element.\n- Handle the empty array case by returning an empty map.\n\n### Real-World Context\n\nThis problem is common in data analysis tasks, such as counting occurrences of items in a dataset (e.g., product sales or user actions), frequently encountered in companies like TCS, Infosys, and Oracle.",
    "difficulty": "EASY",
    "tags": [
      "Tcs",
      "Infosys",
      "Array",
      "Hash Map"
    ],
    "constraints": [
      "0 <= nums.length <= 100",
      "-10^5 <= nums[i] <= 10^5",
      "Return a map/dictionary with element frequencies",
      "Time complexity should be O(n)",
      "Space complexity should be O(n) for the map"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 2, 3, 1, 4]",
        "output": "{1:2, 2:2, 3:1, 4:1}",
        "explanation": "1 appears twice, 2 appears twice, 3 appears once, 4 appears once."
      }
    ],
    "testcases": [
      {
        "input": "[1,2,2,3,1,4]",
        "output": "{1:2,2:2,3:1,4:1}",
        "isHidden": false
      },
      {
        "input": "[1]",
        "output": "{1:1}",
        "isHidden": false
      },
      {
        "input": "[]",
        "output": "{}",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Use a hash map/dictionary to store the count of each element.",
      "2. Iterate through the array once, incrementing the count for each element in the map.",
      "3. Handle the empty array case by returning an empty map."
    ],
    "editorial": "## Editorial: Count Frequency of Each Element in an Array\n\n### Problem Recap\n\nCount the frequency of each element in an array and return the result as a map/dictionary.\n\n### Intuition\n\nA hash map/dictionary is the most efficient data structure for this task, as it allows us to store and update element counts in O(1) time per element. A single pass through the array populates the map with frequencies.\n\n### Approach\n\n#### Hash Map Approach\n\n- **Idea**: Use a hash map to store each element as a key and its frequency as the value.\n- **Steps**:\n  1. Initialize an empty hash map/dictionary.\n  2. Iterate through the array, incrementing the count for each element in the map.\n  3. If an element is not in the map, add it with a count of 1.\n  4. Return the map.\n- **Time Complexity**: O(n) for one pass through the array.\n- **Space Complexity**: O(n) for storing up to n unique elements in the map.\n\n### Recommended Solution\n\nThe hash map approach is optimal for its simplicity and linear time complexity.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for iterating through the array.\n- **Space Complexity**: O(n) for the hash map in the worst case.\n- **Constraints Handling**:\n  - Array length: 0 <= n <= 100.\n  - Values: -10^5 <= nums[i] <= 10^5.\n\n### Edge Cases\n\n- **Empty array**: nums = [] → {}.\n- **Single element**: nums = [1] → {1:1}.\n- **All same elements**: nums = [2,2,2] → {2:3}.\n- **All unique elements**: nums = [1,2,3] → {1:1, 2:1, 3:1}.\n\n### Implementation Notes\n\n- Ensure the map handles negative numbers as keys.\n- Return an empty map for an empty array.\n- Format the output according to the language’s map/dictionary syntax.\n\n### Visual Explanation\n\nFor nums = [1,2,2,3,1,4]:\n- Initialize map = {}.\n- Process: map[1]=1, map[2]=1, map[2]=2, map[3]=1, map[1]=2, map[4]=1.\n- Final: {1:2, 2:2, 3:1, 4:1}.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc countFrequency(nums []int) map[int]int {\n    // Write your code here\n    return make(map[int]int)\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Print(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    nums := make([]int, 0)\n    if input == \"[]\" {\n        // Handle empty array\n    } else {\n        input = input[1 : len(input)-1]\n        strNums := strings.Split(input, \",\")\n        nums = make([]int, len(strNums))\n        for i, s := range strNums {\n            num, err := strconv.Atoi(strings.TrimSpace(s))\n            if err != nil {\n                fmt.Print(\"Invalid input format\")\n                return\n            }\n            nums[i] = num\n        }\n    }\n    result := countFrequency(nums)\n    fmt.Print(\"{\")\n    i := 0\n    for k, v := range result {\n        fmt.Printf(\"%d:%d\", k, v)\n        if i < len(result)-1 {\n            fmt.Print(\",\")\n        }\n        i++\n    }\n    fmt.Print(\"}\") // Output without newline\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <map> // For sorted output\nusing namespace std;\n\nclass Solution {\npublic:\n    unordered_map<int, int> countFrequency(vector<int>& nums) {\n        // Write your code here\n        return unordered_map<int, int>();\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\";\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        if (line == \"\") {\n            // Handle empty array\n        } else {\n            size_t pos = 0;\n            while ((pos = line.find(\",\")) != string::npos) {\n                nums.push_back(stoi(line.substr(0, pos)));\n                line.erase(0, pos + 1);\n            }\n            if (!line.empty()) nums.push_back(stoi(line));\n        }\n        Solution sol;\n        unordered_map<int, int> result = sol.countFrequency(nums);\n        // Convert to map for sorted keys\n        map<int, int> sorted_result(result.begin(), result.end());\n        cout << \"{\";\n        size_t i = 0;\n        for (const auto& pair : sorted_result) {\n            cout << pair.first << \":\" << pair.second;\n            if (i < sorted_result.size() - 1) cout << \",\";\n            i++;\n        }\n        cout << \"}\"; // Output without newline\n    } catch (...) {\n        cout << \"Invalid input format\";\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.*;\n\npublic class Main {\n    /**\n     * Counts frequency of each element in an array.\n     * @param nums Array of integers\n     * @return Map of element frequencies\n     */\n    public Map<Integer, Integer> countFrequency(int[] nums) {\n        // Write your code here\n        return new HashMap<>();\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            int[] nums;\n            if (line.equals(\"[]\")) {\n                nums = new int[0]; // Handle empty array\n            } else {\n                String[] strNums = line.substring(1, line.length()-1).split(\",\");\n                nums = new int[strNums.length];\n                for (int i = 0; i < strNums.length; i++) {\n                    nums[i] = Integer.parseInt(strNums[i].trim());\n                }\n            }\n            Main main = new Main();\n            Map<Integer, Integer> result = main.countFrequency(nums);\n            System.out.print(\"{\");\n            int i = 0;\n            for (Map.Entry<Integer, Integer> entry : result.entrySet()) {\n                System.out.print(entry.getKey() + \":\" + entry.getValue());\n                if (i < result.size() - 1) System.out.print(\",\");\n                i++;\n            }\n            System.out.print(\"}\"); // Output without newline\n        } catch (Exception e) {\n            System.out.print(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import sys\nimport json\n\nclass Solution:\n    def countFrequency(self, nums):\n        \"\"\"\n        Counts frequency of each element in an array.\n        :param nums: List of integers\n        :return: Dictionary with element frequencies\n        \"\"\"\n        # Write your code here\n        return {}\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.countFrequency(nums)\n        output = \"{\"\n        items = list(result.items())\n        for i, (k, v) in enumerate(items):\n            output += \"%d:%d\" % (k, v)  # Python 2.7-compatible formatting\n            if i < len(items) - 1:\n                output += \",\"\n        output += \"}\"\n        sys.stdout.write(output)  # Output without newline\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Counts frequency of each element in an array.\n * @param {number[]} nums - Array of integers\n * @return {Object} - Map of element frequencies\n */\nfunction countFrequency(nums) {\n    // Write your code here\n    return {};\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        line = line.trim();\n        let nums = [];\n        if (line !== \"[]\") {\n            nums = JSON.parse(line);\n        }\n        const result = countFrequency(nums);\n        let output = \"{\";\n        let entries = Object.entries(result);\n        for (let i = 0; i < entries.length; i++) {\n            output += entries[i][0] + \":\" + entries[i][1];\n            if (i < entries.length - 1) output += \",\";\n        }\n        output += \"}\";\n        console.log(output); // Output without newline\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc countFrequency(nums []int) map[int]int {\n    freq := make(map[int]int)\n    for _, num := range nums {\n        freq[num]++\n    }\n    return freq\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Print(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    nums := make([]int, 0)\n    if input == \"[]\" {\n        // Handle empty array\n    } else {\n        input = input[1 : len(input)-1]\n        strNums := strings.Split(input, \",\")\n        nums = make([]int, len(strNums))\n        for i, s := range strNums {\n            num, err := strconv.Atoi(strings.TrimSpace(s))\n            if err != nil {\n                fmt.Print(\"Invalid input format\")\n                return\n            }\n            nums[i] = num\n        }\n    }\n    result := countFrequency(nums)\n    fmt.Print(\"{\")\n    i := 0\n    for k, v := range result {\n        fmt.Printf(\"%d:%d\", k, v)\n        if i < len(result)-1 {\n            fmt.Print(\",\")\n        }\n        i++\n    }\n    fmt.Print(\"}\") // Output without newline\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <map> // For sorted output\nusing namespace std;\n\nclass Solution {\npublic:\n    unordered_map<int, int> countFrequency(vector<int>& nums) {\n        unordered_map<int, int> freq;\n        for (int num : nums) {\n            freq[num]++;\n        }\n        return freq;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\";\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        if (line == \"\") {\n            // Handle empty array\n        } else {\n            size_t pos = 0;\n            while ((pos = line.find(\",\")) != string::npos) {\n                nums.push_back(stoi(line.substr(0, pos)));\n                line.erase(0, pos + 1);\n            }\n            if (!line.empty()) nums.push_back(stoi(line));\n        }\n        Solution sol;\n        unordered_map<int, int> result = sol.countFrequency(nums);\n        // Convert to map for sorted keys\n        map<int, int> sorted_result(result.begin(), result.end());\n        cout << \"{\";\n        size_t i = 0;\n        for (const auto& pair : sorted_result) {\n            cout << pair.first << \":\" << pair.second;\n            if (i < sorted_result.size() - 1) cout << \",\";\n            i++;\n        }\n        cout << \"}\"; // Output without newline\n    } catch (...) {\n        cout << \"Invalid input format\";\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.*;\n\npublic class Main {\n    public Map<Integer, Integer> countFrequency(int[] nums) {\n        Map<Integer, Integer> freq = new HashMap<>();\n        for (int num : nums) {\n            freq.put(num, freq.getOrDefault(num, 0) + 1);\n        }\n        return freq;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            int[] nums;\n            if (line.equals(\"[]\")) {\n                nums = new int[0]; // Handle empty array\n            } else {\n                String[] strNums = line.substring(1, line.length()-1).split(\",\");\n                nums = new int[strNums.length];\n                for (int i = 0; i < strNums.length; i++) {\n                    nums[i] = Integer.parseInt(strNums[i].trim());\n                }\n            }\n            Main main = new Main();\n            Map<Integer, Integer> result = main.countFrequency(nums);\n            System.out.print(\"{\");\n            int i = 0;\n            for (Map.Entry<Integer, Integer> entry : result.entrySet()) {\n                System.out.print(entry.getKey() + \":\" + entry.getValue());\n                if (i < result.size() - 1) System.out.print(\",\");\n                i++;\n            }\n            System.out.print(\"}\"); // Output without newline\n        } catch (Exception e) {\n            System.out.print(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import sys\nimport json\n\nclass Solution:\n    def countFrequency(self, nums):\n        freq = {}\n        for num in nums:\n            freq[num] = freq.get(num, 0) + 1\n        return freq\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.countFrequency(nums)\n        output = \"{\"\n        items = list(result.items())\n        for i, (k, v) in enumerate(items):\n            output += \"%d:%d\" % (k, v)  # Python 2.7-compatible formatting\n            if i < len(items) - 1:\n                output += \",\"\n        output += \"}\"\n        sys.stdout.write(output)  # Output without newline\n    except Exception:\n        sys.stdout.write(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Counts frequency of each element in an array.\n * @param {number[]} nums - Array of integers\n * @return {Object} - Map of element frequencies\n */\nfunction countFrequency(nums) {\n    const freq = {};\n    for (let num of nums) {\n        freq[num] = (freq[num] || 0) + 1;\n    }\n    return freq;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        line = line.trim();\n        let nums = [];\n        if (line !== \"[]\") {\n            nums = JSON.parse(line);\n        }\n        const result = countFrequency(nums);\n        let output = \"{\";\n        let entries = Object.entries(result);\n        for (let i = 0; i < entries.length; i++) {\n            output += entries[i][0] + \":\" + entries[i][1];\n            if (i < entries.length - 1) output += \",\";\n        }\n        output += \"}\";\n        console.log(output); // Output without newline\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    }
  },
  {
    "title": "Number of Islands",
    "description": "Given a 2D grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water.\n\n### Problem Statement\n\nYou are given a 2D grid **grid** of characters '1' (land) and '0' (water). Count the number of islands, where an island is a group of '1's connected horizontally or vertically.\n\n### Input\n\n- **grid**: A 2D array of characters '1' or '0' (1 <= grid.length, grid[i].length <= 50).\n\n### Output\n\n- An integer representing the number of islands.\n\n### Example\n\n**Input**: grid = [['1','1','1','1','0'],['1','1','0','1','0'],['1','1','0','0','0'],['0','0','0','0','0']]  \n**Output**: 1  \n**Explanation**: There is one island formed by connected '1's.\n\n**Input**: grid = [['1','1','0','0','0'],['1','1','0','0','0'],['0','0','1','0','0'],['0','0','0','1','1']]  \n**Output**: 3  \n**Explanation**: There are three islands.\n\n**Input**: grid = [['1','0']]  \n**Output**: 1  \n**Explanation**: A single '1' forms one island.\n\n### Notes\n\n- Use depth-first search (DFS) or breadth-first search (BFS) to explore connected '1's.\n- Mark visited cells to avoid counting them multiple times.\n\n### Real-World Context\n\nThis problem models scenarios like identifying connected regions in image processing, network connectivity analysis, or geographical mapping applications.",
    "difficulty": "EASY",
    "tags": [
      "Array",
      "DFS",
      "BFS",
      "Matrix",
      "Google",
      "Amazon",
      "Microsoft",
      "Oracle"
    ],
    "constraints": [
      "1 <= grid.length <= 50",
      "1 <= grid[i].length <= 50",
      "grid[i][j] is '0' or '1'",
      "Time complexity should be O(m*n), where m,n are grid dimensions",
      "Space complexity should be O(m*n) for visited array or recursion stack"
    ],
    "examples": [
      {
        "input": "grid = [['1','1','1','1','0'],['1','1','0','1','0'],['1','1','0','0','0'],['0','0','0','0','0']]",
        "output": "1",
        "explanation": "There is one island formed by connected '1's."
      }
    ],
    "testcases": [
      {
        "input": "[['1','1','1','1','0'],['1','1','0','1','0'],['1','1','0','0','0'],['0','0','0','0','0']]",
        "output": "1",
        "isHidden": false
      },
      {
        "input": "[['1','1','0','0','0'],['1','1','0','0','0'],['0','0','1','0','0'],['0','0','0','1','1']]",
        "output": "3",
        "isHidden": false
      },
      {
        "input": "[['0']]",
        "output": "0",
        "isHidden": false
      }
    ],
    "hints": [
      "1. Use DFS to explore all connected '1's when you find one.",
      "2. Mark visited cells to avoid revisiting.",
      "3. Iterate through each cell to find all islands."
    ],
    "editorial": "## Editorial: Number of Islands\n\n### Problem Recap\n\nCount the number of islands in a 2D grid, where an island is a group of '1's connected horizontally or vertically.\n\n### Intuition\n\nThis is a connected component problem. Use DFS or BFS to explore all connected '1's when a '1' is found, marking them as visited to avoid recounting. Count each new group as an island.\n\n### Approaches\n\n#### 1. DFS\n\n- **Idea**: For each unvisited '1', use DFS to mark all connected '1's as visited, incrementing the island count.\n- **Steps**:\n  1. Iterate over each cell in the grid.\n  2. If grid[i][j] is '1', start DFS to mark all connected '1's.\n  3. Increment island count for each new '1' found.\n- **Time Complexity**: O(m*n), visiting each cell once.\n- **Space Complexity**: O(m*n) for recursion stack in worst case.\n- **Pros**: Simple, intuitive.\n\n#### 2. BFS\n\n- **Idea**: Similar to DFS, but use a queue to explore connected '1's level by level.\n- **Steps**:\n  1. Iterate over each cell.\n  2. If grid[i][j] is '1', use BFS to mark connected '1's.\n  3. Increment island count.\n- **Time Complexity**: O(m*n).\n- **Space Complexity**: O(min(m,n)) for queue.\n\n### Recommended Solution\n\nDFS is recommended for simplicity and lower memory overhead in most cases.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(m*n) for visiting each cell.\n- **Space Complexity**: O(m*n) for recursion stack or visited array.\n- **Constraints Handling**:\n  - Grid size: 1 <= m,n <= 50.\n  - Values: grid[i][j] is '0' or '1'.\n\n### Edge Cases\n\n- **Single cell**: grid = [['1']] → 1.\n- **No islands**: grid = [['0']] → 0.\n- **All land**: grid = [['1','1']] → 1.\n\n### Implementation Notes\n\n- Modify grid in-place to mark visited cells (e.g., change '1' to '#').\n- Validate indices to avoid out-of-bounds errors.\n\n### Visual Explanation\n\nFor grid = [['1','1'],['1','0']]:\n- Start at (0,0)='1', DFS marks (0,0),(0,1),(1,0) as visited.\n- Count one island.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"bufio\"\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \"strings\"\n)\n\nfunc numIslands(grid [][]byte) int {\n    // Write your code here\n    return 0\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    if !scanner.Scan() {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    input := strings.TrimSpace(scanner.Text())\n\n    // Try parsing as JSON into [][]string\n    var stringGrid [][]string\n    input = strings.Replace(input, \"'\", \"\\\"\", -1)\n    if err := json.Unmarshal([]byte(input), &stringGrid); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n\n    // Convert to [][]byte and validate\n    if len(stringGrid) == 0 || len(stringGrid[0]) == 0 {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    grid := make([][]byte, len(stringGrid))\n    for i, row := range stringGrid {\n        grid[i] = make([]byte, len(row))\n        for j, c := range row {\n            if c != \"0\" && c != \"1\" {\n                fmt.Println(\"Invalid input format\")\n                return\n            }\n            grid[i][j] = c[0]\n        }\n    }\n\n    result := numIslands(grid)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        // Write your code here\n        return 0;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        line = line.substr(2, line.length()-4);\n        vector<vector<char>> grid;\n        size_t pos = 0;\n        while ((pos = line.find(\"],[\")) != string::npos) {\n            string rowStr = line.substr(0, pos);\n            vector<char> row;\n            for (char c : rowStr) if (c != '\\'' && c != ',') row.push_back(c);\n            grid.push_back(row);\n            line.erase(0, pos + 3);\n        }\n        vector<char> row;\n        for (char c : line) if (c != '\\'' && c != ',') row.push_back(c);\n        if (!row.empty()) grid.push_back(row);\n        Solution sol;\n        int result = sol.numIslands(grid);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Counts the number of islands in the grid.\n     * @param grid 2D grid of '1's and '0's\n     * @return Number of islands\n     */\n    public int numIslands(char[][] grid) {\n        // Write your code here\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            if (!line.startsWith(\"[[\") || !line.endsWith(\"]]\")) {\n                throw new Exception(\"Invalid grid format\");\n            }\n            line = line.substring(2, line.length() - 2);\n            String[] rows = line.split(\"],\\\\[\");\n            char[][] grid = new char[rows.length][];\n            for (int i = 0; i < rows.length; i++) {\n                String row = rows[i].replace(\"\\\"\", \"\").replace(\"'\", \"\");\n                String[] cells = row.split(\",\");\n                grid[i] = new char[cells.length];\n                for (int j = 0; j < cells.length; j++) {\n                    if (cells[j].length() != 1 || (cells[j].charAt(0) != '0' && cells[j].charAt(0) != '1')) {\n                        throw new Exception(\"Invalid grid content\");\n                    }\n                    grid[i][j] = cells[j].charAt(0);\n                }\n            }\n            Main main = new Main();\n            int result = main.numIslands(grid);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import sys\nimport json\n\nclass Solution:\n    def numIslands(self, grid):\n        \"\"\"\n        :param grid: 2D grid of '1's and '0's\n        :return: Number of islands\n        \"\"\"\n        # Write your code\n        return 0\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        line = sys.stdin.readline().strip()\n        # Try JSON parsing\n        try:\n            grid = json.loads(line)\n        except:\n            # Fallback: manual parsing\n            line = line.replace(\"'\", '\"')\n            if line.startswith('[[') and line.endswith(']]'):\n                rows = line[2:-2].split('],[')\n                grid = []\n                for row in rows:\n                    cells = [c.strip('\"') for c in row.split(',')]\n                    grid.append(cells)\n            else:\n                raise ValueError(\"Invalid grid format\")\n        \n        # Validate grid\n        if not isinstance(grid, list) or not all(isinstance(row, list) for row in grid) or not all(all(c in '01' for c in row) for row in grid):\n            raise ValueError(\"Invalid grid format\")\n        \n        sol = Solution()\n        result = sol.numIslands(grid)\n        print result\n    except Exception:\n        print \"Invalid input format\"\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Counts the number of islands in the grid.\n * @param {character[][]} grid - 2D grid of '1's and '0's\n * @return {number} - Number of islands\n */\nfunction numIslands(grid) {\n    // Write your code here\n    return 0;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        let grid;\n        line = line.trim();\n        // Try parsing as JSON array\n        try {\n            grid = JSON.parse(line);\n        } catch {\n            // Fallback: parse as comma-separated rows\n            const rows = line.replace(/^\\[|\\]$/g, '').split('],[');\n            grid = rows.map(row => \n                row.replace(/^\\[|\\]$/g, '').split(',').map(c => c.replace(/['\"]/g, ''))\n            );\n        }\n        // Validate grid\n        if (!Array.isArray(grid) || !grid.every(row => Array.isArray(row))) {\n            throw new Error(\"Invalid grid format\");\n        }\n        const result = numIslands(grid);\n        console.log(result);\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"bufio\"\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \"strings\"\n)\n\nfunc numIslands(grid [][]byte) int {\n    if len(grid) == 0 || len(grid[0]) == 0 {\n        return 0\n    }\n    m, n := len(grid), len(grid[0])\n    var dfs func(i, j int)\n    dfs = func(i, j int) {\n        if i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != '1' {\n            return\n        }\n        grid[i][j] = '#'\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n    }\n    count := 0\n    for i := 0; i < m; i++ {\n        for j := 0; j < n; j++ {\n            if grid[i][j] == '1' {\n                count++\n                dfs(i, j)\n            }\n        }\n    }\n    return count\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    if !scanner.Scan() {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    input := strings.TrimSpace(scanner.Text())\n    // Debug: log input\n    fmt.Fprintf(os.Stderr, \"Input: %s\\n\", input)\n\n    // Try parsing as JSON into [][]string\n    var stringGrid [][]string\n    // Normalize quotes\n    input = strings.Replace(input, \"'\", \"\\\"\", -1)\n    if err := json.Unmarshal([]byte(input), &stringGrid); err != nil {\n        fmt.Fprintf(os.Stderr, \"JSON error: %v\\n\", err)\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n\n    // Convert to [][]byte and validate\n    if len(stringGrid) == 0 || len(stringGrid[0]) == 0 {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    grid := make([][]byte, len(stringGrid))\n    for i, row := range stringGrid {\n        grid[i] = make([]byte, len(row))\n        for j, c := range row {\n            if c != \"0\" && c != \"1\" {\n                fmt.Fprintf(os.Stderr, \"Invalid cell: %s\\n\", c)\n                fmt.Println(\"Invalid input format\")\n                return\n            }\n            grid[i][j] = c[0]\n        }\n    }\n\n    result := numIslands(grid)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        int count = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    count++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return count;\n    }\nprivate:\n    void dfs(vector<vector<char>>& grid, int i, int j) {\n        int m = grid.size(), n = grid[0].size();\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != '1') return;\n        grid[i][j] = '#';\n        dfs(grid, i+1, j);\n        dfs(grid, i-1, j);\n        dfs(grid, i, j+1);\n        dfs(grid, i, j-1);\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        line = line.substr(2, line.length()-4);\n        vector<vector<char>> grid;\n        size_t pos = 0;\n        while ((pos = line.find(\"],[\")) != string::npos) {\n            string rowStr = line.substr(0, pos);\n            vector<char> row;\n            for (char c : rowStr) if (c != '\\'' && c != ',') row.push_back(c);\n            grid.push_back(row);\n            line.erase(0, pos + 3);\n        }\n        vector<char> row;\n        for (char c : line) if (c != '\\'' && c != ',') row.push_back(c);\n        if (!row.empty()) grid.push_back(row);\n        Solution sol;\n        int result = sol.numIslands(grid);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public int numIslands(char[][] grid) {\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\n        int m = grid.length, n = grid[0].length;\n        int count = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    count++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return count;\n    }\n\n    private void dfs(char[][] grid, int i, int j) {\n        int m = grid.length, n = grid[0].length;\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != '1') return;\n        grid[i][j] = '#';\n        dfs(grid, i + 1, j);\n        dfs(grid, i - 1, j);\n        dfs(grid, i, j + 1);\n        dfs(grid, i, j - 1);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            // Remove outer brackets\n            if (!line.startsWith(\"[[\") || !line.endsWith(\"]]\")) {\n                throw new Exception(\"Invalid grid format\");\n            }\n            line = line.substring(2, line.length() - 2);\n            // Split into rows\n            String[] rows = line.split(\"],\\\\[\");\n            char[][] grid = new char[rows.length][];\n            for (int i = 0; i < rows.length; i++) {\n                // Remove quotes and split cells\n                String row = rows[i].replace(\"\\\"\", \"\").replace(\"'\", \"\");\n                String[] cells = row.split(\",\");\n                grid[i] = new char[cells.length];\n                for (int j = 0; j < cells.length; j++) {\n                    if (cells[j].length() != 1 || (cells[j].charAt(0) != '0' && cells[j].charAt(0) != '1')) {\n                        throw new Exception(\"Invalid grid content\");\n                    }\n                    grid[i][j] = cells[j].charAt(0);\n                }\n            }\n            Main main = new Main();\n            int result = main.numIslands(grid);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import sys\nimport json\n\nclass Solution:\n    def numIslands(self, grid):\n        if not grid or not grid[0]:\n            return 0\n        m, n = len(grid), len(grid[0])\n        count = 0\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != '1':\n                return\n            grid[i][j] = '#'  # Mark as visited\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1':\n                    count += 1\n                    dfs(i, j)\n        \n        return count\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        line = sys.stdin.readline().strip()\n        # Log input for debugging\n        print >> sys.stderr, \"Raw input:\", line\n        \n        # Try JSON parsing\n        try:\n            grid = json.loads(line)\n        except:\n            # Fallback: manual parsing\n            # Replace single quotes and normalize\n            line = line.replace(\"'\", '\"')\n            # Remove outer brackets and split rows\n            if line.startswith('[[') and line.endswith(']]'):\n                rows = line[2:-2].split('],[')\n                grid = []\n                for row in rows:\n                    # Split on commas, strip quotes\n                    cells = [c.strip('\"') for c in row.split(',')]\n                    grid.append(cells)\n            else:\n                raise ValueError(\"Invalid grid format\")\n        \n        # Validate grid\n        if not isinstance(grid, list) or not all(isinstance(row, list) for row in grid) or not all(all(c in '01' for c in row) for row in grid):\n            print >> sys.stderr, \"Invalid grid:\", grid\n            raise ValueError(\"Invalid grid format\")\n        \n        sol = Solution()\n        result = sol.numIslands(grid)\n        print result\n    except Exception:\n        print \"Invalid input format\"\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Counts the number of islands in the grid.\n * @param {character[][]} grid - 2D grid of '1's and '0's\n * @return {number} - Number of islands\n */\nfunction numIslands(grid) {\n    if (!grid || grid.length === 0) return 0;\n    const m = grid.length, n = grid[0].length;\n    let count = 0;\n    \n    function dfs(i, j) {\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] !== '1') return;\n        grid[i][j] = '#';\n        dfs(i + 1, j);\n        dfs(i - 1, j);\n        dfs(i, j + 1);\n        dfs(i, j - 1);\n    }\n    \n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === '1') {\n                count++;\n                dfs(i, j);\n            }\n        }\n    }\n    return count;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        let grid;\n        line = line.trim();\n        // Try parsing as JSON array\n        try {\n            grid = JSON.parse(line);\n        } catch {\n            // Fallback: parse as comma-separated rows\n            const rows = line.replace(/^\\[|\\]$/g, '').split('],[');\n            grid = rows.map(row => \n                row.replace(/^\\[|\\]$/g, '').split(',').map(c => c.replace(/['\"]/g, ''))\n            );\n        }\n        // Validate grid\n        if (!Array.isArray(grid) || !grid.every(row => Array.isArray(row))) {\n            throw new Error(\"Invalid grid format\");\n        }\n        const result = numIslands(grid);\n        console.log(result);\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    }
  },
  {
    "title": "Course Schedule",
    "description": "There are a total of numCourses courses labeled from 0 to numCourses-1. Some courses have prerequisites, e.g., to take course 0, you must first take course 1, expressed as [0,1]. Given the number of courses and a list of prerequisite pairs, determine if it is possible to finish all courses.\n\n### Problem Statement\n\nYou are given an integer **numCourses** and an array **prerequisites** where each prerequisites[i] = [ai, bi] indicates that you must take course bi before course ai. Return true if all courses can be completed, false otherwise.\n\n### Input\n\n- **numCourses**: Number of courses (1 <= numCourses <= 10^5).\n- **prerequisites**: Array of pairs [ai, bi] (0 <= ai, bi < numCourses).\n\n### Output\n\n- A boolean: true if all courses can be completed, false otherwise.\n\n### Example\n\n**Input**: numCourses = 2, prerequisites = [[1,0]]  \n**Output**: true  \n**Explanation**: Course 1 requires course 0, which is possible.\n\n**Input**: numCourses = 2, prerequisites = [[1,0],[0,1]]  \n**Output**: false  \n**Explanation**: A cycle exists, so courses cannot be completed.\n\n**Input**: numCourses = 1, prerequisites = []  \n**Output**: true  \n**Explanation**: No prerequisites, so course can be completed.\n\n### Notes\n\n- Use graph cycle detection (DFS or BFS) to check for impossible schedules.\n- A cycle in the graph indicates a dependency loop, making completion impossible.\n\n### Real-World Context\n\nThis problem models task scheduling, dependency resolution in software builds, or course planning in educational systems.",
    "difficulty": "EASY",
    "tags": [
      "Graph",
      "DFS",
      "BFS",
      "Atlassian",
      "Amazon",
      "Google",
      "VM Ware"
    ],
    "constraints": [
      "1 <= numCourses <= 10^5",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "0 <= ai, bi < numCourses",
      "No duplicate edges in prerequisites",
      "Time complexity should be O(V + E), where V is numCourses, E is prerequisites.length",
      "Space complexity should be O(V + E) for adjacency list"
    ],
    "examples": [
      {
        "input": "numCourses = 2, prerequisites = [[1, 0]]",
        "output": "true",
        "explanation": "Course 1 requires course 0, which is possible."
      }
    ],
    "testcases": [
      {
        "input": "2\n[[1,0]]",
        "output": "true",
        "isHidden": false
      },
      {
        "input": "2\n[[1,0],[0,1]]",
        "output": "false",
        "isHidden": false
      },
      {
        "input": "1\n[]",
        "output": "true",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Model the problem as a directed graph and check for cycles.",
      "2. Use DFS to detect cycles by tracking visited nodes.",
      "3. Alternatively, use BFS with in-degree counting (topological sort)."
    ],
    "editorial": "## Editorial: Course Schedule\n\n### Problem Recap\n\nDetermine if all courses can be completed given prerequisites, by checking for cycles in the dependency graph.\n\n### Intuition\n\nThis is a graph cycle detection problem. A cycle in the directed graph (where edges represent prerequisites) means a course depends on itself indirectly, making completion impossible. Use DFS or BFS to detect cycles.\n\n### Approaches\n\n#### 1. DFS with Cycle Detection\n\n- **Idea**: Build an adjacency list and use DFS to detect cycles.\n- **Steps**:\n  1. Create an adjacency list from prerequisites.\n  2. For each course, run DFS to check for cycles in its dependency path.\n  3. Use a visited set and recursion stack to track cycles.\n  4. Return false if a cycle is found, true otherwise.\n- **Time Complexity**: O(V + E), where V is numCourses, E is prerequisites.length.\n- **Space Complexity**: O(V + E) for adjacency list and recursion stack.\n- **Pros**: Intuitive for cycle detection.\n\n#### 2. BFS with Topological Sort\n\n- **Idea**: Use in-degree to perform topological sort; a cycle means no valid order exists.\n- **Steps**:\n  1. Build adjacency list and in-degree array.\n  2. Queue nodes with in-degree 0.\n  3. Process nodes, reducing in-degrees of neighbors.\n  4. If all nodes processed, no cycle; else, cycle exists.\n- **Time Complexity**: O(V + E).\n- **Space Complexity**: O(V + E).\n\n### Recommended Solution\n\nDFS is recommended for simplicity in detecting cycles.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(V + E) for graph traversal.\n- **Space Complexity**: O(V + E) for adjacency list and visited set.\n- **Constraints Handling**:\n  - Courses: 1 <= numCourses <= 10^5.\n  - Prerequisites: 0 <= length <= 5000.\n\n### Edge Cases\n\n- **No prerequisites**: numCourses = 1, prerequisites = [] → true.\n- **Single course with prereq**: numCourses = 1, prerequisites = [[0,0]] → false.\n- **Large graph**: numCourses = 10^5.\n\n### Implementation Notes\n\n- Use adjacency list for efficient graph representation.\n- Track visited nodes and recursion stack separately to detect cycles.\n\n### Visual Explanation\n\nFor numCourses = 2, prerequisites = [[1,0]]:\n- Graph: 0→1, no cycle, return true.\nFor [[1,0],[0,1]]:\n- Graph: 0→1, 1→0, cycle detected, return false.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"bufio\"\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \"strings\"\n)\n\nfunc canFinish(numCourses int, prerequisites [][]int) bool {\n    // Write your code here\n    return false\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    // Read input\n    if !scanner.Scan() {\n        fmt.Println(\"Invalid input\")\n        return\n    }\n    var numCourses int\n    if _, err := fmt.Sscanf(strings.TrimSpace(scanner.Text()), \"%d\", &numCourses); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    if numCourses < 1 {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    if !scanner.Scan() {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    input := strings.TrimSpace(scanner.Text())\n    var prerequisites [][]int\n    if input == \"[]\" {\n        prerequisites = [][]int{}\n    } else {\n        if err := json.Unmarshal([]byte(input), &prerequisites); err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        for _, p := range prerequisites {\n            if len(p) != 2 || p[0] < 0 || p[0] >= numCourses || p[1] < 0 || p[1] >= numCourses {\n                fmt.Println(\"Invalid input format\")\n                return\n            }\n        }\n    }\n    result := canFinish(numCourses, prerequisites)\n    fmt.Println(strings.ToLower(fmt.Sprintf(\"%v\", result)))\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        // Write your code here\n        return false;\n    }\n};\n\nint main() {\n    try {\n        int numCourses;\n        cin >> numCourses;\n        cin.ignore();\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        line = line.substr(2, line.length()-4);\n        vector<vector<int>> prerequisites;\n        size_t pos = 0;\n        while ((pos = line.find(\"],[\")) != string::npos) {\n            string pairStr = line.substr(0, pos);\n            vector<int> pair;\n            size_t comma = pairStr.find(\",\");\n            pair.push_back(stoi(pairStr.substr(0, comma)));\n            pair.push_back(stoi(pairStr.substr(comma+1)));\n            prerequisites.push_back(pair);\n            line.erase(0, pos + 3);\n        }\n        if (!line.empty()) {\n            vector<int> pair;\n            size_t comma = line.find(\",\");\n            pair.push_back(stoi(line.substr(0, comma)));\n            pair.push_back(stoi(line.substr(comma+1)));\n            prerequisites.push_back(pair);\n        }\n        Solution sol;\n        bool result = sol.canFinish(numCourses, prerequisites);\n        cout << (result ? \"true\" : \"false\") << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Checks if all courses can be completed.\n     * @param numCourses Number of courses\n     * @param prerequisites Array of prerequisite pairs\n     * @return True if possible, false otherwise\n     */\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        // Write your code here\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            int numCourses = Integer.parseInt(scanner.nextLine().trim());\n            if (numCourses < 1) throw new Exception(\"Invalid numCourses\");\n            String line = scanner.nextLine().trim();\n            int[][] prerequisites;\n            if (line.equals(\"[]\")) {\n                prerequisites = new int[0][2];\n            } else {\n                if (!line.startsWith(\"[[\") || !line.endsWith(\"]]\")) throw new Exception(\"Invalid format\");\n                String[] pairs = line.substring(2, line.length()-2).split(\"],\\\\[\");\n                prerequisites = new int[pairs.length][2];\n                for (int i = 0; i < pairs.length; i++) {\n                    String[] pair = pairs[i].split(\",\");\n                    if (pair.length != 2) throw new Exception(\"Invalid pair\");\n                    prerequisites[i][0] = Integer.parseInt(pair[0].trim());\n                    prerequisites[i][1] = Integer.parseInt(pair[1].trim());\n                    if (prerequisites[i][0] < 0 || prerequisites[i][0] >= numCourses ||\n                        prerequisites[i][1] < 0 || prerequisites[i][1] >= numCourses) {\n                        throw new Exception(\"Invalid course ID\");\n                    }\n                }\n            }\n            Main main = new Main();\n            boolean result = main.canFinish(numCourses, prerequisites);\n            System.out.println(String.valueOf(result).toLowerCase()); // Output true/false\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import sys\nimport json\n\nclass Solution:\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        Checks if all courses can be completed.\n        :param numCourses: Number of courses\n        :param prerequisites: List of prerequisite pairs\n        :return: True if possible, false otherwise\n        \"\"\"\n        # Write your code here\n        return False\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        numCourses = int(sys.stdin.readline().strip())\n        prerequisites = json.loads(sys.stdin.readline().strip())\n        if not isinstance(prerequisites, list) or not all(isinstance(p, list) and len(p) == 2 for p in prerequisites):\n            raise ValueError(\"Invalid prerequisites format\")\n        if numCourses < 1:\n            raise ValueError(\"Invalid numCourses\")\n        sol = Solution()\n        result = sol.canFinish(numCourses, prerequisites)\n        print str(result).lower()  # Output true/false\n    except Exception:\n        print \"Invalid input format\"\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Checks if all courses can be completed.\n * @param {number} numCourses - Number of courses\n * @param {number[][]} prerequisites - Array of prerequisite pairs\n * @return {boolean} - True if possible, false otherwise\n */\nfunction canFinish(numCourses, prerequisites) {\n    // Write your code here\n    return false;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nlet lines = [];\nrl.on(\"line\", (line) => {\n    lines.push(line.trim());\n    if (lines.length === 2) {\n        try {\n            const numCourses = parseInt(lines[0]);\n            const prerequisites = JSON.parse(lines[1]);\n            const result = canFinish(numCourses, prerequisites);\n            console.log(result);\n            rl.close();\n        } catch (e) {\n            console.log(\"Invalid input format\");\n            process.exit(1);\n        }\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"bufio\"\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \"strings\"\n)\n\nfunc canFinish(numCourses int, prerequisites [][]int) bool {\n    adj := make([][]int, numCourses)\n    for i := range adj {\n        adj[i] = make([]int, 0)\n    }\n    for _, pair := range prerequisites {\n        adj[pair[0]] = append(adj[pair[0]], pair[1])\n    }\n    visited := make([]bool, numCourses)\n    recStack := make([]bool, numCourses)\n    var dfs func(node int) bool\n    dfs = func(node int) bool {\n        if recStack[node] {\n            return false\n        }\n        if visited[node] {\n            return true\n        }\n        visited[node] = true\n        recStack[node] = true\n        for _, neighbor := range adj[node] {\n            if !dfs(neighbor) {\n                return false\n            }\n        }\n        recStack[node] = false\n        return true\n    }\n    for i := 0; i < numCourses; i++ {\n        if !visited[i] && !dfs(i) {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    // Read numCourses\n    if !scanner.Scan() {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    var numCourses int\n    if _, err := fmt.Sscanf(strings.TrimSpace(scanner.Text()), \"%d\", &numCourses); err != nil {\n        fmt.Fprintf(os.Stderr, \"numCourses error: %v\\n\", err)\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    if numCourses < 1 {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    // Read prerequisites\n    if !scanner.Scan() {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    input := strings.TrimSpace(scanner.Text())\n    // Debug: log input\n    fmt.Fprintf(os.Stderr, \"Input: %s\\n\", input)\n    var prerequisites [][]int\n    if input == \"[]\" {\n        prerequisites = [][]int{}\n    } else {\n        if err := json.Unmarshal([]byte(input), &prerequisites); err != nil {\n            fmt.Fprintf(os.Stderr, \"JSON error: %v\\n\", err)\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        // Validate prerequisites\n        for _, p := range prerequisites {\n            if len(p) != 2 || p[0] < 0 || p[0] >= numCourses || p[1] < 0 || p[1] >= numCourses {\n                fmt.Println(\"Invalid input format\")\n                return\n            }\n        }\n    }\n    result := canFinish(numCourses, prerequisites)\n    fmt.Println(strings.ToLower(fmt.Sprintf(\"%v\", result))) // Output true/false\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> adj(numCourses);\n        for (const auto& pair : prerequisites) adj[pair[0]].push_back(pair[1]);\n        vector<bool> visited(numCourses, false), recStack(numCourses, false);\n        for (int i = 0; i < numCourses; i++) {\n            if (!visited[i] && !dfs(i, adj, visited, recStack)) return false;\n        }\n        return true;\n    }\nprivate:\n    bool dfs(int node, vector<vector<int>>& adj, vector<bool>& visited, vector<bool>& recStack) {\n        if (recStack[node]) return false;\n        if (visited[node]) return true;\n        visited[node] = true;\n        recStack[node] = true;\n        for (int neighbor : adj[node]) {\n            if (!dfs(neighbor, adj, visited, recStack)) return false;\n        }\n        recStack[node] = false;\n        return true;\n    }\n};\n\nint main() {\n    try {\n        int numCourses;\n        cin >> numCourses;\n        cin.ignore();\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        line = line.substr(2, line.length()-4);\n        vector<vector<int>> prerequisites;\n        size_t pos = 0;\n        while ((pos = line.find(\"],[\")) != string::npos) {\n            string pairStr = line.substr(0, pos);\n            vector<int> pair;\n            size_t comma = pairStr.find(\",\");\n            pair.push_back(stoi(pairStr.substr(0, comma)));\n            pair.push_back(stoi(pairStr.substr(comma+1)));\n            prerequisites.push_back(pair);\n            line.erase(0, pos + 3);\n        }\n        if (!line.empty()) {\n            vector<int> pair;\n            size_t comma = line.find(\",\");\n            pair.push_back(stoi(line.substr(0, comma)));\n            pair.push_back(stoi(line.substr(comma+1)));\n            prerequisites.push_back(pair);\n        }\n        Solution sol;\n        bool result = sol.canFinish(numCourses, prerequisites);\n        cout << (result ? \"true\" : \"false\") << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class Main {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < numCourses; i++) adj.add(new ArrayList<>());\n        for (int[] pair : prerequisites) adj.get(pair[0]).add(pair[1]);\n        boolean[] visited = new boolean[numCourses], recStack = new boolean[numCourses];\n        for (int i = 0; i < numCourses; i++) {\n            if (!visited[i] && !dfs(i, adj, visited, recStack)) return false;\n        }\n        return true;\n    }\n\n    private boolean dfs(int node, List<List<Integer>> adj, boolean[] visited, boolean[] recStack) {\n        if (recStack[node]) return false;\n        if (visited[node]) return true;\n        visited[node] = true;\n        recStack[node] = true;\n        for (int neighbor : adj.get(node)) {\n            if (!dfs(neighbor, adj, visited, recStack)) return false;\n        }\n        recStack[node] = false;\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            int numCourses = Integer.parseInt(scanner.nextLine().trim());\n            if (numCourses < 1) throw new Exception(\"Invalid numCourses\");\n            String line = scanner.nextLine().trim();\n            int[][] prerequisites;\n            if (line.equals(\"[]\")) {\n                prerequisites = new int[0][2];\n            } else {\n                if (!line.startsWith(\"[[\") || !line.endsWith(\"]]\")) throw new Exception(\"Invalid format\");\n                String[] pairs = line.substring(2, line.length()-2).split(\"],\\\\[\");\n                prerequisites = new int[pairs.length][2];\n                for (int i = 0; i < pairs.length; i++) {\n                    String[] pair = pairs[i].split(\",\");\n                    if (pair.length != 2) throw new Exception(\"Invalid pair\");\n                    prerequisites[i][0] = Integer.parseInt(pair[0].trim());\n                    prerequisites[i][1] = Integer.parseInt(pair[1].trim());\n                    if (prerequisites[i][0] < 0 || prerequisites[i][0] >= numCourses ||\n                        prerequisites[i][1] < 0 || prerequisites[i][1] >= numCourses) {\n                        throw new Exception(\"Invalid course ID\");\n                    }\n                }\n            }\n            Main main = new Main();\n            boolean result = main.canFinish(numCourses, prerequisites);\n            System.out.println(String.valueOf(result).toLowerCase()); // Output true/false\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "import sys\nimport json\n\nclass Solution:\n    def canFinish(self, numCourses, prerequisites):\n        adj = [[] for _ in range(numCourses)]\n        for course, prereq in prerequisites:\n            adj[course].append(prereq)\n        visited, recStack = set(), set()\n        def dfs(node):\n            if node in recStack:\n                return False\n            if node in visited:\n                return True\n            visited.add(node)\n            recStack.add(node)\n            for neighbor in adj[node]:\n                if not dfs(neighbor):\n                    return False\n            recStack.remove(node)\n            return True\n        for i in range(numCourses):\n            if i not in visited and not dfs(i):\n                return False\n        return True\n\n# Input handling\nif __name__ == \"__main__\":\n    try:\n        numCourses = int(sys.stdin.readline().strip())\n        prerequisites = json.loads(sys.stdin.readline().strip())\n        if not isinstance(prerequisites, list) or not all(isinstance(p, list) and len(p) == 2 for p in prerequisites):\n            raise ValueError(\"Invalid prerequisites format\")\n        if numCourses < 1:\n            raise ValueError(\"Invalid numCourses\")\n        sol = Solution()\n        result = sol.canFinish(numCourses, prerequisites)\n        print str(result).lower()  # Output true/false\n    except Exception:\n        print \"Invalid input format\"\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Checks if all courses can be completed.\n * @param {number} numCourses - Number of courses\n * @param {number[][]} prerequisites - Array of prerequisite pairs\n * @return {boolean} - True if possible, false otherwise\n */\nfunction canFinish(numCourses, prerequisites) {\n    const adj = Array.from({ length: numCourses }, () => []);\n    for (const [course, prereq] of prerequisites) {\n        adj[course].push(prereq);\n    }\n    const visited = new Set(), recStack = new Set();\n    function dfs(node) {\n        if (recStack.has(node)) return false;\n        if (visited.has(node)) return true;\n        visited.add(node);\n        recStack.add(node);\n        for (const neighbor of adj[node]) {\n            if (!dfs(neighbor)) return false;\n        }\n        recStack.delete(node);\n        return true;\n    }\n    for (let i = 0; i < numCourses; i++) {\n        if (!visited.has(i) && !dfs(i)) return false;\n    }\n    return true;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nlet lines = [];\nrl.on(\"line\", (line) => {\n    lines.push(line.trim());\n    if (lines.length === 2) {\n        try {\n            const numCourses = parseInt(lines[0]);\n            const prerequisites = JSON.parse(lines[1]);\n            const result = canFinish(numCourses, prerequisites);\n            console.log(result);\n            rl.close();\n        } catch (e) {\n            console.log(\"Invalid input format\");\n            process.exit(1);\n        }\n    }\n});"
    }
  },
  {
    "title": "Majority Element",
    "description": "Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊n/2⌋ times. You may assume that the array is non-empty and the majority element always exists in the array.\n\n### Problem Statement\n\nReturn the majority element in the array.\n\n### Input\n\n- **nums**: An array of integers (1 <= nums.length <= 5 * 10^4, -10^9 <= nums[i] <= 10^9).\n\n### Output\n\n- An integer representing the majority element.\n\n### Example\n\n**Input**: nums = [3,2,3]  \n**Output**: 3  \n**Explanation**: 3 appears twice, which is more than ⌊3/2⌋ = 1.\n\n**Input**: nums = [2,2,1,1,1,2,2]  \n**Output**: 2  \n**Explanation**: 2 appears four times, which is more than ⌊7/2⌋ = 3.\n\n### Notes\n\n- The majority element is guaranteed to exist.\n- An efficient solution can use Boyer-Moore Voting Algorithm for O(1) space.\n\n### Real-World Context\n\nThis problem is relevant in scenarios like finding the most frequent item in a dataset, such as popular votes or common errors, common at companies like Uber.",
    "difficulty": "EASY",
    "tags": [
      "Array",
      "Boyer-Moore Voting",
      "Uber",
      "Google",
      "Microsoft"
    ],
    "constraints": [
      "1 <= nums.length <= 5 * 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "Majority element always exists",
      "Time complexity should be O(n)",
      "Space complexity should be O(1)"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 3]",
        "output": "3",
        "explanation": "3 appears twice, which is more than ⌊3/2⌋ = 1."
      }
    ],
    "testcases": [
      {
        "input": "[3,2,3]",
        "output": "3",
        "isHidden": false
      },
      {
        "input": "[2,2,1,1,1,2,2]",
        "output": "2",
        "isHidden": false
      },
      {
        "input": "[1]",
        "output": "1",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Use Boyer-Moore Voting Algorithm to find the majority element in one pass.",
      "2. Keep a candidate and count; increment for same element, decrement for different.",
      "3. The candidate remaining is the majority element due to the problem's guarantee."
    ],
    "editorial": "## Editorial: Majority Element\n\n### Problem Recap\n\nFind the element that appears more than ⌊n/2⌋ times in an array, guaranteed to exist.\n\n### Intuition\n\nThe Boyer-Moore Voting Algorithm is ideal because the majority element’s frequency ensures it will dominate in a voting process. By pairing majority and non-majority elements, the majority element will remain.\n\n### Approach\n\n#### Boyer-Moore Voting Algorithm\n\n- **Idea**: Maintain a candidate and count, incrementing for the candidate and decrementing for others.\n- **Steps**:\n  1. Initialize candidate = nums[0], count = 1.\n  2. Iterate through nums[1:]\n     - If count == 0, set candidate = nums[i].\n     - If nums[i] == candidate, increment count; else decrement count.\n  3. Return candidate (guaranteed to be the majority element).\n- **Time Complexity**: O(n) for one pass.\n- **Space Complexity**: O(1) for two variables.\n\n### Recommended Solution\n\nBoyer-Moore is optimal for O(n) time and O(1) space.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for iterating through the array.\n- **Space Complexity**: O(1) for candidate and count.\n- **Constraints Handling**:\n  - Array length: 1 <= n <= 5 * 10^4.\n  - Values: -10^9 <= nums[i] <= 10^9.\n\n### Edge Cases\n\n- **Single element**: nums = [1] → 1.\n- **All same elements**: nums = [2,2,2] → 2.\n- **Mixed elements**: nums = [2,2,1,1,1,2,2] → 2.\n\n### Implementation Notes\n\n- No need to verify the candidate since the majority element is guaranteed.\n- Handle negative numbers as they are valid inputs.\n- The algorithm works due to the majority element’s dominance.\n\n### Visual Explanation\n\nFor nums = [2,2,1,1,1,2,2]:\n- candidate = 2, count = 1.\n- i=1: 2, count = 2.\n- i=2: 1, count = 1.\n- i=3: 1, count = 0, candidate = 1.\n- i=4: 1, count = 1.\n- i=5: 2, count = 0, candidate = 2.\n- i=6: 2, count = 1.\n- Return 2.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc majorityElement(nums []int) int {\n    // Write your code here\n    return 0\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    input = input[1 : len(input)-1]\n    strNums := strings.Split(input, \",\")\n    nums := make([]int, len(strNums))\n    for i, s := range strNums {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        nums[i] = num\n    }\n    result := majorityElement(nums)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        // Write your code here\n        return 0;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        size_t pos = 0;\n        while ((pos = line.find(\",\")) != string::npos) {\n            nums.push_back(stoi(line.substr(0, pos)));\n            line.erase(0, pos + 1);\n        }\n        if (!line.empty()) nums.push_back(stoi(line));\n        Solution sol;\n        int result = sol.majorityElement(nums);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Finds the majority element.\n     * @param nums Array of integers\n     * @return Majority element\n     */\n    public int majorityElement(int[] nums) {\n        // Write your code here\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            String[] strNums = line.substring(1, line.length()-1).split(\",\");\n            int[] nums = new int[strNums.length];\n            for (int i = 0; i < strNums.length; i++) {\n                nums[i] = Integer.parseInt(strNums[i].trim());\n            }\n            Main main = new Main();\n            int result = main.majorityElement(nums);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def majorityElement(self, nums):\n        \"\"\"\n        Finds the majority element.\n        :param nums: List of integers\n        :return: Majority element\n        \"\"\"\n        # Write your code here\n        return 0\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    import json\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.majorityElement(nums)\n        print result \n    except Exception as e:\n        print \"Invalid input format\"\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds the majority element.\n * @param {number[]} nums - Array of integers\n * @return {number} - Majority element\n */\nfunction majorityElement(nums) {\n    // Write your code here\n    return 0;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const nums = JSON.parse(line.trim());\n        const result = majorityElement(nums);\n        console.log(result);\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc majorityElement(nums []int) int {\n    candidate, count := nums[0], 1\n    for _, num := range nums[1:] {\n        if count == 0 {\n            candidate = num\n        }\n        if num == candidate {\n            count++\n        } else {\n            count--\n        }\n    }\n    return candidate\n}\n\nfunc main() {\n    var input string\n    if _, err := fmt.Scanln(&input); err != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    input = strings.TrimSpace(input)\n    input = input[1:len(input)-1]\n    strNums := strings.Split(input, \",\")\n    nums := make([]int, len(strNums))\n    for i, s := range strNums {\n        num, err := strconv.Atoi(strings.TrimSpace(s))\n        if err != nil {\n            fmt.Println(\"Invalid input format\")\n            return\n        }\n        nums[i] = num\n    }\n    result := majorityElement(nums)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int candidate = nums[0], count = 1;\n        for (int i = 1; i < nums.size(); i++) {\n            if (count == 0) candidate = nums[i];\n            count += (nums[i] == candidate) ? 1 : -1;\n        }\n        return candidate;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) {\n            cout << \"Invalid input format\" << endl;\n            return 1;\n        }\n        line = line.substr(1, line.length()-2);\n        vector<int> nums;\n        size_t pos = 0;\n        while ((pos = line.find(\",\")) != string::npos) {\n            nums.push_back(stoi(line.substr(0, pos)));\n            line.erase(0, pos + 1);\n        }\n        if (!line.empty()) nums.push_back(stoi(line));\n        Solution sol;\n        int result = sol.majorityElement(nums);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public int majorityElement(int[] nums) {\n        int candidate = nums[0], count = 1;\n        for (int i = 1; i < nums.length; i++) {\n            if (count == 0) candidate = nums[i];\n            count += (nums[i] == candidate) ? 1 : -1;\n        }\n        return candidate;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            String[] strNums = line.substring(1, line.length()-1).split(\",\");\n            int[] nums = new int[strNums.length];\n            for (int i = 0; i < strNums.length; i++) {\n                nums[i] = Integer.parseInt(strNums[i].trim());\n            }\n            Main main = new Main();\n            int result = main.majorityElement(nums);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class Solution:\n    def majorityElement(self, nums):\n        candidate, count = nums[0], 1\n        for num in nums[1:]:\n            if count == 0:\n                candidate = num\n            count += 1 if num == candidate else -1\n        return candidate\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    import json\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        sol = Solution()\n        result = sol.majorityElement(nums)\n        print result  \n    except Exception as e:\n        print \"Invalid input format\"\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Finds the majority element.\n * @param {number[]} nums - Array of integers\n * @return {number} - Majority element\n */\nfunction majorityElement(nums) {\n    let candidate = nums[0], count = 1;\n    for (let i = 1; i < nums.length; i++) {\n        if (count === 0) candidate = nums[i];\n        count += (nums[i] === candidate) ? 1 : -1;\n    }\n    return candidate;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        const nums = JSON.parse(line.trim());\n        const result = majorityElement(nums);\n        console.log(result);\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    }
  },
  {
    "title": "Minimum Number of K Consecutive Bit Flips",
    "description": "Given a binary array nums and an integer k, you can flip exactly k consecutive bits at a time. Return the minimum number of flips needed to make all elements 1. If impossible, return -1.\n\n### Problem Statement\n\nYou are given a binary array **nums** and an integer **k**. In one operation, you can choose an index i and flip k consecutive bits starting from i (i.e., nums[i] to nums[i+k-1]). Return the minimum number of flips needed to make all elements 1, or -1 if impossible.\n\n### Input\n\n- **nums**: A binary array of 0s and 1s (1 <= nums.length <= 10^5).\n- **k**: An integer (1 <= k <= nums.length).\n\n### Output\n\n- An integer: the minimum number of flips needed, or -1 if impossible.\n\n### Example\n\n**Input**: nums = [0,1,0], k = 1  \n**Output**: 2  \n**Explanation**: Flip nums[0] and nums[2] to get [1,1,1].\n\n**Input**: nums = [0,0,0,1,0,1,1,0], k = 3  \n**Output**: 3  \n**Explanation**: Flip [0,2], [3,5], [5,7] to get all 1s.\n\n**Input**: nums = [1,1,0], k = 2  \n**Output**: -1  \n**Explanation**: Cannot make all 1s with k=2 flips.\n\n### Notes\n\n- Use a sliding window or queue to track flip effects.\n- Check if flips exceed array bounds or are impossible.\n\n### Real-World Context\n\nThis problem models scenarios like signal processing or bit manipulation in hardware where consecutive bits must be altered.",
    "difficulty": "EASY",
    "tags": [
      "Array",
      "Sliding Window",
      "Greedy",
      "Google",
      "Amazon",
      "Tcs"
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "nums[i] is 0 or 1",
      "1 <= k <= nums.length",
      "Time complexity should be O(n), where n is nums.length",
      "Space complexity should be O(1) or O(n) for queue"
    ],
    "examples": [
      {
        "input": "nums = [0, 1, 0], k = 1",
        "output": "2",
        "explanation": "Flip nums[0] and nums[2] to get [1,1,1]."
      }
    ],
    "testcases": [
      {
        "input": "[0,1,0]\n1",
        "output": "2",
        "isHidden": false
      },
      {
        "input": "[0,0,0,1,0,1,1,0]\n3",
        "output": "3",
        "isHidden": false
      },
      {
        "input": "[1,1,0]\n2",
        "output": "-1",
        "isHidden": true
      }
    ],
    "hints": [
      "1. Track the number of flips affecting each index.\\n2. Use a queue or difference array to manage flip ranges.\\n3. If a bit cannot be flipped to 1, return -1."
    ],
    "editorial": "## Editorial: Minimum Number of K Consecutive Bit Flips\n\n### Problem Recap\n\nFind the minimum number of k-consecutive bit flips to make all bits 1, or return -1 if impossible.\n\n### Intuition\n\nThis is a greedy problem. For each index, if the bit is 0 (after accounting for prior flips), perform a flip starting at that index. Track flip effects using a queue or difference array to ensure each bit’s state is correctly computed.\n\n### Approaches\n\n#### 1. Queue-Based Tracking\n\n- **Idea**: Use a queue to track indices where flips start, removing them after k positions.\n- **Steps**:\n  1. Initialize a queue and flip count.\n  2. For each index i, check if nums[i] (after prior flips) is 0.\n  3. If 0, add i to queue, increment flip count, and toggle future bits.\n  4. If queue size exceeds k, remove oldest flip.\n  5. If any bit cannot be made 1, return -1.\n- **Time Complexity**: O(n), where n is array length.\n- **Space Complexity**: O(k) for queue.\n- **Pros**: Intuitive, handles overlapping flips.\n\n### Recommended Solution\n\nQueue-Based Tracking is recommended for clarity and efficiency.\n\n### Complexity Analysis\n\n- **Time Complexity**: O(n) for one pass.\n- **Space Complexity**: O(k) for queue.\n- **Constraints Handling**:\n  - Array length: 1 <= n <= 10^5.\n  - k: 1 <= k <= n.\n\n### Edge Cases\n\n- **k = 1**: Single bit flips, count 0s.\n- **k = n**: One flip or impossible.\n- **All 1s**: Return 0.\n\n### Implementation Notes\n\n- Use modulo to track flip parity.\n- Validate flip boundaries to avoid index errors.\n\n### Visual Explanation\n\nFor nums = [0,1,0], k = 1:\n- Flip i=0: [1,1,0], flips=1.\n- Flip i=2: [1,1,1], flips=2.\n- Return 2.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n)\n\nfunc minKBitFlips(nums []int, k int) int {\n    // Write your code here\n    return -1\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin) // Fixed: Use NewScanner\n    var lines []string\n    for scanner.Scan() {\n        lines = append(lines, strings.TrimSpace(scanner.Text()))\n        if len(lines) == 2 {\n            break\n        }\n    }\n    if scanner.Err() != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    numsLine, kStr := lines[0], lines[1]\n    var nums []int\n    if numsLine != \"[]\" {\n        numsStr := strings.Split(numsLine[1:len(numsLine)-1], \",\")\n        nums = make([]int, len(numsStr))\n        for i, s := range numsStr {\n            val, err := strconv.Atoi(strings.TrimSpace(s))\n            if err != nil || (val != 0 && val != 1) {\n                fmt.Println(\"Invalid input format\")\n                return\n            }\n            nums[i] = val\n        }\n    }\n    k, err := strconv.Atoi(kStr)\n    if err != nil || k < 1 || k > len(nums) {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := 0\n    if len(nums) > 0 {\n        result = minKBitFlips(nums, k)\n    }\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minKBitFlips(vector<int>& nums, int k) {\n        // Write your code here\n        return -1;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) throw runtime_error(\"Invalid input\");\n        line = line.substr(1, line.length() - 1); // Remove [ and ]\n        vector<int> nums;\n        if (line.empty()) { // Handle empty array\n            int k;\n            if (!(cin >> k) || k < 1) throw runtime_error(\"Invalid input\");\n            cout << 0 << endl; // Empty array needs 0 flips\n            return 0;\n        }\n        size_t pos = 0;\n        while ((pos = line.find(',')) != string::npos) {\n            int n = stoi(line.substr(0, pos));\n            if (n != 0 && n != 1) throw runtime_error(\"Invalid input\");\n            nums.push_back(n);\n            line.erase(0, pos + 1);\n        }\n        int n = stoi(line);\n        if (n != 0 && n != 1) throw runtime_error(\"Invalid input\");\n        nums.push_back(n);\n        int k;\n        if (!(cin >> k) || k < 1 || k > nums.size()) throw runtime_error(\"Invalid input\");\n        Solution sol;\n        int result = sol.minKBitFlips(nums, k);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public int minKBitFlips(int[] nums, int k) {\n        // Write your code here\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String numsLine = scanner.nextLine().trim();\n            int k = Integer.parseInt(scanner.nextLine().trim());\n            if (numsLine.equals(\"[]\")) {\n                System.out.println(0); // Empty array requires no flips\n                return;\n            }\n            String[] numsStr = numsLine.substring(1, numsLine.length() - 1).split(\",\");\n            int[] nums = new int[numsStr.length];\n            for (int i = 0; i < numsStr.length; i++) {\n                nums[i] = Integer.parseInt(numsStr[i].trim());\n                if (nums[i] != 0 && nums[i] != 1) throw new Exception(\"Invalid input\");\n            }\n            if (k < 1 || k > nums.length) throw new Exception(\"Invalid input\");\n            Main main = new Main();\n            int result = main.minKBitFlips(nums, k);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "def minKBitFlips(nums, k):\n    # Write your code here\n    return -1\n\n# Input handling\nif __name__ == '__main__':\n    import sys\n    import json\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        k = int(sys.stdin.readline().strip())\n        if not isinstance(nums, list) or any(n not in [0, 1] for n in nums) or k < 1 or k > len(nums):\n            raise ValueError('Invalid input')\n        result = minKBitFlips(nums, k)\n        print(result)\n    except Exception:\n        print('Invalid input format')\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Returns minimum k-consecutive bit flips needed.\n * @param {number[]} nums - Binary array\n * @param {number} k - Flip length\n * @return {number} - Minimum flips or -1\n */\nfunction minKBitFlips(nums, k) {\n    // Write your code here\n    return -1;\n}\n\n// Input handling\nconst readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nlet lines = [];\nrl.on('line', (line) => {\n    lines.push(line.trim());\n    if (lines.length === 2) {\n        try {\n            const nums = JSON.parse(lines[0]);\n            const k = parseInt(lines[1]);\n            if (!Array.isArray(nums) || nums.some(n => n !== 0 && n !== 1) || k < 1 || k > nums.length) {\n                throw new Error('Invalid input');\n            }\n            const result = minKBitFlips(nums, k);\n            console.log(result);\n            rl.close();\n        } catch (e) {\n            console.log('Invalid input format');\n            process.exit(1);\n        }\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n)\n\nfunc minKBitFlips(nums []int, k int) int {\n    n := len(nums)\n    flips := 0\n    currFlips := 0\n    flip := make([]int, n)\n    for i := 0; i < n; i++ {\n        if i >= k {\n            currFlips -= flip[i-k]\n        }\n        if (nums[i]+currFlips)%2 == 0 {\n            if i+k > n {\n                return -1\n            }\n            flips++\n            currFlips++\n            flip[i] = 1\n        }\n    }\n    return flips\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin) \n    var lines []string\n    for scanner.Scan() {\n        lines = append(lines, strings.TrimSpace(scanner.Text()))\n        if len(lines) == 2 {\n            break\n        }\n    }\n    if scanner.Err() != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    numsLine, kStr := lines[0], lines[1]\n    var nums []int\n    if numsLine != \"[]\" {\n        numsStr := strings.Split(numsLine[1:len(numsLine)-1], \",\")\n        nums = make([]int, len(numsStr))\n        for i, s := range numsStr {\n            val, err := strconv.Atoi(strings.TrimSpace(s))\n            if err != nil || (val != 0 && val != 1) {\n                fmt.Println(\"Invalid input format\")\n                return\n            }\n            nums[i] = val\n        }\n    }\n    k, err := strconv.Atoi(kStr)\n    if err != nil || k < 1 || k > len(nums) {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    result := 0\n    if len(nums) > 0 {\n        result = minKBitFlips(nums, k)\n    }\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minKBitFlips(vector<int>& nums, int k) {\n        int n = nums.size(), flips = 0, currFlips = 0;\n        vector<int> flip(n, 0);\n        for (int i = 0; i < n; i++) {\n            if (i >= k) currFlips -= flip[i - k];\n            if ((nums[i] + currFlips) % 2 == 0) {\n                if (i + k > n) return -1;\n                flips++;\n                currFlips++;\n                flip[i] = 1;\n            }\n        }\n        return flips;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) throw runtime_error(\"Invalid input\");\n        line = line.substr(1, line.length() - 1); // Remove [ and ]\n        vector<int> nums;\n        if (line.empty()) { // Handle empty array\n            int k;\n            if (!(cin >> k) || k < 1) throw runtime_error(\"Invalid input\");\n            cout << 0 << endl; // Empty array needs 0 flips\n            return 0;\n        }\n        size_t pos = 0;\n        while ((pos = line.find(',')) != string::npos) {\n            int n = stoi(line.substr(0, pos));\n            if (n != 0 && n != 1) throw runtime_error(\"Invalid input\");\n            nums.push_back(n);\n            line.erase(0, pos + 1);\n        }\n        int n = stoi(line);\n        if (n != 0 && n != 1) throw runtime_error(\"Invalid input\");\n        nums.push_back(n);\n        int k;\n        if (!(cin >> k) || k < 1 || k > nums.size()) throw runtime_error(\"Invalid input\");\n        Solution sol;\n        int result = sol.minKBitFlips(nums, k);\n        cout << result << endl;\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public int minKBitFlips(int[] nums, int k) {\n        int n = nums.length, flips = 0, currFlips = 0;\n        int[] flip = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (i >= k) currFlips -= flip[i - k];\n            if ((nums[i] + currFlips) % 2 == 0) {\n                if (i + k > n) return -1;\n                flips++;\n                currFlips++;\n                flip[i] = 1;\n            }\n        }\n        return flips;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String numsLine = scanner.nextLine().trim();\n            int k = Integer.parseInt(scanner.nextLine().trim());\n            if (numsLine.equals(\"[]\")) {\n                System.out.println(0); // Empty array requires no flips\n                return;\n            }\n            String[] numsStr = numsLine.substring(1, numsLine.length() - 1).split(\",\");\n            int[] nums = new int[numsStr.length];\n            for (int i = 0; i < numsStr.length; i++) {\n                nums[i] = Integer.parseInt(numsStr[i].trim());\n                if (nums[i] != 0 && nums[i] != 1) throw new Exception(\"Invalid input\");\n            }\n            if (k < 1 || k > nums.length) throw new Exception(\"Invalid input\");\n            Main main = new Main();\n            int result = main.minKBitFlips(nums, k);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "def minKBitFlips(nums, k):\n    n = len(nums)\n    flip = [0] * n\n    curr_flips = 0\n    flips = 0\n    for i in range(n):\n        if i >= k:\n            curr_flips -= flip[i - k]\n        if (nums[i] + curr_flips) % 2 == 0:\n            if i + k > n:\n                return -1\n            flips += 1\n            curr_flips += 1\n            flip[i] = 1\n    return flips\n\n# Input handling\nif __name__ == '__main__':\n    import sys\n    import json\n    try:\n        nums = json.loads(sys.stdin.readline().strip())\n        k = int(sys.stdin.readline().strip())\n        if not isinstance(nums, list) or any(n not in [0, 1] for n in nums) or k < 1 or k > len(nums):\n            raise ValueError('Invalid input')\n        result = minKBitFlips(nums, k)\n        print(result)\n    except Exception:\n        print('Invalid input format')\n        sys.exit(1)",
      "JAVASCRIPT": "/**\n * Returns minimum k-consecutive bit flips needed.\n * @param {number[]} nums - Binary array\n * @param {number} k - Flip length\n * @return {number} - Minimum flips or -1\n */\nfunction minKBitFlips(nums, k) {\n    let flips = 0, n = nums.length;\n    const flip = new Array(n).fill(0);\n    let currFlips = 0;\n    for (let i = 0; i < n; i++) {\n        if (i >= k) currFlips -= flip[i - k];\n        if ((nums[i] + currFlips) % 2 === 0) {\n            if (i + k > n) return -1;\n            flips++;\n            currFlips++;\n            flip[i] = 1;\n        }\n    }\n    return flips;\n}\n\n// Input handling\nconst readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nlet lines = [];\nrl.on('line', (line) => {\n    lines.push(line.trim());\n    if (lines.length === 2) {\n        try {\n            const nums = JSON.parse(lines[0]);\n            const k = parseInt(lines[1]);\n            if (!Array.isArray(nums) || nums.some(n => n !== 0 && n !== 1) || k < 1 || k > nums.length) {\n                throw new Error('Invalid input');\n            }\n            const result = minKBitFlips(nums, k);\n            console.log(result);\n            rl.close();\n        } catch (e) {\n            console.log('Invalid input format');\n            process.exit(1);\n        }\n    }\n});"
    }
  },
  {
    "title": "Count Leaf Nodes in Binary Tree",
    "description": "Given the root of a binary tree, return the number of leaf nodes. A leaf node is a node with no children.\n\n### Problem Statement\nCount the number of leaf nodes in a binary tree.\n\n### Input\n- **root**: Root of a binary tree (0 <= nodes <= 10^4, -100 <= Node.val <= 100).\n\n### Output\n- An integer: number of leaf nodes.\n\n### Example\n**Input**: root = [1,2,3,4,5]  \n**Output**: 3  \n**Input**: root = []  \n**Output**: 0  \n**Input**: root = [1]  \n**Output**: 1\n\n### Notes\nUse DFS or BFS to traverse the tree.\n\n### Real-World Context\nUseful in network topology or organizational charts.",
    "difficulty": "EASY",
    "tags": [
      "Tree",
      "DFS",
      "BFS",
      "Tcs",
      "Cisco"
    ],
    "constraints": [
      "0 <= nodes <= 10^4",
      "-100 <= Node.val <= 100",
      "Time: O(n), where n is nodes",
      "Space: O(h), where h is tree height"
    ],
    "examples": [
      {
        "input": "root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))",
        "output": "3",
        "explanation": "Leaves are 4, 5, 3."
      }
    ],
    "testcases": [
      {
        "input": "[1,2,3,4,5]",
        "output": "3",
        "isHidden": false
      },
      {
        "input": "[]",
        "output": "0",
        "isHidden": false
      },
      {
        "input": "[1]",
        "output": "1",
        "isHidden": true
      }
    ],
    "hints": [
      "1. A leaf node has no left or right child.\\n2. Use recursion to count leaves in subtrees.\\n3. BFS can also count leaves by checking nodes."
    ],
    "editorial": "## Editorial: Count Leaf Nodes\n\n### Problem Recap\nCount leaf nodes (nodes with no children) in a binary tree.\n\n### Intuition\nTraverse the tree, incrementing a counter when a leaf (no left or right child) is found. Use DFS for simplicity.\n\n### Approach\n**Recursive DFS**:\n1. If root is null, return 0.\n2. If root has no children, return 1.\n3. Return countLeaves(left) + countLeaves(right).\n- Time: O(n)\n- Space: O(h)\n\n### Edge Cases\n- Empty tree: [] → 0.\n- Single node: [1] → 1.\n- All leaves: [1,2,3] → 2.",
    "codeSnippets": {
      "GO": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n)\n\ntype TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n\nfunc countLeaves(root *TreeNode) int {\n    // Write your code here\n    return 0\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    scanner.Scan()\n    line := strings.TrimSpace(scanner.Text())\n    if scanner.Err() != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    if line == \"[]\" {\n        fmt.Println(0) // Empty tree\n        return\n    }\n    arr := strings.Split(line[1:len(line)-1], \",\")\n    if len(arr) == 0 || arr[0] == \"\" {\n        fmt.Println(0)\n        return\n    }\n    nodes := make([]*TreeNode, len(arr))\n    for i, s := range arr {\n        s = strings.TrimSpace(s)\n        if s != \"null\" {\n            val, err := strconv.Atoi(s)\n            if err != nil {\n                fmt.Println(\"Invalid input format\")\n                return\n            }\n            nodes[i] = &TreeNode{Val: val}\n        }\n    }\n    for i := 0; i < len(arr); i++ {\n        if nodes[i] != nil {\n            if 2*i+1 < len(nodes) {\n                nodes[i].Left = nodes[2*i+1]\n            }\n            if 2*i+2 < len(nodes) {\n                nodes[i].Right = nodes[2*i+2]\n            }\n        }\n    }\n    result := countLeaves(nodes[0])\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <algorithm> // Added for std::remove\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    int countLeaves(TreeNode* root) {\n        // Write your code here\n        return 0;\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) throw runtime_error(\"Invalid input format\");\n        line.erase(std::remove(line.begin(), line.end(), ' '), line.end()); // Remove whitespace\n        if (line == \"[]\") {\n            cout << 0 << endl; // Empty tree\n            return 0;\n        }\n        line = line.substr(1, line.length() - 2); // Remove [ and ]\n        vector<string> arr;\n        stringstream ss(line);\n        string token;\n        while (getline(ss, token, ',')) arr.push_back(token);\n        if (arr.empty()) {\n            cout << 0 << endl;\n            return 0;\n        }\n        vector<TreeNode*> nodes(arr.size(), nullptr);\n        for (int i = 0; i < arr.size(); i++) {\n            if (arr[i] != \"null\") {\n                nodes[i] = new TreeNode(stoi(arr[i]));\n            }\n        }\n        for (int i = 0; i < arr.size(); i++) {\n            if (nodes[i]) {\n                if (2 * i + 1 < nodes.size()) nodes[i]->left = nodes[2 * i + 1];\n                if (2 * i + 2 < nodes.size()) nodes[i]->right = nodes[2 * i + 2];\n            }\n        }\n        Solution sol;\n        int result = sol.countLeaves(nodes.empty() ? nullptr : nodes[0]);\n        cout << result << endl;\n        // Clean up memory\n        for (TreeNode* node : nodes) {\n            if (node) delete node;\n        }\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\nclass TreeNode {\n    int val;\n    TreeNode left, right;\n    TreeNode(int val) { this.val = val; }\n}\n\npublic class Main {\n    public int countLeaves(TreeNode root) {\n        // Write your code here\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            if (line.equals(\"[]\")) {\n                System.out.println(0); // Empty tree\n                return;\n            }\n            String[] arrStr = line.substring(1, line.length() - 1).split(\",\");\n            if (arrStr.length == 0 || (arrStr.length == 1 && arrStr[0].trim().isEmpty())) {\n                System.out.println(0); // Handle malformed empty input\n                return;\n            }\n            TreeNode[] nodes = new TreeNode[arrStr.length];\n            for (int i = 0; i < arrStr.length; i++) {\n                if (!arrStr[i].trim().equals(\"null\")) {\n                    nodes[i] = new TreeNode(Integer.parseInt(arrStr[i].trim()));\n                }\n            }\n            for (int i = 0; i < arrStr.length; i++) {\n                if (nodes[i] != null) {\n                    if (2 * i + 1 < nodes.length) nodes[i].left = nodes[2 * i + 1];\n                    if (2 * i + 2 < nodes.length) nodes[i].right = nodes[2 * i + 2];\n                }\n            }\n            Main main = new Main();\n            int result = main.countLeaves(nodes.length > 0 ? nodes[0] : null);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class TreeNode:\n    def __init__(self, val=0):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def countLeaves(self, root):\n        # Write your code here\n        return 0\n\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        if line == \"[]\":\n            print(0)  # Empty tree\n            sys.exit(0)\n        arr = line[1:-1].split(',')\n        if not arr or arr[0] == \"\":\n            print(0)\n            sys.exit(0)\n        nodes = [None] * len(arr)\n        for i in range(len(arr)):\n            if arr[i].strip() != \"null\":\n                nodes[i] = TreeNode(int(arr[i].strip()))\n        for i in range(len(arr)):\n            if nodes[i]:\n                if 2 * i + 1 < len(nodes):\n                    nodes[i].left = nodes[2 * i + 1]\n                if 2 * i + 2 < len(nodes):\n                    nodes[i].right = nodes[2 * i + 2]\n        sol = Solution()\n        result = sol.countLeaves(nodes[0] if nodes else None)\n        print(result)\n    except Exception:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "class TreeNode {\n    constructor(val) {\n        this.val = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nfunction countLeaves(root) {\n    // Write your code here\n    return 0;\n}\n\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        line = line.trim();\n        if (line === \"[]\") {\n            console.log(0); // Empty tree\n            rl.close();\n            return;\n        }\n        const arr = line.slice(1, -1).split(\",\");\n        if (!arr || arr[0] === \"\") {\n            console.log(0);\n            rl.close();\n            return;\n        }\n        const nodes = new Array(arr.length).fill(null);\n        for (let i = 0; i < arr.length; i++) {\n            if (arr[i].trim() !== \"null\") {\n                nodes[i] = new TreeNode(parseInt(arr[i].trim()));\n            }\n        }\n        for (let i = 0; i < arr.length; i++) {\n            if (nodes[i]) {\n                if (2 * i + 1 < nodes.length) nodes[i].left = nodes[2 * i + 1];\n                if (2 * i + 2 < nodes.length) nodes[i].right = nodes[2 * i + 2];\n            }\n        }\n        const result = countLeaves(nodes[0] || null);\n        console.log(result);\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n)\n\ntype TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n\nfunc countLeaves(root *TreeNode) int {\n    if root == nil {\n        return 0\n    }\n    if root.Left == nil && root.Right == nil {\n        return 1\n    }\n    return countLeaves(root.Left) + countLeaves(root.Right)\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    scanner.Scan()\n    line := strings.TrimSpace(scanner.Text())\n    if scanner.Err() != nil {\n        fmt.Println(\"Invalid input format\")\n        return\n    }\n    if line == \"[]\" {\n        fmt.Println(0) // Empty tree\n        return\n    }\n    arr := strings.Split(line[1:len(line)-1], \",\")\n    if len(arr) == 0 || arr[0] == \"\" {\n        fmt.Println(0)\n        return\n    }\n    nodes := make([]*TreeNode, len(arr))\n    for i, s := range arr {\n        s = strings.TrimSpace(s)\n        if s != \"null\" {\n            val, err := strconv.Atoi(s)\n            if err != nil {\n                fmt.Println(\"Invalid input format\")\n                return\n            }\n            nodes[i] = &TreeNode{Val: val}\n        }\n    }\n    for i := 0; i < len(arr); i++ {\n        if nodes[i] != nil {\n            if 2*i+1 < len(nodes) {\n                nodes[i].Left = nodes[2*i+1]\n            }\n            if 2*i+2 < len(nodes) {\n                nodes[i].Right = nodes[2*i+2]\n            }\n        }\n    }\n    result := countLeaves(nodes[0])\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <algorithm> // Added for std::remove\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    int countLeaves(TreeNode* root) {\n        if (!root) return 0;\n        if (!root->left && !root->right) return 1;\n        return countLeaves(root->left) + countLeaves(root->right);\n    }\n};\n\nint main() {\n    try {\n        string line;\n        if (!getline(cin, line)) throw runtime_error(\"Invalid input format\");\n        line.erase(std::remove(line.begin(), line.end(), ' '), line.end()); // Remove whitespace\n        if (line == \"[]\") {\n            cout << 0 << endl; // Empty tree\n            return 0;\n        }\n        line = line.substr(1, line.length() - 2); // Remove [ and ]\n        vector<string> arr;\n        stringstream ss(line);\n        string token;\n        while (getline(ss, token, ',')) arr.push_back(token);\n        if (arr.empty()) {\n            cout << 0 << endl;\n            return 0;\n        }\n        vector<TreeNode*> nodes(arr.size(), nullptr);\n        for (int i = 0; i < arr.size(); i++) {\n            if (arr[i] != \"null\") {\n                nodes[i] = new TreeNode(stoi(arr[i]));\n            }\n        }\n        for (int i = 0; i < arr.size(); i++) {\n            if (nodes[i]) {\n                if (2 * i + 1 < nodes.size()) nodes[i]->left = nodes[2 * i + 1];\n                if (2 * i + 2 < nodes.size()) nodes[i]->right = nodes[2 * i + 2];\n            }\n        }\n        Solution sol;\n        int result = sol.countLeaves(nodes.empty() ? nullptr : nodes[0]);\n        cout << result << endl;\n        // Clean up memory\n        for (TreeNode* node : nodes) {\n            if (node) delete node;\n        }\n    } catch (...) {\n        cout << \"Invalid input format\" << endl;\n        return 1;\n    }\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\nclass TreeNode {\n    int val;\n    TreeNode left, right;\n    TreeNode(int val) { this.val = val; }\n}\n\npublic class Main {\n    public int countLeaves(TreeNode root) {\n        if (root == null) return 0;\n        if (root.left == null && root.right == null) return 1;\n        return countLeaves(root.left) + countLeaves(root.right);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            String line = scanner.nextLine().trim();\n            if (line.equals(\"[]\")) {\n                System.out.println(0); // Empty tree\n                return;\n            }\n            String[] arrStr = line.substring(1, line.length() - 1).split(\",\");\n            if (arrStr.length == 0 || (arrStr.length == 1 && arrStr[0].trim().isEmpty())) {\n                System.out.println(0); // Handle malformed empty input\n                return;\n            }\n            TreeNode[] nodes = new TreeNode[arrStr.length];\n            for (int i = 0; i < arrStr.length; i++) {\n                if (!arrStr[i].trim().equals(\"null\")) {\n                    nodes[i] = new TreeNode(Integer.parseInt(arrStr[i].trim()));\n                }\n            }\n            for (int i = 0; i < arrStr.length; i++) {\n                if (nodes[i] != null) {\n                    if (2 * i + 1 < nodes.length) nodes[i].left = nodes[2 * i + 1];\n                    if (2 * i + 2 < nodes.length) nodes[i].right = nodes[2 * i + 2];\n                }\n            }\n            Main main = new Main();\n            int result = main.countLeaves(nodes.length > 0 ? nodes[0] : null);\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"Invalid input format\");\n            System.exit(1);\n        } finally {\n            scanner.close();\n        }\n    }\n}",
      "PYTHON": "class TreeNode:\n    def __init__(self, val=0):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def countLeaves(self, root):\n        if not root:\n            return 0\n        if not root.left and not root.right:\n            return 1\n        return self.countLeaves(root.left) + self.countLeaves(root.right)\n\nif __name__ == \"__main__\":\n    import sys\n    try:\n        line = sys.stdin.readline().strip()\n        if line == \"[]\":\n            print(0)  # Empty tree\n            sys.exit(0)\n        arr = line[1:-1].split(',')\n        if not arr or arr[0] == \"\":\n            print(0)\n            sys.exit(0)\n        nodes = [None] * len(arr)\n        for i in range(len(arr)):\n            if arr[i].strip() != \"null\":\n                nodes[i] = TreeNode(int(arr[i].strip()))\n        for i in range(len(arr)):\n            if nodes[i]:\n                if 2 * i + 1 < len(nodes):\n                    nodes[i].left = nodes[2 * i + 1]\n                if 2 * i + 2 < len(nodes):\n                    nodes[i].right = nodes[2 * i + 2]\n        sol = Solution()\n        result = sol.countLeaves(nodes[0] if nodes else None)\n        print(result)\n    except Exception:\n        print(\"Invalid input format\")\n        sys.exit(1)",
      "JAVASCRIPT": "class TreeNode {\n    constructor(val) {\n        this.val = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nfunction countLeaves(root) {\n    if (!root) return 0;\n    if (!root.left && !root.right) return 1;\n    return countLeaves(root.left) + countLeaves(root.right);\n}\n\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    try {\n        line = line.trim();\n        if (line === \"[]\") {\n            console.log(0); // Empty tree\n            rl.close();\n            return;\n        }\n        const arr = line.slice(1, -1).split(\",\");\n        if (!arr || arr[0] === \"\") {\n            console.log(0);\n            rl.close();\n            return;\n        }\n        const nodes = new Array(arr.length).fill(null);\n        for (let i = 0; i < arr.length; i++) {\n            if (arr[i].trim() !== \"null\") {\n                nodes[i] = new TreeNode(parseInt(arr[i].trim()));\n            }\n        }\n        for (let i = 0; i < arr.length; i++) {\n            if (nodes[i]) {\n                if (2 * i + 1 < nodes.length) nodes[i].left = nodes[2 * i + 1];\n                if (2 * i + 2 < nodes.length) nodes[i].right = nodes[2 * i + 2];\n            }\n        }\n        const result = countLeaves(nodes[0] || null);\n        console.log(result);\n        rl.close();\n    } catch (e) {\n        console.log(\"Invalid input format\");\n        process.exit(1);\n    }\n});"
    }
  },
  {
    "title": "Climbing Stairs",
    "description": "You are climbing a staircase with **n** steps to reach the top. At each step, you can climb either **1** or **2** steps. In how many distinct ways can you climb to the top?\n\n### Problem Statement\nGiven a positive integer **n** representing the number of steps in a staircase, compute the number of unique ways to reach the top. Each move allows you to advance by either 1 or 2 steps.\n\n### Input\n- **n**: A positive integer representing the number of steps (1 <= n <= 45).\n\n### Output\n- An integer representing the number of distinct ways to climb to the top.\n\n### Example\n**Input**: n = 2  \n**Output**: 2  \n**Explanation**:  \nThere are two ways to climb to the top:  \n1. 1 step + 1 step  \n2. 2 steps\n\n### Notes\n- The answer will fit within a 32-bit signed integer.\n- Consider optimizing for both time and space complexity, as n can be up to 45.\n- This problem is a classic example of dynamic programming, similar to computing Fibonacci numbers.\n\n### Real-World Context\nThis problem models scenarios like counting possible sequences in decision-making processes (e.g., ways to schedule tasks with 1 or 2 time units) or paths in recursive systems.",
    "difficulty": "EASY",
    "tags": [
      "Google",
      "Atlassian",
      "Dynamic Programming",
      "Math",
      "Memoization",
      "Fibonacci"
    ],
    "constraints": [
      "- 1 <= n <= 45",
      "- Input is a positive integer.",
      "- The output must fit within a 32-bit signed integer.",
      "- Time complexity should be O(n) or better.",
      "- Space complexity should be O(1) or O(n) depending on the approach."
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three distinct ways to climb a staircase with 3 steps:\n1. [1,1,1]: Take 1 step three times.\n2. [1,2]: Take 1 step, then 2 steps.\n3. [2,1]: Take 2 steps, then 1 step.\n\n**Visual Path**:\n- Step 0 -> Step 1 -> Step 2 -> Step 3 (1,1,1)\n- Step 0 -> Step 1 -> Step 3 (1,2)\n- Step 0 -> Step 2 -> Step 3 (2,1)"
      }
    ],
    "testcases": [
      {
        "input": "1",
        "output": "1",
        "isHidden": false
      },
      {
        "input": "2",
        "output": "2",
        "isHidden": false
      },
      {
        "input": "3",
        "output": "3",
        "isHidden": false
      },
      {
        "input": "4",
        "output": "5",
        "isHidden": false
      },
      {
        "input": "10",
        "output": "89",
        "isHidden": true
      },
      {
        "input": "45",
        "output": "1836311903",
        "isHidden": false
      },
      {
        "input": "6",
        "output": "13",
        "isHidden": false
      },
      {
        "input": "5",
        "output": "8",
        "isHidden": false
      }
    ],
    "hints": [
      "1. **Basic Approach**: To reach step n, you can arrive from step (n-1) by taking 1 step or from step (n-2) by taking 2 steps. How can you combine these possibilities?",
      "2. **Recursive Insight**: The number of ways to reach step n is the sum of ways to reach step (n-1) and step (n-2). Does this resemble a known sequence?",
      "3. **Optimization**: A naive recursive solution may be slow for large n. Consider storing intermediate results (memoization) or using a bottom-up approach.",
      "4. **Space Efficiency**: Can you solve it using only a few variables instead of an array to store all steps?"
    ],
    "editorial": "## Editorial: Climbing Stairs\n\n### Problem Recap\nThe task is to compute the number of distinct ways to climb a staircase of **n** steps, where each move is either 1 or 2 steps. This is a classic dynamic programming problem due to its recursive structure and overlapping subproblems.\n\n### Intuition\nTo reach step **n**, you must come from:\n- **Step (n-1)** by taking 1 step, or\n- **Step (n-2)** by taking 2 steps.\n\nThus, the number of ways to reach step **n** is the sum of ways to reach step **(n-1)** and step **(n-2)**. This forms a recursive relation:  \n**ways(n) = ways(n-1) + ways(n-2)**  \nWith base cases:  \n- **ways(1) = 1** (one way: 1 step)\n- **ways(2) = 2** (two ways: 1+1, 2)\n\nThis resembles the Fibonacci sequence, where each number is the sum of the two preceding ones.\n\n### Approaches\n\n#### 1. Dynamic Programming (Bottom-Up, Array-Based)\n- **Idea**: Use an array 'dp' where 'dp[i]' stores the number of ways to reach step **i**.\n- **Steps**:\n  1. Initialize 'dp[1] = 1', 'dp[2] = 2'.\n  2. For each step 'i' from 3 to n, compute 'dp[i] = dp[i-1] + dp[i-2]'.\n  3. Return 'dp[n]'.\n- **Time Complexity**: O(n) for iterating from 3 to n.\n- **Space Complexity**: O(n) for the 'dp' array.\n- **Pros**: Simple and clear.\n- **Cons**: Uses O(n) space, which can be optimized.\n\n#### 2. Dynamic Programming (Constant Space)\n- **Idea**: Since we only need the last two values ('ways(n-1)' and 'ways(n-2)'), use two variables instead of an array.\n- **Steps**:\n  1. Initialize 'a = 1' (ways for 1 step), 'b = 2' (ways for 2 steps).\n  2. For each step 'i' from 3 to n:\n     - Compute 'temp = a + b'.\n     - Update 'a = b', 'b = temp'.\n  3. Return 'b' (or 'a' if n = 1).\n- **Time Complexity**: O(n) for the loop.\n- **Space Complexity**: O(1) since only two variables are used.\n- **Pros**: Optimal space usage.\n- **Cons**: Slightly less intuitive for beginners.\n\n#### 3. Memoized Recursion (Top-Down)\n- **Idea**: Use recursion with a cache to store computed results.\n- **Steps**:\n  1. Define a recursive function 'ways(n)' that returns 'ways(n-1) + ways(n-2)'.\n  2. Use a cache (e.g., array or map) to store results for each n.\n  3. Base cases: 'ways(1) = 1', 'ways(2) = 2'.\n- **Time Complexity**: O(n) as each n is computed once.\n- **Space Complexity**: O(n) for the cache.\n- **Pros**: Intuitive for recursive thinkers.\n- **Cons**: Overhead of recursion and cache management.\n\n### Recommended Solution\nThe constant-space dynamic programming approach is recommended for its simplicity and efficiency (O(n) time, O(1) space). It avoids unnecessary memory allocation while remaining easy to understand.\n\n### Complexity Analysis\n- **Time Complexity**: O(n) for iterating through steps 3 to n.\n- **Space Complexity**: O(1) using only two variables.\n- **Constraints Handling**: For n <= 45, the output (Fibonacci-like) fits within a 32-bit integer (e.g., ways(45) ≈ 1.83 billion).\n\n### Edge Cases\n- **n = 1**: Only one way (1 step).\n- **n = 2**: Two ways (1+1, 2).\n- **n = 45**: Large input, requires efficient computation to avoid timeouts.\n- **Invalid Inputs**: Not applicable, as constraints guarantee 1 <= n <= 45.\n\n### Implementation Notes\n- Ensure the solution handles n = 1 correctly (return 1, not b).\n- Use integer types to avoid overflow (safe for n <= 45).\n- In practice, validate inputs if the platform allows non-constrained inputs.\n\n### Visual Explanation\nFor n = 4:\n- Ways to reach step 4:\n  - From step 3 (1 step): ways(3) = 3\n  - From step 2 (2 steps): ways(2) = 2\n  - Total: ways(4) = 3 + 2 = 5\n- Paths: [1,1,1,1], [1,1,2], [1,2,1], [2,1,1], [2,2]\n\nThis problem teaches dynamic programming fundamentals and optimization techniques, making it an excellent learning exercise for beginners and intermediate coders.",
    "codeSnippets": {
      "GO": "package main\n\nimport \"fmt\"\n\nfunc climbStairs(n int) int {\n    // Write your Code here:\n    if n <= 2 {\n        return n\n    }\n    prev1, prev2 := 1, 2\n    for i := 3; i <= n; i++ {\n        current := prev1 + prev2\n        prev1, prev2 = prev2, current\n    }\n    return prev2\n}\n\nfunc main() {\n    var n int\n    fmt.Scan(&n)\n    result := climbStairs(n)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        // Write your Code here:\n        if (n <= 2) return n;\n        int prev1 = 1, prev2 = 2;\n        for (int i = 3; i <= n; i++) {\n            int current = prev1 + prev2;\n            prev1 = prev2;\n            prev2 = current;\n        }\n        return prev2;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    Solution sol;\n    cout << sol.climbStairs(n) << endl;\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Computes the number of distinct ways to climb n steps, taking 1 or 2 steps at a time.\n     * @param n Number of steps (1 <= n <= 45)\n     * @return Number of distinct ways\n     */\n    public int climbStairs(int n) {\n        // Write your Code here:\n        if (n <= 2) {\n            return n;\n        }\n        \n        // Use two variables to track ways for previous two steps\n        int prev1 = 1; // Ways to climb 1 step\n        int prev2 = 2; // Ways to climb 2 steps\n        \n        // Iterate from step 3 to n\n        for (int i = 3; i <= n; i++) {\n            int current = prev1 + prev2; // Ways to reach current step\n            prev1 = prev2; // Shift for next iteration\n            prev2 = current;\n        }\n        \n        return prev2;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = Integer.parseInt(scanner.nextLine().trim());\n        Main main = new Main();\n        int result = main.climbStairs(n);\n        System.out.println(result);\n        scanner.close();\n    }\n}",
      "PYTHON": "class Solution:\n    def climbStairs(self, n):\n        \"\"\"\n        Computes the number of distinct ways to climb n steps, taking 1 or 2 steps at a time.\n        :param n: Number of steps (1 <= n <= 45)\n        :return: Number of distinct ways\n        \"\"\"\n        # Write your Code here:\n        if n <= 2:\n            return n\n        \n        # Use two variables to track ways for previous two steps\n        prev1, prev2 = 1, 2  # Ways for 1 and 2 steps\n        \n        # Iterate from step 3 to n\n        for i in range(3, n + 1):\n            current = prev1 + prev2  # Ways to reach current step\n            prev1, prev2 = prev2, current  # Shift for next iteration\n        \n        return prev2\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    n = int(sys.stdin.readline().strip())\n    sol = Solution()\n    result = sol.climbStairs(n)\n    print(result)",
      "JAVASCRIPT": "/**\n * Computes the number of distinct ways to climb n steps, taking 1 or 2 steps at a time.\n * @param {number} n - Number of steps (1 <= n <= 45)\n * @return {number} - Number of distinct ways\n */\nfunction climbStairs(n) {\n    // Write your Code here:\n    if (n <= 2) return n;\n    \n    // Use two variables to track ways for previous two steps\n    let prev1 = 1; // Ways to climb 1 step\n    let prev2 = 2; // Ways to climb 2 steps\n    \n    // Iterate from step 3 to n\n    for (let i = 3; i <= n; i++) {\n        const current = prev1 + prev2; // Ways to reach current step\n        prev1 = prev2; // Shift for next iteration\n        prev2 = current;\n    }\n    \n    return prev2;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    const n = parseInt(line.trim());\n    const result = climbStairs(n);\n    console.log(result);\n    rl.close();\n});"
    },
    "referenceSolutions": {
      "GO": "package main\n\nimport \"fmt\"\n\nfunc climbStairs(n int) int {\n    if n <= 2 {\n        return n\n    }\n    prev1, prev2 := 1, 2\n    for i := 3; i <= n; i++ {\n        current := prev1 + prev2\n        prev1, prev2 = prev2, current\n    }\n    return prev2\n}\n\nfunc main() {\n    var n int\n    fmt.Scan(&n)\n    result := climbStairs(n)\n    fmt.Println(result)\n}",
      "C++": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        if (n <= 2) return n;\n        int prev1 = 1, prev2 = 2;\n        for (int i = 3; i <= n; i++) {\n            int current = prev1 + prev2;\n            prev1 = prev2;\n            prev2 = current;\n        }\n        return prev2;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    Solution sol;\n    cout << sol.climbStairs(n) << endl;\n    return 0;\n}",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    /**\n     * Computes the number of distinct ways to climb n steps, taking 1 or 2 steps at a time.\n     * @param n Number of steps (1 <= n <= 45)\n     * @return Number of distinct ways\n     */\n    public int climbStairs(int n) {\n        // Handle base cases\n        if (n <= 2) {\n            return n;\n        }\n        \n        // Use two variables to track ways for previous two steps\n        int prev1 = 1; // Ways to climb 1 step\n        int prev2 = 2; // Ways to climb 2 steps\n        \n        // Iterate from step 3 to n\n        for (int i = 3; i <= n; i++) {\n            int current = prev1 + prev2; // Ways to reach current step\n            prev1 = prev2; // Shift for next iteration\n            prev2 = current;\n        }\n        \n        return prev2;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = Integer.parseInt(scanner.nextLine().trim());\n        Main main = new Main();\n        int result = main.climbStairs(n);\n        System.out.println(result);\n        scanner.close();\n    }\n}",
      "PYTHON": "class Solution:\n    def climbStairs(self, n):\n        \"\"\"\n        Computes the number of distinct ways to climb n steps, taking 1 or 2 steps at a time.\n        :param n: Number of steps (1 <= n <= 45)\n        :return: Number of distinct ways\n        \"\"\"\n        # Handle base cases\n        if n <= 2:\n            return n\n        \n        # Use two variables to track ways for previous two steps\n        prev1, prev2 = 1, 2  # Ways for 1 and 2 steps\n        \n        # Iterate from step 3 to n\n        for i in range(3, n + 1):\n            current = prev1 + prev2  # Ways to reach current step\n            prev1, prev2 = prev2, current  # Shift for next iteration\n        \n        return prev2\n\n# Input handling\nif __name__ == \"__main__\":\n    import sys\n    n = int(sys.stdin.readline().strip())\n    sol = Solution()\n    result = sol.climbStairs(n)\n    print(result)",
      "JAVASCRIPT": "/**\n * Computes the number of distinct ways to climb n steps, taking 1 or 2 steps at a time.\n * @param {number} n - Number of steps (1 <= n <= 45)\n * @return {number} - Number of distinct ways\n */\nfunction climbStairs(n) {\n    // Handle base cases\n    if (n <= 2) return n;\n    \n    // Use two variables to track ways for previous two steps\n    let prev1 = 1; // Ways to climb 1 step\n    let prev2 = 2; // Ways to climb 2 steps\n    \n    // Iterate from step 3 to n\n    for (let i = 3; i <= n; i++) {\n        const current = prev1 + prev2; // Ways to reach current step\n        prev1 = prev2; // Shift for next iteration\n        prev2 = current;\n    }\n    \n    return prev2;\n}\n\n// Input handling\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n});\n\nrl.on(\"line\", (line) => {\n    const n = parseInt(line.trim());\n    const result = climbStairs(n);\n    console.log(result);\n    rl.close();\n});"
    }
  }
]